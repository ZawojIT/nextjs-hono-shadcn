TITLE: Creating a Basic Query with useQuery Hook in React
DESCRIPTION: This snippet demonstrates how to create a basic query using the useQuery hook from TanStack Query. It shows the minimal required parameters: a unique query key and a query function.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/queries.md#2025-04-19_snippet_0

LANGUAGE: tsx
CODE:
```
import { useQuery } from '@tanstack/react-query'

function App() {
  const info = useQuery({ queryKey: ['todos'], queryFn: fetchTodoList })
}
```

----------------------------------------

TITLE: Implementing React Query Core Concepts in a Todo App
DESCRIPTION: This snippet demonstrates how to use React Query's core features in a Todo application. It shows the setup of QueryClient, usage of useQuery for fetching data, useMutation for adding new todos, and query invalidation for refreshing data after mutations.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/quick-start.md#2025-04-19_snippet_0

LANGUAGE: tsx
CODE:
```
import {
  useQuery,
  useMutation,
  useQueryClient,
  QueryClient,
  QueryClientProvider,
} from '@tanstack/react-query'
import { getTodos, postTodo } from '../my-api'

// Create a client
const queryClient = new QueryClient()

function App() {
  return (
    // Provide the client to your App
    <QueryClientProvider client={queryClient}>
      <Todos />
    </QueryClientProvider>
  )
}

function Todos() {
  // Access the client
  const queryClient = useQueryClient()

  // Queries
  const query = useQuery({ queryKey: ['todos'], queryFn: getTodos })

  // Mutations
  const mutation = useMutation({
    mutationFn: postTodo,
    onSuccess: () => {
      // Invalidate and refetch
      queryClient.invalidateQueries({ queryKey: ['todos'] })
    },
  })

  return (
    <div>
      <ul>{query.data?.map((todo) => <li key={todo.id}>{todo.title}</li>)}</ul>

      <button
        onClick={() => {
          mutation.mutate({
            id: Date.now(),
            title: 'Do Laundry',
          })
        }}
      >
        Add Todo
      </button>
    </div>
  )
}

render(<App />, document.getElementById('root'))
```

----------------------------------------

TITLE: Handling Query States in Vue Template with TanStack Query
DESCRIPTION: This example shows how to use the useQuery hook in a Vue component's setup script and handle different query states (loading, error, success) in the template. It demonstrates destructuring the query result and using Vue's template syntax to conditionally render content based on the query state.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/queries.md#2025-04-19_snippet_1

LANGUAGE: vue
CODE:
```
<script setup>
import { useQuery } from '@tanstack/vue-query'

const { isPending, isError, data, error } = useQuery({
  queryKey: ['todos'],
  queryFn: fetchTodoList,
})
</script>

<template>
  <span v-if="isPending">Loading...</span>
  <span v-else-if="isError">Error: {{ error.message }}</span>
  <!-- We can assume by this point that `isSuccess === true` -->
  <ul v-else-if="data">
    <li v-for="todo in data" :key="todo.id">{{ todo.title }}</li>
  </ul>
</template>
```

----------------------------------------

TITLE: Implementing Dependent Query with useQuery in React
DESCRIPTION: This snippet demonstrates how to create a dependent query using the useQuery hook. It first fetches user data, then uses the user ID to fetch the user's projects only when the user data is available.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/dependent-queries.md#2025-04-19_snippet_0

LANGUAGE: tsx
CODE:
```
// Get the user
const { data: user } = useQuery({
  queryKey: ['user', email],
  queryFn: getUserByEmail,
})

const userId = user?.id

// Then get the user's projects
const {
  status,
  fetchStatus,
  data: projects,
} = useQuery({
  queryKey: ['projects', userId],
  queryFn: getProjectsByUser,
  // The query will not execute until the userId exists
  enabled: !!userId,
})
```

----------------------------------------

TITLE: Using Status State for Query Handling in Angular
DESCRIPTION: Demonstrates an alternative approach to handling query states using the status property instead of boolean flags. It uses a switch statement in the template to render different content based on the query status.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/queries.md#2025-04-19_snippet_3

LANGUAGE: angular-ts
CODE:
```
@Component({
  selector: 'todos',
  standalone: true,
  template: `
    @switch (todos.status()) {
      @case ('pending') {
        <span>Loading...</span>
      }
      @case ('error') {
        <span>Error: {{ todos.error()?.message }}</span>
      }
      <!-- also status === 'success', but "else" logic works, too -->
      @default {
        <ul>
          @for (todo of todos.data(); track todo.id) {
            <li>{{ todo.title }}</li>
          } @empty {
            <li>No todos found</li>
          }
        </ul>
      }
    }
  `,
})
class TodosComponent {}
```

----------------------------------------

TITLE: Basic Query Usage in Vue with TanStack Query
DESCRIPTION: This snippet demonstrates the basic usage of a query in a Vue component using the useQuery hook from @tanstack/vue-query. It sets up a query to fetch a list of todos.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/queries.md#2025-04-19_snippet_0

LANGUAGE: typescript
CODE:
```
import { useQuery } from '@tanstack/vue-query'

const result = useQuery({ queryKey: ['todos'], queryFn: fetchTodoList })
```

----------------------------------------

TITLE: Updating a Single Todo with Cache-based Optimistic Updates in React Query
DESCRIPTION: Demonstrates how to optimistically update a single todo item in the cache, with error handling and rollback functionality.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/optimistic-updates.md#2025-04-19_snippet_5

LANGUAGE: tsx
CODE:
```
useMutation({
  mutationFn: updateTodo,
  // When mutate is called:
  onMutate: async (newTodo) => {
    // Cancel any outgoing refetches
    // (so they don't overwrite our optimistic update)
    await queryClient.cancelQueries({ queryKey: ['todos', newTodo.id] })

    // Snapshot the previous value
    const previousTodo = queryClient.getQueryData(['todos', newTodo.id])

    // Optimistically update to the new value
    queryClient.setQueryData(['todos', newTodo.id], newTodo)

    // Return a context with the previous and new todo
    return { previousTodo, newTodo }
  },
  // If the mutation fails, use the context we returned above
  onError: (err, newTodo, context) => {
    queryClient.setQueryData(
      ['todos', context.newTodo.id],
      context.previousTodo,
    )
  },
  // Always refetch after error or success:
  onSettled: (newTodo) =>
    queryClient.invalidateQueries({ queryKey: ['todos', newTodo.id] }),
})
```

----------------------------------------

TITLE: Mutation Lifecycle Callbacks
DESCRIPTION: Demonstrates implementation of mutation lifecycle callbacks including onMutate, onError, onSuccess, and onSettled.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/mutations.md#2025-04-19_snippet_3

LANGUAGE: tsx
CODE:
```
useMutation({
  mutationFn: addTodo,
  onMutate: (variables) => {
    return { id: 1 }
  },
  onError: (error, variables, context) => {
    console.log(`rolling back optimistic update with id ${context.id}`)
  },
  onSuccess: (data, variables, context) => {
  },
  onSettled: (data, error, variables, context) => {
  },
})
```

----------------------------------------

TITLE: Implementing Basic GitHub Repository Data Fetching with TanStack Query
DESCRIPTION: Demonstrates the basic setup and usage of TanStack Query to fetch GitHub repository statistics. Shows initialization of QueryClient, QueryClientProvider wrapper, and implementation of a query using useQuery hook to fetch and display repository data with loading and error states.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/overview.md#2025-04-19_snippet_0

LANGUAGE: tsx
CODE:
```
import {
  QueryClient,
  QueryClientProvider,
  useQuery,
} from '@tanstack/react-query'

const queryClient = new QueryClient()

export default function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <Example />
    </QueryClientProvider>
  )
}

function Example() {
  const { isPending, error, data } = useQuery({
    queryKey: ['repoData'],
    queryFn: () =>
      fetch('https://api.github.com/repos/TanStack/query').then((res) =>
        res.json(),
      ),
  })

  if (isPending) return 'Loading...'

  if (error) return 'An error has occurred: ' + error.message

  return (
    <div>
      <h1>{data.name}</h1>
      <p>{data.description}</p>
      <strong>üëÄ {data.subscribers_count}</strong>{' '}
      <strong>‚ú® {data.stargazers_count}</strong>{' '}
      <strong>üç¥ {data.forks_count}</strong>
    </div>
  )
}
```

----------------------------------------

TITLE: Basic Todo Creation Mutation Example
DESCRIPTION: Demonstrates implementing a basic mutation to add a new todo item using the useMutation hook. Shows handling of pending, error, and success states.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/mutations.md#2025-04-19_snippet_0

LANGUAGE: tsx
CODE:
```
function App() {
  const mutation = useMutation({
    mutationFn: (newTodo) => {
      return axios.post('/todos', newTodo)
    },
  })

  return (
    <div>
      {mutation.isPending ? (
        'Adding todo...'
      ) : (
        <>
          {mutation.isError ? (
            <div>An error occurred: {mutation.error.message}</div>
          ) : null}

          {mutation.isSuccess ? <div>Todo added!</div> : null}

          <button
            onClick={() => {
              mutation.mutate({ id: new Date(), title: 'Do Laundry' })
            }}
          >
            Create Todo
          </button>
        </>
      )}
    </div>
  )
```

----------------------------------------

TITLE: Using Fetch with TanStack Query and Error Handling (TSX)
DESCRIPTION: Shows how to use the fetch API with TanStack Query, including manual error throwing for unsuccessful HTTP calls, as fetch doesn't throw errors by default.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/query-functions.md#2025-04-19_snippet_2

LANGUAGE: tsx
CODE:
```
useQuery({
  queryKey: ['todos', todoId],
  queryFn: async () => {
    const response = await fetch('/todos/' + todoId)
    if (!response.ok) {
      throw new Error('Network response was not ok')
    }
    return response.json()
  },
})
```

----------------------------------------

TITLE: Persisting and Resuming Mutations in React Query
DESCRIPTION: This snippet demonstrates how to persist mutations to storage and resume them later. It includes setting mutation defaults, handling optimistic updates, and using hydration functions for persistence.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/mutations.md#2025-04-19_snippet_9

LANGUAGE: tsx
CODE:
```
const queryClient = new QueryClient()

// Define the "addTodo" mutation
queryClient.setMutationDefaults(['addTodo'], {
  mutationFn: addTodo,
  onMutate: async (variables) => {
    // Cancel current queries for the todos list
    await queryClient.cancelQueries({ queryKey: ['todos'] })

    // Create optimistic todo
    const optimisticTodo = { id: uuid(), title: variables.title }

    // Add optimistic todo to todos list
    queryClient.setQueryData(['todos'], (old) => [...old, optimisticTodo])

    // Return context with the optimistic todo
    return { optimisticTodo }
  },
  onSuccess: (result, variables, context) => {
    // Replace optimistic todo in the todos list with the result
    queryClient.setQueryData(['todos'], (old) =>
      old.map((todo) =>
        todo.id === context.optimisticTodo.id ? result : todo,
      ),
    )
  },
  onError: (error, variables, context) => {
    // Remove optimistic todo from the todos list
    queryClient.setQueryData(['todos'], (old) =>
      old.filter((todo) => todo.id !== context.optimisticTodo.id),
    )
  },
  retry: 3,
})

// Start mutation in some component:
const mutation = useMutation({ mutationKey: ['addTodo'] })
mutation.mutate({ title: 'title' })

// If the mutation has been paused because the device is for example offline,
// Then the paused mutation can be dehydrated when the application quits:
const state = dehydrate(queryClient)

// The mutation can then be hydrated again when the application is started:
hydrate(queryClient, state)

// Resume the paused mutations:
queryClient.resumePausedMutations()
```

----------------------------------------

TITLE: Basic Query Caching with TanStack Query
DESCRIPTION: Demonstrates the usage of useQuery hook with a todos query showcasing caching behavior. The example uses default gcTime of 5 minutes and staleTime of 0, showing how data is cached, shared between instances, and eventually garbage collected.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/caching.md#2025-04-19_snippet_0

LANGUAGE: javascript
CODE:
```
useQuery({ queryKey: ['todos'], queryFn: fetchTodos })
```

----------------------------------------

TITLE: Basic Query Invalidation in TanStack Query
DESCRIPTION: Demonstrates basic query invalidation methods using QueryClient. Shows how to invalidate all queries in cache or queries with specific key prefixes.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/query-invalidation.md#2025-04-19_snippet_0

LANGUAGE: tsx
CODE:
```
// Invalidate every query in the cache
queryClient.invalidateQueries()
// Invalidate every query with a key that starts with `todos`
queryClient.invalidateQueries({ queryKey: ['todos'] })
```

----------------------------------------

TITLE: Using useMutation Hook in TanStack Query (TSX)
DESCRIPTION: This snippet demonstrates how to use the useMutation hook in TanStack Query. It shows the hook's usage with various options and the structure of the returned object. The mutate function is also shown with its parameters.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/reference/useMutation.md#2025-04-19_snippet_0

LANGUAGE: tsx
CODE:
```
const {
  data,
  error,
  isError,
  isIdle,
  isPending,
  isPaused,
  isSuccess,
  failureCount,
  failureReason,
  mutate,
  mutateAsync,
  reset,
  status,
  submittedAt,
  variables,
} = useMutation(
  {
    mutationFn,
    gcTime,
    meta,
    mutationKey,
    networkMode,
    onError,
    onMutate,
    onSettled,
    onSuccess,
    retry,
    retryDelay,
    scope,
    throwOnError,
  },
  queryClient,
)

mutate(variables, {
  onError,
  onSettled,
  onSuccess,
})
```

----------------------------------------

TITLE: Implementing Manual Parallel Queries with TanStack Query
DESCRIPTION: Demonstrates how to execute multiple queries in parallel using individual useQuery hooks. Each query runs independently and concurrently to maximize fetching efficiency.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/parallel-queries.md#2025-04-19_snippet_0

LANGUAGE: tsx
CODE:
```
function App () {
  // The following queries will execute in parallel
  const usersQuery = useQuery({ queryKey: ['users'], queryFn: fetchUsers })
  const teamsQuery = useQuery({ queryKey: ['teams'], queryFn: fetchTeams })
  const projectsQuery = useQuery({ queryKey: ['projects'], queryFn: fetchProjects })
  ...
}
```

----------------------------------------

TITLE: Improved Paginated Query with placeholderData in TanStack Query
DESCRIPTION: This example shows an improved implementation of paginated queries using the placeholderData feature. It uses keepPreviousData to maintain the previous data while fetching new data, providing a smoother user experience.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/paginated-queries.md#2025-04-19_snippet_1

LANGUAGE: tsx
CODE:
```
import { keepPreviousData, useQuery } from '@tanstack/react-query'
import React from 'react'

function Todos() {
  const [page, setPage] = React.useState(0)

  const fetchProjects = (page = 0) =>
    fetch('/api/projects?page=' + page).then((res) => res.json())

  const { isPending, isError, error, data, isFetching, isPlaceholderData } =
    useQuery({
      queryKey: ['projects', page],
      queryFn: () => fetchProjects(page),
      placeholderData: keepPreviousData,
    })

  return (
    <div>
      {isPending ? (
        <div>Loading...</div>
      ) : isError ? (
        <div>Error: {error.message}</div>
      ) : (
        <div>
          {data.projects.map((project) => (
            <p key={project.id}>{project.name}</p>
          ))}
        </div>
      )}
      <span>Current Page: {page + 1}</span>
      <button
        onClick={() => setPage((old) => Math.max(old - 1, 0))}
        disabled={page === 0}
      >
        Previous Page
      </button>
      <button
        onClick={() => {
          if (!isPlaceholderData && data.hasMore) {
            setPage((old) => old + 1)
          }
        }}
        // Disable the Next Page button until we know a next page is available
        disabled={isPlaceholderData || !data?.hasMore}
      >
        Next Page
      </button>
      {isFetching ? <span> Loading...</span> : null}
    </div>
  )
}
```

----------------------------------------

TITLE: Using Query Status Instead of Booleans in React
DESCRIPTION: This snippet illustrates an alternative approach to handling query states using the status property instead of boolean flags. It shows how to check for 'pending', 'error', and 'success' states.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/queries.md#2025-04-19_snippet_3

LANGUAGE: tsx
CODE:
```
function Todos() {
  const { status, data, error } = useQuery({
    queryKey: ['todos'],
    queryFn: fetchTodoList,
  })

  if (status === 'pending') {
    return <span>Loading...</span>
  }

  if (status === 'error') {
    return <span>Error: {error.message}</span>
  }

  // also status === 'success', but "else" logic works, too
  return (
    <ul>
      {data.map((todo) => (
        <li key={todo.id}>{todo.title}</li>
      ))}
    </ul>
  )
}
```

----------------------------------------

TITLE: Accessing Query Result Object in React
DESCRIPTION: This snippet shows how to access the result object returned by the useQuery hook. The result object contains all the information about the query, including its state and data.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/queries.md#2025-04-19_snippet_1

LANGUAGE: tsx
CODE:
```
const result = useQuery({ queryKey: ['todos'], queryFn: fetchTodoList })
```

----------------------------------------

TITLE: Using initialData in TanStack Query (TypeScript/React)
DESCRIPTION: This snippet demonstrates how to use the 'initialData' option in a TanStack Query to prepopulate the cache with initial data for a query, skipping the initial loading state.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/initial-query-data.md#2025-04-19_snippet_0

LANGUAGE: tsx
CODE:
```
const result = useQuery({
  queryKey: ['todos'],
  queryFn: () => fetch('/todos'),
  initialData: initialTodos,
})
```

----------------------------------------

TITLE: Testing Custom Hook Implementation
DESCRIPTION: Basic test setup for a React Query custom hook using React Testing Library.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/testing.md#2025-04-19_snippet_2

LANGUAGE: tsx
CODE:
```
import { renderHook, waitFor } from '@testing-library/react'

const queryClient = new QueryClient()
const wrapper = ({ children }) => (
  <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
)

const { result } = renderHook(() => useCustomHook(), { wrapper })

await waitFor(() => expect(result.current.isSuccess).toBe(true))

expect(result.current.data).toEqual('Hello')
```

----------------------------------------

TITLE: Mutation State Reset Example
DESCRIPTION: Shows how to implement mutation state reset functionality in a todo creation form, handling error states and form input.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/mutations.md#2025-04-19_snippet_2

LANGUAGE: tsx
CODE:
```
const CreateTodo = () => {
  const [title, setTitle] = useState('')
  const mutation = useMutation({ mutationFn: createTodo })

  const onCreateTodo = (e) => {
    e.preventDefault()
    mutation.mutate({ title })
  }

  return (
    <form onSubmit={onCreateTodo}>
      {mutation.error && (
        <h5 onClick={() => mutation.reset()}>{mutation.error}</h5>
      )}
      <input
        type="text"
        value={title}
        onChange={(e) => setTitle(e.target.value)}
      />
      <br />
      <button type="submit">Create Todo</button>
    </form>
  )
```

----------------------------------------

TITLE: Implementing Dynamic Parallel Dependent Queries with useQueries in React
DESCRIPTION: This example shows how to create dynamic parallel dependent queries using the useQueries hook. It first fetches user IDs, then uses these IDs to fetch messages for each user in parallel.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/dependent-queries.md#2025-04-19_snippet_1

LANGUAGE: tsx
CODE:
```
// Get the users ids
const { data: userIds } = useQuery({
  queryKey: ['users'],
  queryFn: getUsersData,
  select: (users) => users.map((user) => user.id),
})

// Then get the users messages
const usersMessages = useQueries({
  queries: userIds
    ? userIds.map((id) => {
        return {
          queryKey: ['messages', id],
          queryFn: () => getMessagesByUsers(id),
        }
      })
    : [], // if users is undefined, an empty array will be returned
})
```

----------------------------------------

TITLE: React Query with Next.js Server Components
DESCRIPTION: Implementation of React Query with Next.js server components using ReactQueryStreamedHydration
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/suspense.md#2025-04-19_snippet_3

LANGUAGE: tsx
CODE:
```
'use client'

import {
  isServer,
  QueryClient,
  QueryClientProvider,
} from '@tanstack/react-query'
import * as React from 'react'
import { ReactQueryStreamedHydration } from '@tanstack/react-query-next-experimental'

function makeQueryClient() {
  return new QueryClient({
    defaultOptions: {
      queries: {
        staleTime: 60 * 1000,
      },
    },
  })
}

let browserQueryClient: QueryClient | undefined = undefined

function getQueryClient() {
  if (isServer) {
    return makeQueryClient()
  } else {
    if (!browserQueryClient) browserQueryClient = makeQueryClient()
    return browserQueryClient
  }
}

export function Providers(props: { children: React.ReactNode }) {
  const queryClient = getQueryClient()

  return (
    <QueryClientProvider client={queryClient}>
      <ReactQueryStreamedHydration>
        {props.children}
      </ReactQueryStreamedHydration>
    </QueryClientProvider>
  )
}
```

----------------------------------------

TITLE: Using useQueries for Dynamic Parallel Queries
DESCRIPTION: Shows how to use the useQueries hook to dynamically execute multiple queries in parallel based on a variable number of items. This approach is necessary when the number of queries changes between renders.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/parallel-queries.md#2025-04-19_snippet_1

LANGUAGE: tsx
CODE:
```
function App({ users }) {
  const userQueries = useQueries({
    queries: users.map((user) => {
      return {
        queryKey: ['user', user.id],
        queryFn: () => fetchUserById(user.id),
      }
    }),
  })
}
```

----------------------------------------

TITLE: Using queryOptions for Type-Safe Query Configuration
DESCRIPTION: Demonstrates how to use the queryOptions helper to create type-safe, reusable query configurations. This allows for sharing query options between injectQuery and other functions while preserving type information.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/typescript.md#2025-04-19_snippet_8

LANGUAGE: ts
CODE:
```
@Injectable({
  providedIn: 'root',
})
export class QueriesService {
  private http = inject(HttpClient)

  post(postId: number) {
    return queryOptions({
      queryKey: ['post', postId],
      queryFn: () => {
        return lastValueFrom(
          this.http.get<Post>(
            `https://jsonplaceholder.typicode.com/posts/${postId}`,
          ),
        )
      },
    })
  }
}

@Component({
  // ...
})
export class Component {
  queryClient = inject(QueryClient)

  postId = signal(1)

  queries = inject(QueriesService)
  optionsSignal = computed(() => this.queries.post(this.postId()))

  postQuery = injectQuery(() => this.queries.post(1))
  postQuery = injectQuery(() => this.queries.post(this.postId()))

  // You can also pass a signal which returns query options
  postQuery = injectQuery(this.optionsSignal)

  someMethod() {
    this.queryClient.prefetchQuery(this.queries.post(23))
  }
}
```

----------------------------------------

TITLE: Implementing TanStack Query in Angular Component
DESCRIPTION: A complete example of using TanStack Query in an Angular component to fetch GitHub repository data. The component uses injectQuery to manage the API request state and renders different UI based on loading, error, or successful data states.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/overview.md#2025-04-19_snippet_0

LANGUAGE: typescript
CODE:
```
import { ChangeDetectionStrategy, Component, inject } from '@angular/core'
import { HttpClient } from '@angular/common/http'
import { CommonModule } from '@angular/common'
import { injectQuery } from '@tanstack/angular-query-experimental'
import { lastValueFrom } from 'rxjs'

@Component({
  changeDetection: ChangeDetectionStrategy.OnPush,
  selector: 'simple-example',
  standalone: true,
  template: `
    @if (query.isPending()) {
      Loading...
    }
    @if (query.error()) {
      An error has occurred: {{ query.error().message }}
    }
    @if (query.data(); as data) {
      <h1>{{ data.name }}</h1>
      <p>{{ data.description }}</p>
      <strong>üëÄ {{ data.subscribers_count }}</strong>
      <strong>‚ú® {{ data.stargazers_count }}</strong>
      <strong>üç¥ {{ data.forks_count }}</strong>
    }
  `
})
export class SimpleExampleComponent {
  http = inject(HttpClient)

  query = injectQuery(() => ({
    queryKey: ['repoData'],
    queryFn: () =>
      lastValueFrom(
        this.http.get<Response>('https://api.github.com/repos/tanstack/query'),
      ),
  }))
}

interface Response {
  name: string
  description: string
  subscribers_count: number
  stargazers_count: number
  forks_count: number
}
```

----------------------------------------

TITLE: Handling Query States in React Component
DESCRIPTION: This example demonstrates how to handle different query states (pending, error, success) in a React component. It shows how to conditionally render based on the query's state and display data or error messages accordingly.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/queries.md#2025-04-19_snippet_2

LANGUAGE: tsx
CODE:
```
function Todos() {
  const { isPending, isError, data, error } = useQuery({
    queryKey: ['todos'],
    queryFn: fetchTodoList,
  })

  if (isPending) {
    return <span>Loading...</span>
  }

  if (isError) {
    return <span>Error: {error.message}</span>
  }

  // We can assume by this point that `isSuccess === true`
  return (
    <ul>
      {data.map((todo) => (
        <li key={todo.id}>{todo.title}</li>
      ))}
    </ul>
  )
}
```

----------------------------------------

TITLE: Prefetching Infinite Query Data in TanStack Query
DESCRIPTION: Shows how to prefetch infinite query data using queryClient.prefetchInfiniteQuery. This example prefetches the first 3 pages of projects data.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/prefetching.md#2025-04-19_snippet_1

LANGUAGE: tsx
CODE:
```
const prefetchProjects = async () => {
  // The results of this query will be cached like a normal query
  await queryClient.prefetchInfiniteQuery({
    queryKey: ['projects'],
    queryFn: fetchProjects,
    initialPageParam: 0,
    getNextPageParam: (lastPage, pages) => lastPage.nextCursor,
    pages: 3, // prefetch the first 3 pages
  })
}
```

----------------------------------------

TITLE: Using mutationOptions for Type-Safe Mutations
DESCRIPTION: Shows how to use the mutationOptions helper to create type-safe, reusable mutation configurations with properly typed mutation function parameters and callbacks.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/typescript.md#2025-04-19_snippet_11

LANGUAGE: ts
CODE:
```
export class QueriesService {
  private http = inject(HttpClient)

  updatePost(id: number) {
    return mutationOptions({
      mutationFn: (post: Post) => Promise.resolve(post),
      mutationKey: ['updatePost', id],
      onSuccess: (newPost) => {
        //           ^? newPost: Post
        this.queryClient.setQueryData(['posts', id], newPost)
      },
    })
  }
}
```

----------------------------------------

TITLE: Rendering Optimistic UI Updates in React Query
DESCRIPTION: Demonstrates how to render a list of todos with an optimistic update while the mutation is pending.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/optimistic-updates.md#2025-04-19_snippet_1

LANGUAGE: tsx
CODE:
```
<ul>
  {todoQuery.items.map((todo) => (
    <li key={todo.id}>{todo.text}</li>
  ))}
  {isPending && <li style={{ opacity: 0.5 }}>{variables}</li>}
</ul>
```

----------------------------------------

TITLE: Basic Query Usage in Solid with TanStack Query
DESCRIPTION: Demonstrates how to use the useQuery hook in a Solid component to fetch and display data. The query key is 'todos' and the query function fetches todos from an API.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/solid/guides/queries.md#2025-04-19_snippet_0

LANGUAGE: javascript
CODE:
```
import { useQuery(() =>  } from '@tanstack/solid-query'

function Todos() {
  const { isPending, isError, data, error } = useQuery(() => {
    queryKey: ['todos'],
    queryFn: async () => {
      const response = await fetch('/api/todos')
      return response.json()
    },
  })

  if (isPending) {
    return <span>Loading...</span>
  }

  if (isError) {
    return <span>Error: {error.message}</span>
  }

  // We can assume by this point that `isSuccess === true`
  return (
    <ul>
      {data.map((todo) => (
        <li key={todo.id}>{todo.title}</li>
      ))}
    </ul>
  )
}
```

----------------------------------------

TITLE: Implementing Type-Safe GraphQL Queries with React Query in TypeScript
DESCRIPTION: This snippet demonstrates how to use React Query with graphql-request and GraphQL Code Generator to create fully-typed GraphQL operations. It includes a sample query for fetching film data with type-checked variables.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/graphql.md#2025-04-19_snippet_0

LANGUAGE: tsx
CODE:
```
import request from 'graphql-request'
import { useQuery } from '@tanstack/react-query'

import { graphql } from './gql/gql'

const allFilmsWithVariablesQueryDocument = graphql(/* GraphQL */ `
  query allFilmsWithVariablesQuery($first: Int!) {
    allFilms(first: $first) {
      edges {
        node {
          id
          title
        }
      }
    }
  }
`)

function App() {
  // `data` is fully typed!
  const { data } = useQuery({
    queryKey: ['films'],
    queryFn: async () =>
      request(
        'https://swapi-graphql.netlify.app/.netlify/functions/index',
        allFilmsWithVariablesQueryDocument,
        // variables are type-checked too!
        { first: 10 },
      ),
  })
  // ...
}
```

----------------------------------------

TITLE: Implementing Queries and Mutations with Vue Query in Vue.js
DESCRIPTION: This snippet showcases how to use Vue Query to fetch data (todos) and add new items. It demonstrates the usage of useQuery for data fetching, useMutation for data updates, and how to handle loading and error states in the template.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/quick-start.md#2025-04-19_snippet_0

LANGUAGE: vue
CODE:
```
<script setup>
import { useQueryClient, useQuery, useMutation } from '@tanstack/vue-query'

// Access QueryClient instance
const queryClient = useQueryClient()

// Query
const { isPending, isError, data, error } = useQuery({
  queryKey: ['todos'],
  queryFn: getTodos,
})

// Mutation
const mutation = useMutation({
  mutationFn: postTodo,
  onSuccess: () => {
    // Invalidate and refetch
    queryClient.invalidateQueries({ queryKey: ['todos'] })
  },
})

function onButtonClick() {
  mutation.mutate({
    id: Date.now(),
    title: 'Do Laundry',
  })
}
</script>

<template>
  <span v-if="isPending">Loading...</span>
  <span v-else-if="isError">Error: {{ error.message }}</span>
  <!-- We can assume by this point that `isSuccess === true` -->
  <ul v-else>
    <li v-for="todo in data" :key="todo.id">{{ todo.title }}</li>
  </ul>
  <button @click="onButtonClick">Add Todo</button>
</template>
```

----------------------------------------

TITLE: Updating Query Data with Mutation Response in TanStack Query
DESCRIPTION: This snippet shows how to use the useMutation hook and the QueryClient's setQueryData method to update an existing query with data returned from a mutation response. It demonstrates updating a todo item and then using the updated data in a subsequent query.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/updates-from-mutation-responses.md#2025-04-19_snippet_0

LANGUAGE: tsx
CODE:
```
const queryClient = useQueryClient()

const mutation = useMutation({
  mutationFn: editTodo,
  onSuccess: (data) => {
    queryClient.setQueryData(['todo', { id: 5 }], data)
  },
})

mutation.mutate({
  id: 5,
  name: 'Do the laundry',
})

// The query below will be updated with the response from the
// successful mutation
const { status, data, error } = useQuery({
  queryKey: ['todo', { id: 5 }],
  queryFn: fetchTodoById,
})
```

----------------------------------------

TITLE: Implementing ReactQueryStreamedHydration Provider in Next.js
DESCRIPTION: Sets up the React Query provider with streamed hydration support for Next.js applications. Includes configuration for QueryClient with server-side rendering considerations and proper client-side caching. Implements a provider component that handles both server and client environments.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/advanced-ssr.md#2025-04-19_snippet_12

LANGUAGE: tsx
CODE:
```
// app/providers.tsx
'use client'

import {
  isServer,
  QueryClient,
  QueryClientProvider,
} from '@tanstack/react-query'
import * as React from 'react'
import { ReactQueryStreamedHydration } from '@tanstack/react-query-next-experimental'

function makeQueryClient() {
  return new QueryClient({
    defaultOptions: {
      queries: {
        // With SSR, we usually want to set some default staleTime
        // above 0 to avoid refetching immediately on the client
        staleTime: 60 * 1000,
      },
    },
  })
}

let browserQueryClient: QueryClient | undefined = undefined

function getQueryClient() {
  if (isServer) {
    // Server: always make a new query client
    return makeQueryClient()
  } else {
    // Browser: make a new query client if we don't already have one
    // This is very important, so we don't re-make a new client if React
    // suspends during the initial render. This may not be needed if we
    // have a suspense boundary BELOW the creation of the query client
    if (!browserQueryClient) browserQueryClient = makeQueryClient()
    return browserQueryClient
  }
}

export function Providers(props: { children: React.ReactNode }) {
  // NOTE: Avoid useState when initializing the query client if you don't
  //       have a suspense boundary between this and the code that may
  //       suspend because React will throw away the client on the initial
  //       render if it suspends and there is no boundary
  const queryClient = getQueryClient()

  return (
    <QueryClientProvider client={queryClient}>
      <ReactQueryStreamedHydration>
        {props.children}
      </ReactQueryStreamedHydration>
    </QueryClientProvider>
  )
}
```

----------------------------------------

TITLE: Implementing Individual Query Loading States in React with TanStack Query
DESCRIPTION: Demonstrates how to use status and isFetching flags to show different loading states for individual queries. The component displays loading, error, or data states along with a background refresh indicator when the query is fetching new data.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/background-fetching-indicators.md#2025-04-19_snippet_0

LANGUAGE: tsx
CODE:
```
function Todos() {
  const {
    status,
    data: todos,
    error,
    isFetching,
  } = useQuery({
    queryKey: ['todos'],
    queryFn: fetchTodos,
  })

  return status === 'pending' ? (
    <span>Loading...</span>
  ) : status === 'error' ? (
    <span>Error: {error.message}</span>
  ) : (
    <>
      {isFetching ? <div>Refreshing...</div> : null}

      <div>
        {todos.map((todo) => (
          <Todo todo={todo} />
        ))}
      </div>
    </>
  )
}
```

----------------------------------------

TITLE: Updating QueryClient Methods in TanStack Query v5
DESCRIPTION: This snippet shows the changes in QueryClient method signatures, moving from multiple parameters to a single object parameter for various query operations.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-v5.md#2025-04-19_snippet_1

LANGUAGE: tsx
CODE:
```
queryClient.isFetching(key, filters) // [!code --]
queryClient.isFetching({ queryKey, ...filters }) // [!code ++]
queryClient.ensureQueryData(key, filters) // [!code --]
queryClient.ensureQueryData({ queryKey, ...filters }) // [!code ++]
queryClient.getQueriesData(key, filters) // [!code --]
queryClient.getQueriesData({ queryKey, ...filters }) // [!code ++]
queryClient.setQueriesData(key, updater, filters, options) // [!code --]
queryClient.setQueriesData({ queryKey, ...filters }, updater, options) // [!code ++]
queryClient.removeQueries(key, filters) // [!code --]
queryClient.removeQueries({ queryKey, ...filters }) // [!code ++]
queryClient.resetQueries(key, filters, options) // [!code --]
queryClient.resetQueries({ queryKey, ...filters }, options) // [!code ++]
queryClient.cancelQueries(key, filters, options) // [!code --]
queryClient.cancelQueries({ queryKey, ...filters }, options) // [!code ++]
queryClient.invalidateQueries(key, filters, options) // [!code --]
queryClient.invalidateQueries({ queryKey, ...filters }, options) // [!code ++]
queryClient.refetchQueries(key, filters, options) // [!code --]
queryClient.refetchQueries({ queryKey, ...filters }, options) // [!code ++]
queryClient.fetchQuery(key, fn, options) // [!code --]
queryClient.fetchQuery({ queryKey, queryFn, ...options }) // [!code ++]
queryClient.prefetchQuery(key, fn, options) // [!code --]
queryClient.prefetchQuery({ queryKey, queryFn, ...options }) // [!code ++]
queryClient.fetchInfiniteQuery(key, fn, options) // [!code --]
queryClient.fetchInfiniteQuery({ queryKey, queryFn, ...options }) // [!code ++]
queryClient.prefetchInfiniteQuery(key, fn, options) // [!code --]
queryClient.prefetchInfiniteQuery({ queryKey, queryFn, ...options }) // [!code ++]
```

----------------------------------------

TITLE: Fetch API Integration with Query Functions
DESCRIPTION: Demonstrates how to integrate the Fetch API with query functions, including proper error handling for network responses and JSON parsing.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/query-functions.md#2025-04-19_snippet_2

LANGUAGE: typescript
CODE:
```
todos = injectQuery(() => ({
  queryKey: ['todos', todoId()],
  queryFn: async () => {
    const response = await fetch('/todos/' + todoId)
    if (!response.ok) {
      throw new Error('Network response was not ok')
    }
    return response.json()
  },
}))
```

----------------------------------------

TITLE: Initializing QueryObserver in TanStack Query
DESCRIPTION: Demonstrates how to create a new QueryObserver instance and subscribe to query results. The observer can be used to watch queries and handle their state changes. The subscription can be cleaned up using the returned unsubscribe function.
SOURCE: https://github.com/tanstack/query/blob/main/docs/reference/QueryObserver.md#2025-04-19_snippet_0

LANGUAGE: tsx
CODE:
```
const observer = new QueryObserver(queryClient, { queryKey: ['posts'] })

const unsubscribe = observer.subscribe((result) => {
  console.log(result)
  unsubscribe()
})
```

----------------------------------------

TITLE: Implementing Error Boundary with useQueryErrorResetBoundary in React Query
DESCRIPTION: This snippet demonstrates how to use the useQueryErrorResetBoundary hook from @tanstack/react-query in combination with an ErrorBoundary component. It allows resetting query errors and provides a fallback UI for error states.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/reference/useQueryErrorResetBoundary.md#2025-04-19_snippet_0

LANGUAGE: tsx
CODE:
```
import { useQueryErrorResetBoundary } from '@tanstack/react-query'
import { ErrorBoundary } from 'react-error-boundary'

const App = () => {
  const { reset } = useQueryErrorResetBoundary()
  return (
    <ErrorBoundary
      onReset={reset}
      fallbackRender={({ resetErrorBoundary }) => (
        <div>
          There was an error!
          <Button onClick={() => resetErrorBoundary()}>Try again</Button>
        </div>
      )}
    >
      <Page />
    </ErrorBoundary>
  )
}
```

----------------------------------------

TITLE: Handling Form Submissions with Mutations in Angular
DESCRIPTION: Shows how to use injectMutation with Angular's Reactive Forms to create a todo item. The component includes form validation, error handling, and demonstrates how to reset a mutation after an error occurs.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/mutations.md#2025-04-19_snippet_1

LANGUAGE: angular-ts
CODE:
```
@Component({
  standalone: true,
  selector: 'todo-item',
  imports: [ReactiveFormsModule],
  template: `
    <form [formGroup]="todoForm" (ngSubmit)="onCreateTodo()">
      @if (mutation.error()) {
        <h5 (click)="mutation.reset()">{{ mutation.error() }}</h5>
      }
      <input type="text" formControlName="title" />
      <br />
      <button type="submit">Create Todo</button>
    </form>
  `,
})
export class TodosComponent {
  mutation = injectMutation(() => ({
    mutationFn: createTodo,
  }))

  fb = inject(NonNullableFormBuilder)

  todoForm = this.fb.group({
    title: this.fb.control('', {
      validators: [Validators.required],
    }),
  })

  title = toSignal(this.todoForm.controls.title.valueChanges, {
    initialValue: '',
  })

  onCreateTodo = () => {
    this.mutation.mutate(this.title())
  }
}
```

----------------------------------------

TITLE: Implementing Query Functions in TanStack Query (TSX)
DESCRIPTION: Examples of valid query function configurations in TanStack Query. These functions return promises that resolve data or throw errors.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/query-functions.md#2025-04-19_snippet_0

LANGUAGE: tsx
CODE:
```
useQuery({ queryKey: ['todos'], queryFn: fetchAllTodos })
useQuery({ queryKey: ['todos', todoId], queryFn: () => fetchTodoById(todoId) })
useQuery({
  queryKey: ['todos', todoId],
  queryFn: async () => {
    const data = await fetchTodoById(todoId)
    return data
  },
})
useQuery({
  queryKey: ['todos', todoId],
  queryFn: ({ queryKey }) => fetchTodoById(queryKey[1]),
})
```

----------------------------------------

TITLE: Implementing Dependent Query Prefetching
DESCRIPTION: Example of prefetching dependent queries in server-side props, showing how to handle sequential data fetching scenarios.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/ssr.md#2025-04-19_snippet_8

LANGUAGE: tsx
CODE:
```
export async function getServerSideProps() {
  const queryClient = new QueryClient()

  const user = await queryClient.fetchQuery({
    queryKey: ['user', email],
    queryFn: getUserByEmail,
  })

  if (user?.userId) {
    await queryClient.prefetchQuery({
      queryKey: ['projects', userId],
      queryFn: getProjectsByUser,
    })
  }

  return { props: { dehydratedState: dehydrate(queryClient) } }
}
```

----------------------------------------

TITLE: Basic Query Function Implementation in TanStack
DESCRIPTION: Demonstrates different ways to implement basic query functions using injectQuery. Shows various patterns for defining queryKey and queryFn with both direct and async implementations.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/query-functions.md#2025-04-19_snippet_0

LANGUAGE: typescript
CODE:
```
injectQuery(() => ({ queryKey: ['todos'], queryFn: fetchAllTodos }))
injectQuery(() => ({ queryKey: ['todos', todoId], queryFn: () => fetchTodoById(todoId) })
injectQuery(() => ({
  queryKey: ['todos', todoId],
  queryFn: async () => {
    const data = await fetchTodoById(todoId)
    return data
  },
}))
injectQuery(() => ({
  queryKey: ['todos', todoId],
  queryFn: ({ queryKey }) => fetchTodoById(queryKey[1]),
}))
```

----------------------------------------

TITLE: Advanced Mutation Configuration with Optimistic Updates
DESCRIPTION: Comprehensive example showing how to configure mutations with default settings, implement optimistic updates, handle offline scenarios, and persist mutation state with hydration/dehydration. Includes error handling and retry logic.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/mutations.md#2025-04-19_snippet_8

LANGUAGE: typescript
CODE:
```
const queryClient = new QueryClient()

// Define the "addTodo" mutation
queryClient.setMutationDefaults(['addTodo'], {
  mutationFn: addTodo,
  onMutate: async (variables) => {
    // Cancel current queries for the todos list
    await queryClient.cancelQueries({ queryKey: ['todos'] })

    // Create optimistic todo
    const optimisticTodo = { id: uuid(), title: variables.title }

    // Add optimistic todo to todos list
    queryClient.setQueryData(['todos'], (old) => [...old, optimisticTodo])

    // Return context with the optimistic todo
    return { optimisticTodo }
  },
  onSuccess: (result, variables, context) => {
    // Replace optimistic todo in the todos list with the result
    queryClient.setQueryData(['todos'], (old) =>
      old.map((todo) =>
        todo.id === context.optimisticTodo.id ? result : todo,
      ),
    )
  },
  onError: (error, variables, context) => {
    // Remove optimistic todo from the todos list
    queryClient.setQueryData(['todos'], (old) =>
      old.filter((todo) => todo.id !== context.optimisticTodo.id),
    )
  },
  retry: 3,
})

class someComponent {
  // Start mutation in some component:
  mutation = injectMutation(() => ({ mutationKey: ['addTodo'] }))

  someMethod() {
    mutation.mutate({ title: 'title' })
  }
}

// If the mutation has been paused because the device is for example offline,
// Then the paused mutation can be dehydrated when the application quits:
const state = dehydrate(queryClient)

// The mutation can then be hydrated again when the application is started:
hydrate(queryClient, state)

// Resume the paused mutations:
queryClient.resumePausedMutations()
```

----------------------------------------

TITLE: Implementing Default Query Function in TanStack Query with TypeScript
DESCRIPTION: This example demonstrates how to set up a default query function in TanStack Query that will be used for all queries across the application. The default function makes HTTP GET requests to JSONPlaceholder API using axios, extracting the endpoint from the query key. This approach simplifies component queries by requiring only the query key parameter.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/default-query-function.md#2025-04-19_snippet_0

LANGUAGE: typescript
CODE:
```
// Define a default query function that will receive the query key
const defaultQueryFn: QueryFunction = async ({ queryKey }) => {
  const { data } = await axios.get(
    `https://jsonplaceholder.typicode.com${queryKey[0]}`,
  )
  return data
}

// provide the default query function to your app with defaultOptions
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      queryFn: defaultQueryFn,
    },
  },
})

bootstrapApplication(MyAppComponent, {
  providers: [provideTanStackQuery(queryClient)],
})

export class PostsComponent {
  // All you have to do now is pass a key!
  postsQuery = injectQuery<Array<Post>>(() => ({
    queryKey: ['/posts'],
  }))
  // ...
}

export class PostComponent {
  // You can even leave out the queryFn and just go straight into options
  postQuery = injectQuery<Post>(() => ({
    enabled: this.postIdSignal() > 0,
    queryKey: [`/posts/${this.postIdSignal()}`],
  }))
  // ...
}
```

----------------------------------------

TITLE: Using Query Filters in TanStack Query
DESCRIPTION: Examples of using QueryFilters to cancel, remove, and refetch queries based on different conditions. Shows how to filter queries by key, type, and other properties.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/filters.md#2025-04-19_snippet_0

LANGUAGE: tsx
CODE:
```
// Cancel all queries
await queryClient.cancelQueries()

// Remove all inactive queries that begin with `posts` in the key
queryClient.removeQueries({ queryKey: ['posts'], type: 'inactive' })

// Refetch all active queries
await queryClient.refetchQueries({ type: 'active' })

// Refetch all active queries that begin with `posts` in the key
await queryClient.refetchQueries({ queryKey: ['posts'], type: 'active' })
```

----------------------------------------

TITLE: Initializing useQuery Hook with TypeScript
DESCRIPTION: Comprehensive example showing all available options and return values from the useQuery hook. Demonstrates the complete API surface including status flags, data handling, and configuration options.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/solid/reference/useQuery.md#2025-04-19_snippet_0

LANGUAGE: tsx
CODE:
```
const {
  data,
  dataUpdatedAt,
  error,
  errorUpdatedAt,
  failureCount,
  failureReason,
  fetchStatus,
  isError,
  isFetched,
  isFetchedAfterMount,
  isFetching,
  isInitialLoading,
  isLoading,
  isLoadingError,
  isPaused,
  isPending,
  isPlaceholderData,
  isRefetchError,
  isRefetching,
  isStale,
  isSuccess,
  refetch,
  status,
} = useQuery(
  () => ({
    queryKey,
    queryFn,
    enabled,
    select,
    placeholderData,
    deferStream,
    reconcile,
    gcTime,
    networkMode,
    initialData,
    initialDataUpdatedAt,
    meta,
    queryKeyHashFn,
    refetchInterval,
    refetchIntervalInBackground,
    refetchOnMount,
    refetchOnReconnect,
    refetchOnWindowFocus,
    retry,
    retryOnMount,
    retryDelay,
    staleTime,
    throwOnError,
  }),
  () => queryClient,
)
```

----------------------------------------

TITLE: Using Mutation State Globally in Angular
DESCRIPTION: Shows how to set up a mutation with a mutation key and access its state from elsewhere in the application using injectMutationState. This enables sharing mutation variables across components.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/optimistic-updates.md#2025-04-19_snippet_3

LANGUAGE: typescript
CODE:
```
// somewhere in your app
addTodo = injectMutation(() => ({
  mutationFn: (newTodo: string) => axios.post('/api/data', { text: newTodo }),
  onSettled: () => queryClient.invalidateQueries({ queryKey: ['todos'] }),
  mutationKey: ['addTodo'],
}))

// access variables somewhere else

mutationState = injectMutationState<string>(() => ({
  filters: { mutationKey: ['addTodo'], status: 'pending' },
  select: (mutation) => mutation.state.variables,
}))
```

----------------------------------------

TITLE: Providing initialData from Cache in TanStack Query (TypeScript/React)
DESCRIPTION: This example demonstrates how to provide initial data for a query from the cached result of another query. It searches the cached data from a todos list query for an individual todo item.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/initial-query-data.md#2025-04-19_snippet_5

LANGUAGE: tsx
CODE:
```
const result = useQuery({
  queryKey: ['todo', todoId],
  queryFn: () => fetch('/todos'),
  initialData: () => {
    // Use a todo from the 'todos' query as the initial data for this todo query
    return queryClient.getQueryData(['todos'])?.find((d) => d.id === todoId)
  },
})
```

----------------------------------------

TITLE: Implementing TanStack Query useQuery Hook
DESCRIPTION: Demonstrates the complete signature and return values of the useQuery hook. The hook accepts configuration options for query behavior and cache management, along with an optional QueryClient instance. Returns an object containing query state and control methods.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/reference/useQuery.md#2025-04-19_snippet_0

LANGUAGE: tsx
CODE:
```
const {
  data,
  dataUpdatedAt,
  error,
  errorUpdatedAt,
  failureCount,
  failureReason,
  fetchStatus,
  isError,
  isFetched,
  isFetchedAfterMount,
  isFetching,
  isInitialLoading,
  isLoading,
  isLoadingError,
  isPaused,
  isPending,
  isPlaceholderData,
  isRefetchError,
  isRefetching,
  isStale,
  isSuccess,
  promise,
  refetch,
  status,
} = useQuery(
  {
    queryKey,
    queryFn,
    gcTime,
    enabled,
    networkMode,
    initialData,
    initialDataUpdatedAt,
    meta,
    notifyOnChangeProps,
    placeholderData,
    queryKeyHashFn,
    refetchInterval,
    refetchIntervalInBackground,
    refetchOnMount,
    refetchOnReconnect,
    refetchOnWindowFocus,
    retry,
    retryOnMount,
    retryDelay,
    select,
    staleTime,
    structuralSharing,
    subscribed,
    throwOnError,
  },
  queryClient,
)
```

----------------------------------------

TITLE: Fetching Multiple Queries with useQueries in TanStack Query (TSX)
DESCRIPTION: Demonstrates how to use the useQueries hook to fetch multiple queries based on an array of IDs. Each query is configured with a unique key and custom options.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/reference/useQueries.md#2025-04-19_snippet_0

LANGUAGE: tsx
CODE:
```
const ids = [1, 2, 3]
const results = useQueries({
  queries: ids.map((id) => ({
    queryKey: ['post', id],
    queryFn: () => fetchPost(id),
    staleTime: Infinity,
  })),
})
```

----------------------------------------

TITLE: Implementing Infinite Queries with Vue Query and Vue 3 Composition API
DESCRIPTION: This snippet demonstrates how to use the useInfiniteQuery hook from @tanstack/vue-query to implement infinite scrolling in a Vue 3 component. It fetches project data in pages, handles loading states, and provides a button to load more data.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/infinite-queries.md#2025-04-19_snippet_0

LANGUAGE: vue
CODE:
```
<script setup>
import { useInfiniteQuery } from '@tanstack/vue-query'

const fetchProjects = async ({ pageParam = 0 }) => {
  const res = await fetch('/api/projects?cursor=' + pageParam)
  return res.json()
}

const {
  data,
  error,
  fetchNextPage,
  hasNextPage,
  isFetching,
  isFetchingNextPage,
  isPending,
  isError,
} = useInfiniteQuery({
  queryKey: ['projects'],
  queryFn: fetchProjects,
  getNextPageParam: (lastPage, pages) => lastPage.nextCursor,
})
</script>

<template>
  <span v-if="isPending">Loading...</span>
  <span v-else-if="isError">Error: {{ error.message }}</span>
  <div v-else-if="data">
    <span v-if="isFetching && !isFetchingNextPage">Fetching...</span>
    <ul v-for="(group, index) in data.pages" :key="index">
      <li v-for="project in group.projects" :key="project.id">
        {{ project.name }}
      </li>
    </ul>
    <button
      @click="() => fetchNextPage()"
      :disabled="!hasNextPage || isFetchingNextPage"
    >
      <span v-if="isFetchingNextPage">Loading more...</span>
      <span v-else-if="hasNextPage">Load More</span>
      <span v-else>Nothing more to load</span>
    </button>
  </div>
</template>
```

----------------------------------------

TITLE: Implementing Query Cancellation with Axios in TanStack Query
DESCRIPTION: Shows how to integrate axios HTTP client with TanStack Query's cancellation mechanism. The AbortSignal is passed directly to axios's request configuration to enable automatic cancellation.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/query-cancellation.md#2025-04-19_snippet_2

LANGUAGE: tsx
CODE:
```
import axios from 'axios'

const query = injectQuery(() => ({
  queryKey: ['todos'],
  queryFn: ({ signal }) =>
    axios.get('/todos', {
      // Pass the signal to `axios`
      signal,
    }),
}))
```

----------------------------------------

TITLE: Persisting Offline Mutations with React Query
DESCRIPTION: This example shows how to persist offline mutations using the persistQueryClient plugin. It includes setting up a storage persister, configuring the QueryClient, and providing default mutation functions for resuming after page reload.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/mutations.md#2025-04-19_snippet_10

LANGUAGE: tsx
CODE:
```
const persister = createSyncStoragePersister({
  storage: window.localStorage,
})
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      gcTime: 1000 * 60 * 60 * 24, // 24 hours
    },
  },
})

// we need a default mutation function so that paused mutations can resume after a page reload
queryClient.setMutationDefaults(['todos'], {
  mutationFn: ({ id, data }) => {
    return api.updateTodo(id, data)
  },
})

export default function App() {
  return (
    <PersistQueryClientProvider
      client={queryClient}
      persistOptions={{ persister }}
      onSuccess={() => {
        // resume mutations after initial restore from localStorage was successful
        queryClient.resumePausedMutations()
      }}
    >
      <RestOfTheApp />
    </PersistQueryClientProvider>
  )
}
```

----------------------------------------

TITLE: Optimistic Updates for Single Todo Item in Angular
DESCRIPTION: Shows optimistic updates for a single todo item using its ID in the query key. This example demonstrates more granular updates by targeting specific items in the cache rather than the whole list.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/optimistic-updates.md#2025-04-19_snippet_5

LANGUAGE: typescript
CODE:
```
queryClient = inject(QueryClient)

updateTodo = injectMutation(() => ({
  mutationFn: updateTodo,
  // When mutate is called:
  onMutate: async (newTodo) => {
    // Cancel any outgoing refetches
    // (so they don't overwrite our optimistic update)
    await this.queryClient.cancelQueries({ queryKey: ['todos', newTodo.id] })

    // Snapshot the previous value
    const previousTodo = this.queryClient.getQueryData(['todos', newTodo.id])

    // Optimistically update to the new value
    this.queryClient.setQueryData(['todos', newTodo.id], newTodo)

    // Return a context with the previous and new todo
    return { previousTodo, newTodo }
  },
  // If the mutation fails, use the context we returned above
  onError: (err, newTodo, context) => {
    this.queryClient.setQueryData(
      ['todos', context.newTodo.id],
      context.previousTodo,
    )
  },
  // Always refetch after error or success:
  onSettled: (newTodo) => {
    this.queryClient.invalidateQueries({ queryKey: ['todos', newTodo.id] })
  },
}))
```

----------------------------------------

TITLE: Exact Query Key Invalidation
DESCRIPTION: Shows how to use exact matching for query invalidation by setting exact: true option. This ensures only queries with exactly matching keys are invalidated.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/query-invalidation.md#2025-04-19_snippet_3

LANGUAGE: tsx
CODE:
```
queryClient.invalidateQueries({
  queryKey: ['todos'],
  exact: true,
})

// The query below will be invalidated
const todoListQuery = useQuery({
  queryKey: ['todos'],
  queryFn: fetchTodoList,
})

// However, the following query below will NOT be invalidated
const todoListQuery = useQuery({
  queryKey: ['todos', { type: 'done' }],
  queryFn: fetchTodoList,
})
```

----------------------------------------

TITLE: Implementing Default Query Function in TanStack Query with TypeScript/React
DESCRIPTION: This snippet demonstrates how to define a default query function, configure it with QueryClient, and use it in React components. It uses axios for HTTP requests and assumes a REST API structure.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/default-query-function.md#2025-04-19_snippet_0

LANGUAGE: tsx
CODE:
```
// Define a default query function that will receive the query key
const defaultQueryFn = async ({ queryKey }) => {
  const { data } = await axios.get(
    `https://jsonplaceholder.typicode.com${queryKey[0]}`,
  )
  return data
}

// provide the default query function to your app with defaultOptions
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      queryFn: defaultQueryFn,
    },
  },
})

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <YourApp />
    </QueryClientProvider>
  )
}

// All you have to do now is pass a key!
function Posts() {
  const { status, data, error, isFetching } = useQuery({ queryKey: ['/posts'] })

  // ...
}

// You can even leave out the queryFn and just go straight into options
function Post({ postId }) {
  const { status, data, error, isFetching } = useQuery({
    queryKey: [`/posts/${postId}`],
    enabled: !!postId,
  })

  // ...
}
```

----------------------------------------

TITLE: Multiple Parallel Dependent Queries using useQueries
DESCRIPTION: Implementation of multiple parallel dependent queries using useQueries hook. Fetches messages for multiple users after retrieving user IDs from an initial query.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/dependent-queries.md#2025-04-19_snippet_1

LANGUAGE: typescript
CODE:
```
// Get the users ids
const { data: userIds } = useQuery({
  queryKey: ['users'],
  queryFn: getUsersData,
  select: (users) => users.map((user) => user.id),
})

const queries = computed(() => {
  return userIds.value.length
    ? userIds.value.map((id) => {
        return {
          queryKey: ['messages', id],
          queryFn: () => getMessagesByUsers(id),
        }
      })
    : []
})

// Then get the users messages
const usersMessages = useQueries({
  queries, // if users is undefined, an empty array will be returned
})
```

----------------------------------------

TITLE: Using useSuspenseQuery Hook in TanStack Query - TSX
DESCRIPTION: Demonstrates the basic usage of useSuspenseQuery hook. This suspense-enabled version differs from useQuery by guaranteeing defined data and having a simplified status states. It does not support query cancellation and excludes throwOnError, enabled, and placeholderData options.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/reference/useSuspenseQuery.md#2025-04-19_snippet_0

LANGUAGE: tsx
CODE:
```
const result = useSuspenseQuery(options)
```

----------------------------------------

TITLE: Manual Query Priming in TanStack Query
DESCRIPTION: Shows how to manually prime a query cache using setQueryData when data is already available synchronously.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/prefetching.md#2025-04-19_snippet_8

LANGUAGE: tsx
CODE:
```
queryClient.setQueryData(['todos'], todos)
```

----------------------------------------

TITLE: Implementing Bi-directional Infinite List with TanStack Query
DESCRIPTION: This example demonstrates how to set up a bi-directional infinite list using useInfiniteQuery, enabling both forward and backward pagination.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/infinite-queries.md#2025-04-19_snippet_2

LANGUAGE: tsx
CODE:
```
useInfiniteQuery({
  queryKey: ['projects'],
  queryFn: fetchProjects,
  initialPageParam: 0,
  getNextPageParam: (lastPage, pages) => lastPage.nextCursor,
  getPreviousPageParam: (firstPage, pages) => firstPage.prevCursor,
})
```

----------------------------------------

TITLE: Prefetching in Event Handlers with TanStack Query
DESCRIPTION: Illustrates how to prefetch data on user interactions like mouse enter or focus events. This example uses queryClient.prefetchQuery to start prefetching details data.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/prefetching.md#2025-04-19_snippet_2

LANGUAGE: tsx
CODE:
```
function ShowDetailsButton() {
  const queryClient = useQueryClient()

  const prefetch = () => {
    queryClient.prefetchQuery({
      queryKey: ['details'],
      queryFn: getDetailsData,
      // Prefetch only fires when data is older than the staleTime,
      // so in a case like this you definitely want to set one
      staleTime: 60000,
    })
  }

  return (
    <button onMouseEnter={prefetch} onFocus={prefetch} onClick={...}>
      Show Details
    </button>
  )
}
```

----------------------------------------

TITLE: Implementing Infinite Query with TanStack Query in TypeScript
DESCRIPTION: Example showing the basic implementation of useInfiniteQuery hook with TypeScript, demonstrating pagination parameters and core functionality for handling infinite data loading.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/reference/useInfiniteQuery.md#2025-04-19_snippet_0

LANGUAGE: tsx
CODE:
```
const {
  fetchNextPage,
  fetchPreviousPage,
  hasNextPage,
  hasPreviousPage,
  isFetchingNextPage,
  isFetchingPreviousPage,
  promise,
  ...result
} = useInfiniteQuery({
  queryKey,
  queryFn: ({ pageParam }) => fetchPage(pageParam),
  initialPageParam: 1,
  ...options,
  getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) =>
    lastPage.nextCursor,
  getPreviousPageParam: (firstPage, allPages, firstPageParam, allPageParams) =>
    firstPage.prevCursor,
})
```

----------------------------------------

TITLE: Implementing Paginated Queries with Vue Query
DESCRIPTION: Demonstrates a complete implementation of paginated data fetching using TanStack Vue Query. Features include page navigation, loading states, error handling, and keeping previous data while fetching new pages using keepPreviousData option. The example fetches posts from JSONPlaceholder API with pagination support.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/paginated-queries.md#2025-04-19_snippet_0

LANGUAGE: vue
CODE:
```
<script setup lang="ts">
import { ref, Ref } from 'vue'
import { useQuery, keepPreviousData } from '@tanstack/vue-query'

const fetcher = (page: Ref<number>) =>
  fetch(
    `https://jsonplaceholder.typicode.com/posts?_page=${page.value}&_limit=10`,
  ).then((response) => response.json())

const page = ref(1)
const { isPending, isError, data, error, isFetching, isPlaceholderData } =
  useQuery({
    queryKey: ['projects', page],
    queryFn: () => fetcher(page),
    placeholderData: keepPreviousData,
  })
const prevPage = () => {
  page.value = Math.max(page.value - 1, 1)
}
const nextPage = () => {
  if (!isPlaceholderData.value) {
    page.value = page.value + 1
  }
}
</script>

<template>
  <h1>Posts</h1>
  <p>Current Page: {{ page }} | Previous data: {{ isPlaceholderData }}</p>
  <button @click="prevPage">Prev Page</button>
  <button @click="nextPage">Next Page</button>
  <div v-if="isPending">Loading...</div>
  <div v-else-if="isError">An error has occurred: {{ error }}</div>
  <div v-else-if="data">
    <ul>
      <li v-for="item in data" :key="item.id">
        {{ item.title }}
      </li>
    </ul>
  </div>
</template>
```

----------------------------------------

TITLE: Registering Global Error Type in React Query (TypeScript)
DESCRIPTION: Shows how to register a global error type for React Query to ensure consistent error typing across the application.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/typescript.md#2025-04-19_snippet_7

LANGUAGE: tsx
CODE:
```
import '@tanstack/react-query'

declare module '@tanstack/react-query' {
  interface Register {
    defaultError: AxiosError
  }
}

const { error } = useQuery({ queryKey: ['groups'], queryFn: fetchGroups })
//      ^? const error: AxiosError | null
```

----------------------------------------

TITLE: Implementing Optimistic Updates for Todo List in Angular
DESCRIPTION: Demonstrates a complete implementation of optimistic updates for a todo list. Includes canceling outgoing queries, capturing previous state, optimistically updating the UI, and rolling back on error.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/optimistic-updates.md#2025-04-19_snippet_4

LANGUAGE: typescript
CODE:
```
queryClient = inject(QueryClient)

updateTodo = injectMutation(() => ({
  mutationFn: updateTodo,
  // When mutate is called:
  onMutate: async (newTodo) => {
    // Cancel any outgoing refetches
    // (so they don't overwrite our optimistic update)
    await this.queryClient.cancelQueries({ queryKey: ['todos'] })

    // Snapshot the previous value
    const previousTodos = client.getQueryData(['todos'])

    // Optimistically update to the new value
    this.queryClient.setQueryData(['todos'], (old) => [...old, newTodo])

    // Return a context object with the snapshotted value
    return { previousTodos }
  },
  // If the mutation fails,
  // use the context returned from onMutate to roll back
  onError: (err, newTodo, context) => {
    client.setQueryData(['todos'], context.previousTodos)
  },
  // Always refetch after error or success:
  onSettled: () => {
    this.queryClient.invalidateQueries({ queryKey: ['todos'] })
  },
}))
```

----------------------------------------

TITLE: Conditional initialData from Cache in TanStack Query (TypeScript/React)
DESCRIPTION: This example demonstrates how to conditionally use cached data as initial data based on its freshness. It uses 'queryClient.getQueryState' to check if the cached data is recent enough before using it.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/initial-query-data.md#2025-04-19_snippet_7

LANGUAGE: tsx
CODE:
```
const result = useQuery({
  queryKey: ['todo', todoId],
  queryFn: () => fetch(`/todos/${todoId}`),
  initialData: () => {
    // Get the query state
    const state = queryClient.getQueryState(['todos'])

    // If the query exists and has data that is no older than 10 seconds...
    if (state && Date.now() - state.dataUpdatedAt <= 10 * 1000) {
      // return the individual todo
      return state.data.find((d) => d.id === todoId)
    }

    // Otherwise, return undefined and let it fetch from a hard loading state!
  },
})
```

----------------------------------------

TITLE: Basic TanStack Query Setup with SolidJS
DESCRIPTION: Shows basic setup of TanStack Query in a SolidJS application with query client initialization and basic query usage for fetching todos.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/solid/quick-start.md#2025-04-19_snippet_0

LANGUAGE: tsx
CODE:
```
import {
  QueryClient,
  QueryClientProvider,
  useQuery,
} from '@tanstack/solid-query'
import { Switch, Match, For } from 'solid-js'

const queryClient = new QueryClient()

function Example() {
  const query = useQuery(() => ({
    queryKey: ['todos'],
    queryFn: fetchTodos,
  }))

  return (
    <div>
      <Switch>
        <Match when={query.isPending}>
          <p>Loading...</p>
        </Match>
        <Match when={query.isError}>
          <p>Error: {query.error.message}</p>
        </Match>
        <Match when={query.isSuccess}>
          <For each={query.data}>{(todo) => <p>{todo.title}</p>}</For>
        </Match>
      </Switch>
    </div>
  )
}

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <Example />
    </QueryClientProvider>
  )
}
```

----------------------------------------

TITLE: Implementing Embedded Mode React Query Devtools
DESCRIPTION: Example of how to implement React Query Devtools in embedded mode, which shows the development tools as a fixed element in the application for use in custom development tools.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/devtools.md#2025-04-19_snippet_3

LANGUAGE: typescript
CODE:
```
import { ReactQueryDevtoolsPanel } from '@tanstack/react-query-devtools'

function App() {
  const [isOpen, setIsOpen] = React.useState(false)

  return (
    <QueryClientProvider client={queryClient}>
      {/* The rest of your application */}
      <button
        onClick={() => setIsOpen(!isOpen)}
      >{`${isOpen ? 'Close' : 'Open'} the devtools panel`}</button>
      {isOpen && <ReactQueryDevtoolsPanel onClose={() => setIsOpen(false)} />}
    </QueryClientProvider>
  )
}
```

----------------------------------------

TITLE: Using createQuery in a Svelte Component
DESCRIPTION: This example shows how to use the createQuery function within a Svelte component. It demonstrates querying for todos and handling different query states (loading, error, success) in the template.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/overview.md#2025-04-19_snippet_1

LANGUAGE: svelte
CODE:
```
<script lang="ts">
  import { createQuery } from '@tanstack/svelte-query'

  const query = createQuery({
    queryKey: ['todos'],
    queryFn: () => fetchTodos(),
  })
</script>

<div>
  {#if $query.isLoading}
    <p>Loading...</p>
  {:else if $query.isError}
    <p>Error: {$query.error.message}</p>
  {:else if $query.isSuccess}
    {#each $query.data as todo}
      <p>{todo.title}</p>
    {/each}
  {/if}
</div>
```

----------------------------------------

TITLE: Creating a Basic Mutation in TanStack Angular Query
DESCRIPTION: A simple example of using injectMutation to create a mutation function for posting a todo item.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/invalidations-from-mutations.md#2025-04-19_snippet_0

LANGUAGE: typescript
CODE:
```
mutation = injectMutation(() => ({
  mutationFn: postTodo,
}))
```

----------------------------------------

TITLE: Using Lifecycle Callbacks with Mutations
DESCRIPTION: Demonstrates how to use lifecycle callbacks (onMutate, onError, onSuccess, onSettled) with injectMutation to handle different stages of the mutation process. Includes context passing for rollback operations.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/mutations.md#2025-04-19_snippet_2

LANGUAGE: typescript
CODE:
```
mutation = injectMutation(() => ({
  mutationFn: addTodo,
  onMutate: (variables) => {
    // A mutation is about to happen!

    // Optionally return a context containing data to use when for example rolling back
    return { id: 1 }
  },
  onError: (error, variables, context) => {
    // An error happened!
    console.log(`rolling back optimistic update with id ${context.id}`)
  },
  onSuccess: (data, variables, context) => {
    // Boom baby!
  },
  onSettled: (data, error, variables, context) => {
    // Error or success... doesn't matter!
  },
}))
```

----------------------------------------

TITLE: Combining Query Results with useQueries in TanStack Query (TSX)
DESCRIPTION: Shows how to use the combine option in useQueries to aggregate results from multiple queries into a single value. The example combines data from posts and checks if any query is pending.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/reference/useQueries.md#2025-04-19_snippet_1

LANGUAGE: tsx
CODE:
```
const ids = [1, 2, 3]
const combinedQueries = useQueries({
  queries: ids.map((id) => ({
    queryKey: ['post', id],
    queryFn: () => fetchPost(id),
  })),
  combine: (results) => {
    return {
      data: results.map((result) => result.data),
      pending: results.some((result) => result.isPending),
    }
  },
})
```

----------------------------------------

TITLE: Configuring Query with initialData and Default staleTime (TypeScript/React)
DESCRIPTION: This example shows a query configuration using 'initialData' without specifying 'staleTime'. This setup will immediately show initial data but also refetch data after mounting.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/initial-query-data.md#2025-04-19_snippet_1

LANGUAGE: tsx
CODE:
```
const result = useQuery({
  queryKey: ['todos'],
  queryFn: () => fetch('/todos'),
  initialData: initialTodos,
})
```

----------------------------------------

TITLE: Configuring Query Options in TanStack Query for React
DESCRIPTION: This snippet demonstrates how to use the queryOptions function to configure a query in TanStack Query. It shows setting up a query key, query function, and various options like staleTime and refetchInterval.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/solid/reference/queryOptions.md#2025-04-19_snippet_0

LANGUAGE: javascript
CODE:
```
import { queryOptions } from '@tanstack/react-query'

const options = queryOptions({
  queryKey: ['posts'],
  queryFn: fetchPosts,
  staleTime: 5000,
  refetchInterval: 1000 * 60 * 5,
})
```

----------------------------------------

TITLE: Using initialData as a Function in TanStack Query (TypeScript/React)
DESCRIPTION: This snippet shows how to use a function for 'initialData' when the process of accessing initial data is intensive. The function is executed only once when the query is initialized.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/initial-query-data.md#2025-04-19_snippet_4

LANGUAGE: tsx
CODE:
```
const result = useQuery({
  queryKey: ['todos'],
  queryFn: () => fetch('/todos'),
  initialData: () => getExpensiveTodos(),
})
```

----------------------------------------

TITLE: Disabling Queries with Enabled Option in Vue Query
DESCRIPTION: This snippet demonstrates how to disable a query using the 'enabled' option set to false. It also shows how to manually trigger the query using the 'refetch' function and handle different query states.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/disabling-queries.md#2025-04-19_snippet_0

LANGUAGE: vue
CODE:
```
<script setup>
import { useQuery } from '@tanstack/vue-query'

const { isLoading, isError, data, error, refetch, isFetching } = useQuery({
  queryKey: ['todos'],
  queryFn: fetchTodoList,
  enabled: false,
})
</script>

<template>
  <button @click="refetch()">Fetch Todos</button>
  <span v-if="isLoading">Loading...</span>
  <span v-else-if="isError">Error: {{ error?.message }}</span>
  <div v-else-if="data">
    <span v-if="isFetching">Fetching...</span>
    <ul>
      <li v-for="todo in data" :key="todo.id">{{ todo.title }}</li>
    </ul>
  </div>
  <span v-else>Not ready...</span>
</template>
```

----------------------------------------

TITLE: Implementing Query Cancellation with XMLHttpRequest in TanStack Query
DESCRIPTION: Shows how to use the AbortSignal with XMLHttpRequest in a TanStack Query queryFn. It sets up event listeners for both successful load and abort scenarios.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/query-cancellation.md#2025-04-19_snippet_3

LANGUAGE: tsx
CODE:
```
const query = useQuery({
  queryKey: ['todos'],
  queryFn: ({ signal }) => {
    return new Promise((resolve, reject) => {
      var oReq = new XMLHttpRequest()
      oReq.addEventListener('load', () => {
        resolve(JSON.parse(oReq.responseText))
      })
      signal?.addEventListener('abort', () => {
        oReq.abort()
        reject()
      })
      oReq.open('GET', '/todos')
      oReq.send()
    })
  },
})
```

----------------------------------------

TITLE: Configuring Query Retries in TanStack Query for React
DESCRIPTION: This snippet demonstrates how to set up a specific query with a custom retry count. It uses the useQuery hook from @tanstack/react-query to fetch a todo list page and sets the retry attempts to 10.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/query-retries.md#2025-04-19_snippet_0

LANGUAGE: tsx
CODE:
```
import { useQuery } from '@tanstack/react-query'

// Make a specific query retry a certain number of times
const result = useQuery({
  queryKey: ['todos', 1],
  queryFn: fetchTodoListPage,
  retry: 10, // Will retry failed requests 10 times before displaying an error
})
```

----------------------------------------

TITLE: Implementing Advanced Paginated Query with TanStack Query in Angular
DESCRIPTION: This extensive example demonstrates a complete implementation of paginated queries in an Angular component. It includes handling of loading states, error handling, data display, pagination controls, and prefetching of the next page. The component uses injectQuery with placeholderData for smooth transitions between pages.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/paginated-queries.md#2025-04-19_snippet_1

LANGUAGE: angular-ts
CODE:
```
@Component({
  selector: 'pagination-example',
  template: `
    <div>
      <p>
        In this example, each page of data remains visible as the next page is
        fetched. The buttons and capability to proceed to the next page are also
        suppressed until the next page cursor is known. Each page is cached as a
        normal query too, so when going to previous pages, you'll see them
        instantaneously while they are also re-fetched invisibly in the
        background.
      </p>
      @if (query.status() === 'pending') {
        <div>Loading...</div>
      } @else if (query.status() === 'error') {
        <div>Error: {{ query.error().message }}</div>
      } @else {
        <!-- 'data' will either resolve to the latest page's data -->
        <!-- or if fetching a new page, the last successful page's data -->
        <div>
          @for (project of query.data().projects; track project.id) {
            <p>{{ project.name }}</p>
          }
        </div>
      }

      <div>Current Page: {{ page() + 1 }}</div>
      <button (click)="previousPage()" [disabled]="page() === 0">
        Previous Page
      </button>
      <button
        (click)="nextPage()"
        [disabled]="query.isPlaceholderData() || !query.data()?.hasMore"
      >
        Next Page
      </button>
      <!-- Since the last page's data potentially sticks around between page requests, -->
      <!-- we can use 'isFetching' to show a background loading -->
      <!-- indicator since our status === 'pending' state won't be triggered -->
      @if (query.isFetching()) {
        <span> Loading...</span>
      }
    </div>
  `,
})
export class PaginationExampleComponent {
  page = signal(0)
  queryClient = inject(QueryClient)

  query = injectQuery(() => ({
    queryKey: ['projects', this.page()],
    queryFn: () => lastValueFrom(fetchProjects(this.page())),
    placeholderData: keepPreviousData,
    staleTime: 5000,
  }))

  constructor() {
    effect(() => {
      // Prefetch the next page!
      if (!this.query.isPlaceholderData() && this.query.data()?.hasMore) {
        this.#queryClient.prefetchQuery({
          queryKey: ['projects', this.page() + 1],
          queryFn: () => lastValueFrom(fetchProjects(this.page() + 1)),
        })
      }
    })
  }

  previousPage() {
    this.page.update((old) => Math.max(old - 1, 0))
  }

  nextPage() {
    this.page.update((old) => (this.query.data()?.hasMore ? old + 1 : old))
  }
}
```

----------------------------------------

TITLE: Implementing Cancellable Query and Cancellation in TanStack Query with TypeScript
DESCRIPTION: This snippet shows how to create a cancellable query using useQuery hook and how to cancel it using queryClient. It demonstrates passing a signal to the fetch function for cancellation support and using queryClient's cancelQueries method to trigger cancellation.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/query-cancellation.md#2025-04-19_snippet_0

LANGUAGE: typescript
CODE:
```
const query = useQuery({
  queryKey: ['todos'],
  queryFn: async ({ signal }) => {
    const resp = await fetch('/todos', { signal })
    return resp.json()
  },
})

const queryClient = useQueryClient()

function onButtonClick() {
  queryClient.cancelQueries({ queryKey: ['todos'] })
}
```

----------------------------------------

TITLE: Array Keys with Variables in TanStack Query
DESCRIPTION: Shows how to use query keys with variables for hierarchical resources and queries with additional parameters.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/query-keys.md#2025-04-19_snippet_1

LANGUAGE: tsx
CODE:
```
// An individual todo
useQuery({ queryKey: ['todo', 5], ... })

// An individual todo in a "preview" format
useQuery({ queryKey: ['todo', 5, { preview: true }], ...})

// A list of todos that are "done"
useQuery({ queryKey: ['todos', { type: 'done' }], ... })
```

----------------------------------------

TITLE: Fetching Paginated Projects Data with TanStack Query in TypeScript
DESCRIPTION: This snippet demonstrates how to use useInfiniteQuery to fetch paginated project data from an API. It includes handling loading states, errors, and implementing a 'Load More' button.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/infinite-queries.md#2025-04-19_snippet_0

LANGUAGE: tsx
CODE:
```
import { useInfiniteQuery } from '@tanstack/react-query'

function Projects() {
  const fetchProjects = async ({ pageParam }) => {
    const res = await fetch('/api/projects?cursor=' + pageParam)
    return res.json()
  }

  const {
    data,
    error,
    fetchNextPage,
    hasNextPage,
    isFetching,
    isFetchingNextPage,
    status,
  } = useInfiniteQuery({
    queryKey: ['projects'],
    queryFn: fetchProjects,
    initialPageParam: 0,
    getNextPageParam: (lastPage, pages) => lastPage.nextCursor,
  })

  return status === 'pending' ? (
    <p>Loading...</p>
  ) : status === 'error' ? (
    <p>Error: {error.message}</p>
  ) : (
    <>
      {data.pages.map((group, i) => (
        <React.Fragment key={i}>
          {group.data.map((project) => (
            <p key={project.id}>{project.name}</p>
          ))}
        </React.Fragment>
      ))}
      <div>
        <button
          onClick={() => fetchNextPage()}
          disabled={!hasNextPage || isFetchingNextPage}
        >
          {isFetchingNextPage
            ? 'Loading more...'
            : hasNextPage
              ? 'Load More'
              : 'Nothing more to load'}
        </button>
      </div>
      <div>{isFetching && !isFetchingNextPage ? 'Fetching...' : null}</div>
    </>
  )
}
```

----------------------------------------

TITLE: Simple Query Keys Implementation in TanStack Query
DESCRIPTION: Demonstrates basic query key usage with constant values for generic list/index resources and non-hierarchical resources.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/query-keys.md#2025-04-19_snippet_0

LANGUAGE: tsx
CODE:
```
// A list of todos
useQuery({ queryKey: ['todos'], ... })

// Something else, whatever!
useQuery({ queryKey: ['something', 'special'], ... })
```

----------------------------------------

TITLE: Basic Usage of useQuery in Vue Query
DESCRIPTION: Demonstrates the basic usage of the useQuery hook in Vue Query. It shows how to fetch data from an API and handle the query state.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/reference/useQuery.md#2025-04-19_snippet_0

LANGUAGE: javascript
CODE:
```
import { useQuery } from '@tanstack/vue-query'

const result = useQuery({ queryKey: ['todos'], queryFn: fetchTodoList })
```

----------------------------------------

TITLE: Disabling Queries with enabled Option in TanStack Query (TSX)
DESCRIPTION: This snippet demonstrates how to disable a query using the 'enabled' option set to false. It shows how to manually trigger the query using the refetch function and handle different query states.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/disabling-queries.md#2025-04-19_snippet_0

LANGUAGE: tsx
CODE:
```
function Todos() {
  const { isLoading, isError, data, error, refetch, isFetching } = useQuery({
    queryKey: ['todos'],
    queryFn: fetchTodoList,
    enabled: false,
  })

  return (
    <div>
      <button onClick={() => refetch()}>Fetch Todos</button>

      {data ? (
        <>
          <ul>
            {data.map((todo) => (
              <li key={todo.id}>{todo.title}</li>
            ))}
          </ul>
        </>
      ) : isError ? (
        <span>Error: {error.message}</span>
      ) : isLoading ? (
        <span>Loading...</span>
      ) : (
        <span>Not ready ...</span>
      )}

      <div>{isFetching ? 'Fetching...' : null}</div>
    </div>
  )
}
```

----------------------------------------

TITLE: Creating an Indexed DB Persister for TanStack Query in TypeScript
DESCRIPTION: This code snippet demonstrates how to create an Indexed DB persister for TanStack Query. It uses the 'idb-keyval' library for Indexed DB operations and implements the Persister interface from '@tanstack/react-query-persist-client'. The persister provides methods for persisting, restoring, and removing client data.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/plugins/persistQueryClient.md#2025-04-19_snippet_3

LANGUAGE: typescript
CODE:
```
import { get, set, del } from 'idb-keyval'
import {
  PersistedClient,
  Persister,
} from '@tanstack/react-query-persist-client'

/**
 * Creates an Indexed DB persister
 * @see https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API
 */
export function createIDBPersister(idbValidKey: IDBValidKey = 'reactQuery') {
  return {
    persistClient: async (client: PersistedClient) => {
      await set(idbValidKey, client)
    },
    restoreClient: async () => {
      return await get<PersistedClient>(idbValidKey)
    },
    removeClient: async () => {
      await del(idbValidKey)
    },
  } satisfies Persister
}
```

----------------------------------------

TITLE: Executing Multiple Static Parallel Queries with injectQuery in Angular
DESCRIPTION: This example demonstrates how to execute multiple queries in parallel using the injectQuery function from TanStack Query in an Angular component. It shows three separate queries being executed simultaneously to fetch users, teams, and projects data.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/parallel-queries.md#2025-04-19_snippet_0

LANGUAGE: TypeScript
CODE:
```
export class AppComponent {
  // The following queries will execute in parallel
  usersQuery = injectQuery(() => ({ queryKey: ['users'], queryFn: fetchUsers }))
  teamsQuery = injectQuery(() => ({ queryKey: ['teams'], queryFn: fetchTeams }))
  projectsQuery = injectQuery(() => ({
    queryKey: ['projects'],
    queryFn: fetchProjects,
  }))
}
```

----------------------------------------

TITLE: Creating and Using Query Options in Angular with TanStack Query
DESCRIPTION: This snippet demonstrates how to create a service that provides reusable query options for fetching posts. It shows how to define queryOptions with queryKey and queryFn, and then how to use these options with injectQuery, prefetchQuery, and setQueryData.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/query-options.md#2025-04-19_snippet_0

LANGUAGE: typescript
CODE:
```
import { queryOptions } from '@tanstack/angular-query-experimental'

@Injectable({
  providedIn: 'root',
})
export class QueriesService {
  private http = inject(HttpClient)

  post(postId: number) {
    return queryOptions({
      queryKey: ['post', postId],
      queryFn: () => {
        return lastValueFrom(
          this.http.get<Post>(
            `https://jsonplaceholder.typicode.com/posts/${postId}`,
          ),
        )
      },
    })
  }
}

// usage:

postId = input.required({
  transform: numberAttribute,
})
queries = inject(QueriesService)

postQuery = injectQuery(() => this.queries.post(this.postId()))

queryClient.prefetchQuery(this.queries.post(23))
queryClient.setQueryData(this.queries.post(42).queryKey, newPost)
```

----------------------------------------

TITLE: Updated Infinite Query Configuration
DESCRIPTION: Shows the new required configuration for infinite queries, including the mandatory initialPageParam property and updated queryFn signature without default parameter values.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-v5.md#2025-04-19_snippet_11

LANGUAGE: tsx
CODE:
```
useInfiniteQuery({
   queryKey,
-  queryFn: ({ pageParam = 0 }) => fetchSomething(pageParam), // [!code --]
+  queryFn: ({ pageParam }) => fetchSomething(pageParam), // [!code ++]
+  initialPageParam: 0, // [!code ++]
   getNextPageParam: (lastPage) => lastPage.next,
})
```

----------------------------------------

TITLE: Basic Paginated Query in TanStack Query
DESCRIPTION: This snippet demonstrates a simple paginated query using TanStack Query. It includes the page information in the query key to fetch different pages of data.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/paginated-queries.md#2025-04-19_snippet_0

LANGUAGE: tsx
CODE:
```
const result = useQuery({
  queryKey: ['projects', page],
  queryFn: fetchProjects,
})
```

----------------------------------------

TITLE: Implementing Limited Infinite Query with maxPages Option
DESCRIPTION: This example shows how to limit the number of pages stored in the query data using the maxPages option, improving performance for large datasets.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/infinite-queries.md#2025-04-19_snippet_7

LANGUAGE: tsx
CODE:
```
useInfiniteQuery({
  queryKey: ['projects'],
  queryFn: fetchProjects,
  initialPageParam: 0,
  getNextPageParam: (lastPage, pages) => lastPage.nextCursor,
  getPreviousPageParam: (firstPage, pages) => firstPage.prevCursor,
  maxPages: 3,
})
```

----------------------------------------

TITLE: Using Vue Query with Composition API and <script setup>
DESCRIPTION: This example demonstrates how to use Vue Query with the Composition API and <script setup> syntax, showing a basic query implementation.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/installation.md#2025-04-19_snippet_5

LANGUAGE: vue
CODE:
```
<script setup>
import { useQuery } from '@tanstack/vue-query'

const { isPending, isFetching, isError, data, error } = useQuery({
  queryKey: ['todos'],
  queryFn: getTodos,
})
</script>

<template>...</template>
```

----------------------------------------

TITLE: Rendering Infinite Query Results in Angular Template
DESCRIPTION: This snippet shows how to render the results of an infinite query in an Angular template. It includes handling loading and error states, iterating over pages and projects, and implementing a load more button.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/infinite-queries.md#2025-04-19_snippet_1

LANGUAGE: angular-html
CODE:
```
<div>
  @if (query.isPending()) {
  <p>Loading...</p>
  } @else if (query.isError()) {
  <span>Error: {{ query?.error().message }}</span>
  } @else { @for (page of query?.data().pages; track $index) { @for (project of
  page.data; track project.id) {
  <p>{{ project.name }} {{ project.id }}</p>
  } }
  <div>
    <button (click)="query.fetchNextPage()" [disabled]="nextButtonDisabled()">
      {{ nextButtonText() }}
    </button>
  </div>
  }
</div>
```

----------------------------------------

TITLE: Configuring Global Retry Delay in TanStack Query for React
DESCRIPTION: This example shows how to set up a global retry delay configuration for all queries using QueryClient. It uses an exponential backoff strategy with a maximum delay of 30 seconds.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/query-retries.md#2025-04-19_snippet_1

LANGUAGE: tsx
CODE:
```
import {
  QueryCache,
  QueryClient,
  QueryClientProvider,
} from '@tanstack/react-query'

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
    },
  },
})

function App() {
  return <QueryClientProvider client={queryClient}>...</QueryClientProvider>
}
```

----------------------------------------

TITLE: Configuring Query Client for Server/Client Environment
DESCRIPTION: Sets up a query client with support for dehydrating pending queries and handling server/client environments. Includes configuration for stale time and error handling.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/advanced-ssr.md#2025-04-19_snippet_7

LANGUAGE: typescript
CODE:
```
import {
  isServer,
  QueryClient,
  defaultShouldDehydrateQuery,
} from '@tanstack/react-query'

function makeQueryClient() {
  return new QueryClient({
    defaultOptions: {
      queries: {
        staleTime: 60 * 1000,
      },
      dehydrate: {
        shouldDehydrateQuery: (query) =>
          defaultShouldDehydrateQuery(query) ||
          query.state.status === 'pending',
        shouldRedactErrors: (error) => {
          return false
        },
      },
    },
  })
}

let browserQueryClient: QueryClient | undefined = undefined

export function getQueryClient() {
  if (isServer) {
    return makeQueryClient()
  } else {
    if (!browserQueryClient) browserQueryClient = makeQueryClient()
    return browserQueryClient
  }
}
```

----------------------------------------

TITLE: Initializing Mutation for Optimistic UI Updates in React Query
DESCRIPTION: Sets up a useMutation hook for adding a todo item, with onSettled callback to invalidate the todos query.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/optimistic-updates.md#2025-04-19_snippet_0

LANGUAGE: tsx
CODE:
```
const addTodoMutation = useMutation({
  mutationFn: (newTodo: string) => axios.post('/api/data', { text: newTodo }),
  // make sure to _return_ the Promise from the query invalidation
  // so that the mutation stays in `pending` state until the refetch is finished
  onSettled: () => queryClient.invalidateQueries({ queryKey: ['todos'] }),
})

const { isPending, submittedAt, variables, mutate, isError } = addTodoMutation
```

----------------------------------------

TITLE: Overriding queryOptions with select function in TanStack Query
DESCRIPTION: This example shows how to override queryOptions at the component level by adding a select function. The select function is used to transform the query result, and TypeScript inference ensures proper typing of the query data.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/query-options.md#2025-04-19_snippet_1

LANGUAGE: typescript
CODE:
```
// Type inference still works, so query.data will be the return type of select instead of queryFn

const query = useQuery({
  ...groupOptions(1),
  select: (data) => data.groupName,
})
```

----------------------------------------

TITLE: Implementing Query Cancellation with Fetch in TanStack Query
DESCRIPTION: Demonstrates how to use the AbortSignal with fetch in a TanStack Query queryFn. The signal is passed to both single and multiple fetch calls to enable cancellation.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/query-cancellation.md#2025-04-19_snippet_0

LANGUAGE: tsx
CODE:
```
const query = useQuery({
  queryKey: ['todos'],
  queryFn: async ({ signal }) => {
    const todosResponse = await fetch('/todos', {
      // Pass the signal to one fetch
      signal,
    })
    const todos = await todosResponse.json()

    const todoDetails = todos.map(async ({ details }) => {
      const response = await fetch(details, {
        // Or pass it to several
        signal,
      })
      return response.json()
    })

    return Promise.all(todoDetails)
  },
})
```

----------------------------------------

TITLE: Creating a Reusable Mutation Hook in TanStack Query
DESCRIPTION: This example demonstrates how to create a custom hook for a reusable mutation. The hook uses the useMutation function and includes onSuccess logic to update the query data. It shows how to access both the returned data and the mutation variables in the onSuccess callback.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/updates-from-mutation-responses.md#2025-04-19_snippet_1

LANGUAGE: tsx
CODE:
```
const useMutateTodo = () => {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: editTodo,
    // Notice the second argument is the variables object that the `mutate` function receives
    onSuccess: (data, variables) => {
      queryClient.setQueryData(['todo', { id: variables.id }], data)
    },
  })
}
```

----------------------------------------

TITLE: Implementing Data Selection with React Query Hooks
DESCRIPTION: Demonstrates how to use React Query's select option to subscribe to data subsets and optimize renders. Shows both basic implementation and a custom hook for counting todos.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/render-optimizations.md#2025-04-19_snippet_0

LANGUAGE: javascript
CODE:
```
export const useTodos = (select) => {
  return useQuery({
    queryKey: ['todos'],
    queryFn: fetchTodos,
    select,
  })
}

export const useTodoCount = () => {
  return useTodos((data) => data.length)
}
```

----------------------------------------

TITLE: Mutation Callback Execution Order
DESCRIPTION: Illustrates the execution order of mutation callbacks when multiple callbacks are defined. In this example, the onSuccess callback will execute first, followed by the onSettled callback.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/mutations.md#2025-04-19_snippet_3

LANGUAGE: typescript
CODE:
```
mutation = injectMutation(() => ({
  mutationFn: addTodo,
  onSuccess: async () => {
    console.log("I'm first!")
  },
  onSettled: async () => {
    console.log("I'm second!")
  },
}))
```

----------------------------------------

TITLE: Implementing Query Cancellation with graphql-request in TanStack Query
DESCRIPTION: Demonstrates how to use the AbortSignal with graphql-request in a TanStack Query queryFn. The signal is passed to the client's request method.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/query-cancellation.md#2025-04-19_snippet_4

LANGUAGE: tsx
CODE:
```
const client = new GraphQLClient(endpoint)

const query = useQuery({
  queryKey: ['todos'],
  queryFn: ({ signal }) => {
    client.request({ document: query, signal })
  },
})
```

----------------------------------------

TITLE: Handling and Throwing Errors in TanStack Query Functions (TSX)
DESCRIPTION: Demonstrates how to handle and throw errors in query functions. TanStack Query requires the function to throw or return a rejected Promise to determine an error state.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/query-functions.md#2025-04-19_snippet_1

LANGUAGE: tsx
CODE:
```
const { error } = useQuery({
  queryKey: ['todos', todoId],
  queryFn: async () => {
    if (somethingGoesWrong) {
      throw new Error('Oh no!')
    }
    if (somethingElseGoesWrong) {
      return Promise.reject(new Error('Oh no!'))
    }

    return data
  },
})
```

----------------------------------------

TITLE: Migrating cacheTime to gcTime in QueryClient Configuration
DESCRIPTION: Shows how to update the QueryClient configuration to use the new gcTime property instead of the deprecated cacheTime. The gcTime property controls garbage collection timing for unused queries.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-v5.md#2025-04-19_snippet_7

LANGUAGE: tsx
CODE:
```
const MINUTE = 1000 * 60;

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
-      cacheTime: 10 * MINUTE, // [!code --]
+      gcTime: 10 * MINUTE, // [!code ++]
    },
  },
})
```

----------------------------------------

TITLE: Optimistic Updates with Rollback in React Query
DESCRIPTION: This example shows how to implement optimistic updates with rollback functionality in React Query. It updates the cache immediately on mutation and reverts changes if the mutation fails.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/updates-from-mutation-responses.md#2025-04-19_snippet_1

LANGUAGE: javascript
CODE:
```
const queryClient = useQueryClient()

const mutation = useMutation(
  (newTodo) => axios.post('/todos', newTodo),
  {
    // When mutate is called:
    onMutate: async (newTodo) => {
      // Cancel any outgoing refetches
      // (so they don't overwrite our optimistic update)
      await queryClient.cancelQueries('todos')

      // Snapshot the previous value
      const previousTodos = queryClient.getQueryData('todos')

      // Optimistically update to the new value
      queryClient.setQueryData('todos', (old) => ({
        ...old,
        todos: [...old.todos, newTodo],
      }))

      // Return a context object with the snapshotted value
      return { previousTodos }
    },
    // If the mutation fails,
    // use the context returned from onMutate to roll back
    onError: (err, newTodo, context) => {
      queryClient.setQueryData('todos', context.previousTodos)
    },
    // Always refetch after error or success:
    onSettled: () => {
      queryClient.invalidateQueries('todos')
    },
  }
)
```

----------------------------------------

TITLE: Structuring Complex Query Keys in TanStack Query (TypeScript)
DESCRIPTION: This snippet shows how to structure more complex query keys for individual items, variations of items, and filtered lists. It demonstrates the use of arrays and objects in query keys.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/query-keys.md#2025-04-19_snippet_1

LANGUAGE: typescript
CODE:
```
// An individual todo
injectQuery(() => ({queryKey: ['todo', 5], ...}))

// An individual todo in a "preview" format
injectQuery(() => ({queryKey: ['todo', 5, {preview: true}], ...}))

// A list of todos that are "done"
injectQuery(() => ({queryKey: ['todos', {type: 'done'}], ...}))
```

----------------------------------------

TITLE: Basic Query Prefetching in TanStack Query
DESCRIPTION: Demonstrates how to prefetch query results using queryClient.prefetchQuery(). The prefetched data is cached and follows standard query caching rules including staleTime and garbage collection behaviors.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/prefetching.md#2025-04-19_snippet_0

LANGUAGE: tsx
CODE:
```
const prefetchTodos = async () => {
  // The results of this query will be cached like a normal query
  await queryClient.prefetchQuery({
    queryKey: ['todos'],
    queryFn: fetchTodos,
  })
}
```

----------------------------------------

TITLE: Reversing Page Order in Infinite Query Results
DESCRIPTION: This snippet shows how to use the select option to reverse the order of pages in the infinite query results, useful for displaying newest data first.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/infinite-queries.md#2025-04-19_snippet_3

LANGUAGE: tsx
CODE:
```
useInfiniteQuery({
  queryKey: ['projects'],
  queryFn: fetchProjects,
  select: (data) => ({
    pages: [...data.pages].reverse(),
    pageParams: [...data.pageParams].reverse(),
  }),
})
```

----------------------------------------

TITLE: Basic Suspense Query Implementation in TypeScript
DESCRIPTION: Demonstrates the basic usage of useSuspenseQuery hook for data fetching with React Suspense
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/suspense.md#2025-04-19_snippet_0

LANGUAGE: tsx
CODE:
```
import { useSuspenseQuery } from '@tanstack/react-query'

const { data } = useSuspenseQuery({ queryKey, queryFn })
```

----------------------------------------

TITLE: Basic Query Implementation in Angular Component
DESCRIPTION: Simple example of using injectQuery to set up a query in an Angular component. The query fetches a list of todos using a predefined fetch function.
SOURCE: https://github.com/tanstack/query/blob/main/packages/angular-query-experimental/README.md#2025-04-19_snippet_6

LANGUAGE: typescript
CODE:
```
import { injectQuery } from '@tanstack/angular-query-experimental'
import { Component } from '@angular/core'

@Component({...})
export class TodosComponent {
  info = injectQuery(() => ({ queryKey: ['todos'], queryFn: fetchTodoList }))
}
```

----------------------------------------

TITLE: Implementing Todo List Query with Loading States in Angular
DESCRIPTION: Demonstrates how to handle different query states including pending, error, success, and background fetching for a todo list component. Uses TanStack Query's injectQuery hook to manage the data fetching states.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/background-fetching-indicators.md#2025-04-19_snippet_0

LANGUAGE: angular-ts
CODE:
```
@Component({
  selector: 'todos',
  template: `
    @if (todosQuery.isPending()) {
      Loading...
    } @else if (todosQuery.isError()) {
      An error has occurred: {{ todosQuery.error().message }}
    } @else if (todosQuery.isSuccess()) {
      @if (todosQuery.isFetching()) {
        Refreshing...
      }
      @for (todos of todosQuery.data(); track todo.id) {
        <todo [todo]="todo" />
      }
    }
  `,
})
class TodosComponent {
  todosQuery = injectQuery(() => ({
    queryKey: ['todos'],
    queryFn: fetchTodos,
  }))
}
```

----------------------------------------

TITLE: Basic Mutation Implementation in Angular Component
DESCRIPTION: Demonstrates a basic implementation of injectMutation in an Angular component to create a todo item. The component shows different UI states based on the mutation's status (pending, error, success).
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/mutations.md#2025-04-19_snippet_0

LANGUAGE: angular-ts
CODE:
```
@Component({
  template: `
    <div>
      @if (mutation.isPending()) {
        <span>Adding todo...</span>
      } @else if (mutation.isError()) {
        <div>An error occurred: {{ mutation.error()?.message }}</div>
      } @else if (mutation.isSuccess()) {
        <div>Todo added!</div>
      }
      <button (click)="mutation.mutate(1)">Create Todo</button>
    </div>
  `,
})
export class TodosComponent {
  todoService = inject(TodoService)
  mutation = injectMutation(() => ({
    mutationFn: (todoId: number) =>
      lastValueFrom(this.todoService.create(todoId)),
  }))
}
```

----------------------------------------

TITLE: Defining and Using queryOptions in TanStack Query
DESCRIPTION: This snippet demonstrates how to define queryOptions for a group query and use it with various query hooks and methods. It showcases the flexibility and reusability of queryOptions across different query operations.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/query-options.md#2025-04-19_snippet_0

LANGUAGE: typescript
CODE:
```
import { queryOptions } from '@tanstack/react-query'

function groupOptions(id: number) {
  return queryOptions({
    queryKey: ['groups', id],
    queryFn: () => fetchGroups(id),
    staleTime: 5 * 1000,
  })
}

// usage:

useQuery(groupOptions(1))
useSuspenseQuery(groupOptions(5))
useQueries({
  queries: [groupOptions(1), groupOptions(2)],
})
queryClient.prefetchQuery(groupOptions(23))
queryClient.setQueryData(groupOptions(42).queryKey, newGroups)
```

----------------------------------------

TITLE: Consecutive Mutations Example
DESCRIPTION: Shows how to handle consecutive mutations and their callback behavior with multiple mutation calls.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/mutations.md#2025-04-19_snippet_6

LANGUAGE: tsx
CODE:
```
useMutation({
  mutationFn: addTodo,
  onSuccess: (data, variables, context) => {
    // Will be called 3 times
  },
})

const todos = ['Todo 1', 'Todo 2', 'Todo 3']
todos.forEach((todo) => {
  mutate(todo, {
    onSuccess: (data, variables, context) => {
      // Will execute only once, for the last mutation (Todo 3),
      // regardless which mutation resolves first
    },
  })
})
```

----------------------------------------

TITLE: Testing Network Calls with Nock
DESCRIPTION: Example of testing a React Query hook that makes network requests using the Nock library for mocking.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/testing.md#2025-04-19_snippet_5

LANGUAGE: tsx
CODE:
```
const queryClient = new QueryClient()
const wrapper = ({ children }) => (
  <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
)

const expectation = nock('http://example.com').get('/api/data').reply(200, {
  answer: 42,
})

const { result } = renderHook(() => useFetchData(), { wrapper })

await waitFor(() => expect(result.current.isSuccess).toBe(true))

expect(result.current.data).toEqual({ answer: 42 })
```

----------------------------------------

TITLE: Implementing Basic Mutation in Vue with TanStack Query
DESCRIPTION: This snippet shows how to use the useMutation hook from @tanstack/vue-query to implement a basic mutation for adding a todo item. It demonstrates handling pending, error, and success states, as well as triggering the mutation.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/mutations.md#2025-04-19_snippet_0

LANGUAGE: vue
CODE:
```
<script setup>
import { useMutation } from '@tanstack/vue-query'

const { isPending, isError, error, isSuccess, mutate } = useMutation({
  mutationFn: (newTodo) => axios.post('/todos', newTodo),
})

function addTodo() {
  mutate({ id: new Date(), title: 'Do Laundry' })
}
</script>

<template>
  <span v-if="isPending">Adding todo...</span>
  <span v-else-if="isError">An error occurred: {{ error.message }}</span>
  <span v-else-if="isSuccess">Todo added!</span>
  <button @click="addTodo">Create Todo</button>
</template>
```

----------------------------------------

TITLE: Global Background Fetching Indicator with TanStack Query
DESCRIPTION: Shows how to implement a global loading indicator that displays when any query in the application is fetching data. Uses the useIsFetching hook to track global fetching state.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/background-fetching-indicators.md#2025-04-19_snippet_1

LANGUAGE: tsx
CODE:
```
import { useIsFetching } from '@tanstack/react-query'

function GlobalLoadingIndicator() {
  const isFetching = useIsFetching()

  return isFetching ? (
    <div>Queries are fetching in the background...</div>
  ) : null
}
```

----------------------------------------

TITLE: Configuring Infinite Query Options in TanStack Query
DESCRIPTION: Demonstrates how to configure infinite query options using the infiniteQueryOptions function. The function accepts a queryKey parameter and additional options that are compatible with useInfiniteQuery. The queryKey parameter is required and is used to generate the appropriate query options.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/reference/infiniteQueryOptions.md#2025-04-19_snippet_0

LANGUAGE: tsx
CODE:
```
infiniteQueryOptions({
  queryKey,
  ...options,
})
```

----------------------------------------

TITLE: Implementing Cache-based Optimistic Updates in React Query
DESCRIPTION: Shows how to update the cache optimistically when adding a new todo, with error handling and rollback functionality.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/optimistic-updates.md#2025-04-19_snippet_4

LANGUAGE: tsx
CODE:
```
const queryClient = useQueryClient()

useMutation({
  mutationFn: updateTodo,
  // When mutate is called:
  onMutate: async (newTodo) => {
    // Cancel any outgoing refetches
    // (so they don't overwrite our optimistic update)
    await queryClient.cancelQueries({ queryKey: ['todos'] })

    // Snapshot the previous value
    const previousTodos = queryClient.getQueryData(['todos'])

    // Optimistically update to the new value
    queryClient.setQueryData(['todos'], (old) => [...old, newTodo])

    // Return a context object with the snapshotted value
    return { previousTodos }
  },
  // If the mutation fails,
  // use the context returned from onMutate to roll back
  onError: (err, newTodo, context) => {
    queryClient.setQueryData(['todos'], context.previousTodos)
  },
  // Always refetch after error or success:
  onSettled: () => queryClient.invalidateQueries({ queryKey: ['todos'] }),
})
```

----------------------------------------

TITLE: Removing a Single Value from an Individual Page in Infinite Query
DESCRIPTION: This example shows how to manually update the infinite query data by removing a specific value from an individual page.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/infinite-queries.md#2025-04-19_snippet_5

LANGUAGE: tsx
CODE:
```
const newPagesArray =
  oldPagesArray?.pages.map((page) =>
    page.filter((val) => val.id !== updatedId),
  ) ?? []

queryClient.setQueryData(['projects'], (data) => ({
  pages: newPagesArray,
  pageParams: data.pageParams,
}))
```

----------------------------------------

TITLE: Dynamic Query Keys with Signals in TanStack Query (TypeScript)
DESCRIPTION: This snippet demonstrates how to use dynamic query keys with signals. It shows how to create a query that depends on a signal value and is only enabled when the signal meets certain conditions.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/query-keys.md#2025-04-19_snippet_4

LANGUAGE: typescript
CODE:
```
todoId = signal(-1)

injectQuery(() => ({
  enabled: todoId() > 0,
  queryKey: ['todos', todoId()],
  queryFn: () => fetchTodoById(todoId()),
}))
```

----------------------------------------

TITLE: Implementing Mutation Options Helper with TypeScript in TanStack Query
DESCRIPTION: This snippet demonstrates how to use the mutationOptions helper in a QueriesService class to define and share mutation options. It includes a type-safe mutation function, mutation key, and an onSuccess callback that updates query data with the QueryClient.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/mutation-options.md#2025-04-19_snippet_0

LANGUAGE: typescript
CODE:
```
export class QueriesService {
  private http = inject(HttpClient)

  updatePost(id: number) {
    return mutationOptions({
      mutationFn: (post: Post) => Promise.resolve(post),
      mutationKey: ['updatePost', id],
      onSuccess: (newPost) => {
        //           ^? newPost: Post
        this.queryClient.setQueryData(['posts', id], newPost)
      },
    })
  }
}
```

----------------------------------------

TITLE: Prefetching in Parent Component with TanStack Query
DESCRIPTION: Shows how to prefetch data in a parent component to avoid request waterfalls. This example prefetches article comments data in the Article component.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/prefetching.md#2025-04-19_snippet_4

LANGUAGE: tsx
CODE:
```
function Article({ id }) {
  const { data: articleData, isPending } = useQuery({
    queryKey: ['article', id],
    queryFn: getArticleById,
  })

  // Prefetch
  useQuery({
    queryKey: ['article-comments', id],
    queryFn: getArticleCommentsById,
    // Optional optimization to avoid rerenders when this query changes:
    notifyOnChangeProps: [],
  })

  if (isPending) {
    return 'Loading article...'
  }

  return (
    <>
      <ArticleHeader articleData={articleData} />
      <ArticleBody articleData={articleData} />
      <Comments id={id} />
    </>
  )
}

function Comments({ id }) {
  const { data, isPending } = useQuery({
    queryKey: ['article-comments', id],
    queryFn: getArticleCommentsById,
  })

  ...
}
```

----------------------------------------

TITLE: Prefetching Query Data in TanStack Query
DESCRIPTION: Demonstrates how to use queryClient.prefetchQuery to cache query results ahead of time. This function prefetches todos data and caches it like a normal query.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/prefetching.md#2025-04-19_snippet_0

LANGUAGE: tsx
CODE:
```
const prefetchTodos = async () => {
  // The results of this query will be cached like a normal query
  await queryClient.prefetchQuery({
    queryKey: ['todos'],
    queryFn: fetchTodos,
  })
}
```

----------------------------------------

TITLE: Testing Infinite Query Implementation
DESCRIPTION: Test implementation for infinite scroll functionality using React Query.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/testing.md#2025-04-19_snippet_8

LANGUAGE: tsx
CODE:
```
const { result } = renderHook(() => useInfiniteQueryCustomHook(), {
  wrapper,
})

await waitFor(() => expect(result.current.isSuccess).toBe(true))

expect(result.current.data.pages).toStrictEqual(generateMockedResponse(1))

result.current.fetchNextPage()

await waitFor(() =>
  expect(result.current.data.pages).toStrictEqual([
    ...generateMockedResponse(1),
    ...generateMockedResponse(2),
  ]),
)

expectation.done()
```

----------------------------------------

TITLE: Implementing Default Query Function with TanStack Query and Vue
DESCRIPTION: Shows how to create a default query function that works with axios for HTTP requests, configure it with Vue Query plugin options, and use it in queries. The function automatically handles requests to JSONPlaceholder API based on the provided query key.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/default-query-function.md#2025-04-19_snippet_0

LANGUAGE: tsx
CODE:
```
// Define a default query function that will receive the query key
const defaultQueryFn = async ({ queryKey }) => {
  const { data } = await axios.get(
    `https://jsonplaceholder.typicode.com${queryKey[0]}`,
  )
  return data
}

// provide the default query function to your app with defaultOptions
const vueQueryPluginOptions: VueQueryPluginOptions = {
  queryClientConfig: {
    defaultOptions: { queries: { queryFn: defaultQueryFn } },
  },
}
app.use(VueQueryPlugin, vueQueryPluginOptions)

// All you have to do now is pass a key!
const { status, data, error, isFetching } = useQuery({
  queryKey: [`/posts/${postId}`],
})
```

----------------------------------------

TITLE: Invalidating Multiple Queries After Mutation in Vue Query
DESCRIPTION: Example showing how to invalidate multiple query keys ('todos' and 'reminders') after a successful mutation using the useQueryClient and useMutation hooks from TanStack Vue Query. The invalidation triggers a refetch of the affected queries.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/invalidations-from-mutations.md#2025-04-19_snippet_0

LANGUAGE: tsx
CODE:
```
import { useMutation, useQueryClient } from '@tanstack/vue-query'

const queryClient = useQueryClient()

// When this mutation succeeds, invalidate any queries with the `todos` or `reminders` query key
const mutation = useMutation({
  mutationFn: addTodo,
  onSuccess: () => {
    queryClient.invalidateQueries({ queryKey: ['todos'] })
    queryClient.invalidateQueries({ queryKey: ['reminders'] })
  },
})
```

----------------------------------------

TITLE: Error Handling in Query Functions
DESCRIPTION: Shows how to implement error handling in query functions using both throw statements and Promise rejections. Demonstrates proper error handling patterns for async query functions.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/query-functions.md#2025-04-19_snippet_1

LANGUAGE: typescript
CODE:
```
todos = injectQuery(() => ({
  queryKey: ['todos', todoId()],
  queryFn: async () => {
    if (somethingGoesWrong) {
      throw new Error('Oh no!')
    }
    if (somethingElseGoesWrong) {
      return Promise.reject(new Error('Oh no!'))
    }

    return data
  },
}))
```

----------------------------------------

TITLE: Dynamic Query Parameters with Destructuring
DESCRIPTION: Shows how to work with dynamic query parameters using object destructuring in the queryKey. Demonstrates passing multiple parameters and accessing them in the query function.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/query-functions.md#2025-04-19_snippet_3

LANGUAGE: typescript
CODE:
```
result = injectQuery(() => ({
  queryKey: ['todos', { status: status(), page: page() }],
  queryFn: fetchTodoList,
}))

// Access the key, status and page variables in your query function!
function fetchTodoList({ queryKey }) {
  const [_key, { status, page }] = queryKey
  return new Promise()
}
```

----------------------------------------

TITLE: Async Mutation Callbacks
DESCRIPTION: Shows how to handle async operations in mutation callbacks with proper ordering of operations.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/mutations.md#2025-04-19_snippet_4

LANGUAGE: tsx
CODE:
```
useMutation({
  mutationFn: addTodo,
  onSuccess: async () => {
    console.log("I'm first!")
  },
  onSettled: async () => {
    console.log("I'm second!")
  },
})
```

----------------------------------------

TITLE: Query Prefix Matching Invalidation
DESCRIPTION: Shows how to invalidate multiple queries that share a common prefix in their query keys. Demonstrates the effect on different query configurations.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/query-invalidation.md#2025-04-19_snippet_1

LANGUAGE: tsx
CODE:
```
import { useQuery, useQueryClient } from '@tanstack/react-query'

// Get QueryClient from the context
const queryClient = useQueryClient()

queryClient.invalidateQueries({ queryKey: ['todos'] })

// Both queries below will be invalidated
const todoListQuery = useQuery({
  queryKey: ['todos'],
  queryFn: fetchTodoList,
})
const todoListQuery = useQuery({
  queryKey: ['todos', { page: 1 }],
  queryFn: fetchTodoList,
})
```

----------------------------------------

TITLE: Nested Component Waterfall Example
DESCRIPTION: Example showing how nested components with queries can create waterfalls and how to optimize by hoisting queries to the parent component.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/request-waterfalls.md#2025-04-19_snippet_3

LANGUAGE: typescript
CODE:
```
function Article({ id }) {
  const { data: articleData, isPending } = useQuery({
    queryKey: ['article', id],
    queryFn: getArticleById,
  })

  if (isPending) {
    return 'Loading article...'
  }

  return (
    <>
      <ArticleHeader articleData={articleData} />
      <ArticleBody articleData={articleData} />
      <Comments id={id} />
    </>
  )

}

function Comments({ id }) {
  const { data, isPending } = useQuery({
    queryKey: ['article-comments', id],
    queryFn: getArticleCommentsById,
  })

  ...
}
```

----------------------------------------

TITLE: Optimizing Select Function with useCallback
DESCRIPTION: Shows how to memoize the select function using useCallback to prevent unnecessary re-runs on each render.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/render-optimizations.md#2025-04-19_snippet_1

LANGUAGE: javascript
CODE:
```
export const useTodoCount = () => {
  return useTodos(useCallback((data) => data.length, []))
}
```

----------------------------------------

TITLE: Executing Dynamic Parallel Queries in Vue with TanStack Query
DESCRIPTION: This snippet shows how to dynamically generate and execute parallel queries based on a computed list of users. It uses the useQueries hook to create multiple queries for individual users, with each query fetching data for a specific user ID.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/parallel-queries.md#2025-04-19_snippet_1

LANGUAGE: javascript
CODE:
```
const users = computed(...)
const queries = computed(() => users.value.map(user => {
    return {
      queryKey: ['user', user.id],
      queryFn: () => fetchUserById(user.id),
    }
  })
);
const userQueries = useQueries({queries: queries})
```

----------------------------------------

TITLE: Using fetchQuery with Error Handling
DESCRIPTION: Demonstrates how to fetch and cache query data asynchronously with error handling.
SOURCE: https://github.com/tanstack/query/blob/main/docs/reference/QueryClient.md#2025-04-19_snippet_1

LANGUAGE: tsx
CODE:
```
try {
  const data = await queryClient.fetchQuery({ queryKey, queryFn })
} catch (error) {
  console.log(error)
}
```

----------------------------------------

TITLE: Basic Usage of useMutation in Solid.js
DESCRIPTION: This example demonstrates the basic usage of the useMutation hook in a Solid.js component. It shows how to define a mutation function and use the returned mutation object to trigger the mutation and access its state.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/solid/reference/useMutation.md#2025-04-19_snippet_1

LANGUAGE: javascript
CODE:
```
function App() {
  const mutation = useMutation(() => {
    return postTodo({
      id: new Date(),
      title: 'Do Laundry',
    })
  })

  return (
    <div>
      {mutation.isPending ? (
        'Adding todo...'
      ) : (
        <>
          {mutation.isError ? (
            <div>An error occurred: {mutation.error.message}</div>
          ) : null}

          {mutation.isSuccess ? <div>Todo added!</div> : null}

          <button
            onClick={() => {
              mutation.mutate()
            }}
          >
            Create Todo
          </button>
        </>
      )}
    </div>
  )
}
```

----------------------------------------

TITLE: Using usePrefetchInfiniteQuery Hook in TanStack Query (TSX)
DESCRIPTION: This snippet demonstrates the basic usage of the usePrefetchInfiniteQuery hook. It is used to prefetch infinite query data during render, before a suspense boundary that wraps a component using useSuspenseInfiniteQuery. The hook requires several options including queryKey, queryFn, initialPageParam, and getNextPageParam.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/reference/usePrefetchInfiniteQuery.md#2025-04-19_snippet_0

LANGUAGE: tsx
CODE:
```
usePrefetchInfiniteQuery(options)
```

----------------------------------------

TITLE: Using queryOptions Helper for Type Inference in React Query (TypeScript)
DESCRIPTION: Demonstrates the use of the queryOptions helper to maintain type inference when extracting query options into a separate function.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/typescript.md#2025-04-19_snippet_10

LANGUAGE: ts
CODE:
```
import { queryOptions } from '@tanstack/react-query'

function groupOptions() {
  return queryOptions({
    queryKey: ['groups'],
    queryFn: fetchGroups,
    staleTime: 5 * 1000,
  })
}

useQuery(groupOptions())
queryClient.prefetchQuery(groupOptions())

const data = queryClient.getQueryData(groupOptions().queryKey)
//     ^? const data: Group[] | undefined
```

----------------------------------------

TITLE: Rendering Pending Todo Items in Angular Template
DESCRIPTION: Shows how to display a list of todos in an Angular component template with special styling for pending items. Pending todos are shown with reduced opacity while the mutation is in progress.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/optimistic-updates.md#2025-04-19_snippet_1

LANGUAGE: angular-ts
CODE:
```
@Component({
  template: `
    @for (todo of todos.data(); track todo.id) {
      <li>{{ todo.title }}</li>
    }
    @if (addTodo.isPending()) {
      <li style="opacity: 0.5">{{ addTodo.variables() }}</li>
    }
  `,
})
class TodosComponent {}
```

----------------------------------------

TITLE: Importing and Using broadcastQueryClient in TypeScript
DESCRIPTION: This snippet demonstrates how to import the broadcastQueryClient function from the experimental package and use it with a QueryClient instance. It shows the basic setup for broadcasting the query client state across browser tabs.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/plugins/broadcastQueryClient.md#2025-04-19_snippet_0

LANGUAGE: tsx
CODE:
```
import { broadcastQueryClient } from '@tanstack/query-broadcast-client-experimental'

const queryClient = new QueryClient()

broadcastQueryClient({
  queryClient,
  broadcastChannel: 'my-app',
})
```

----------------------------------------

TITLE: Signal Integration with TanStack Query
DESCRIPTION: Shows how to integrate SolidJS signals with TanStack Query, demonstrating reactive query parameters and enabled states.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/solid/quick-start.md#2025-04-19_snippet_3

LANGUAGE: tsx
CODE:
```
import {
  QueryClient,
  QueryClientProvider,
  useQuery,
} from '@tanstack/solid-query'
import { createSignal, For } from 'solid-js'

const queryClient = new QueryClient()

function Example() {
  const [enabled, setEnabled] = createSignal(false)
  const [todo, setTodo] = createSignal(0)

  const todosQuery = useQuery(() => ({
    queryKey: ['todos'],
    queryFn: fetchTodos,
    enabled: enabled(),
  }))

  const todoDetailsQuery = useQuery(() => ({
    queryKey: ['todo', todo()],
    queryFn: fetchTodo,
    enabled: todo() > 0,
  }))

  return (
    <div>
      <Switch>
        <Match when={todosQuery.isPending}>
          <p>Loading...</p>
        </Match>
        <Match when={todosQuery.isError}>
          <p>Error: {todosQuery.error.message}</p>
        </Match>
        <Match when={todosQuery.isSuccess}>
          <For each={todosQuery.data}>
            {(todo) => (
              <button onClick={() => setTodo(todo.id)}>{todo.title}</button>
            )}
          </For>
        </Match>
      </Switch>
      <button onClick={() => setEnabled(!enabled())}>Toggle enabled</button>
    </div>
  )
}

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <Example />
    </QueryClientProvider>
  )
}
```

----------------------------------------

TITLE: Configuring Pagination Parameters for Infinite Query
DESCRIPTION: This snippet shows how to configure next and previous page parameters for an infinite query using TanStack Query. It uses cursor-based pagination with nextCursor and prevCursor.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/infinite-queries.md#2025-04-19_snippet_3

LANGUAGE: ts
CODE:
```
query = injectInfiniteQuery(() => ({
  queryKey: ['projects'],
  queryFn: fetchProjects,
  getNextPageParam: (lastPage, pages) => lastPage.nextCursor,
  getPreviousPageParam: (firstPage, pages) => firstPage.prevCursor,
}))
```

----------------------------------------

TITLE: Optimizing Dependent Queries with Prefetching
DESCRIPTION: Shows how to optimize dependent queries by implementing prefetching in the query function to load code and data in parallel, reducing waterfall requests.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/prefetching.md#2025-04-19_snippet_6

LANGUAGE: tsx
CODE:
```
function Feed() {
  const queryClient = useQueryClient()
  const { data, isPending } = useQuery({
    queryKey: ['feed'],
    queryFn: async (...args) => {
      const feed = await getFeed(...args)

      for (const feedItem of feed) {
        if (feedItem.type === 'GRAPH') {
          queryClient.prefetchQuery({
            queryKey: ['graph', feedItem.id],
            queryFn: getGraphDataById,
          })
        }
      }

      return feed
    }
  })

  ...
}
```

----------------------------------------

TITLE: Setting Placeholder Data as a Value in TanStack Query
DESCRIPTION: Demonstrates how to set placeholder data for a query using the placeholderData option. This allows the query to start in a success state with initial data while fetching actual data in the background.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/placeholder-query-data.md#2025-04-19_snippet_0

LANGUAGE: tsx
CODE:
```
function Todos() {
  const result = useQuery({
    queryKey: ['todos'],
    queryFn: () => fetch('/todos'),
    placeholderData: placeholderTodos,
  })
}
```

----------------------------------------

TITLE: Optimized Next.js Setup with Reduced Boilerplate
DESCRIPTION: Streamlined implementation of TanStack Query in Next.js, reducing boilerplate by moving HydrationBoundary to _app.tsx.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/ssr.md#2025-04-19_snippet_7

LANGUAGE: tsx
CODE:
```
// _app.tsx
import {
  HydrationBoundary,
  QueryClient,
  QueryClientProvider,
} from '@tanstack/react-query'

export default function MyApp({ Component, pageProps }) {
  const [queryClient] = React.useState(() => new QueryClient())

  return (
    <QueryClientProvider client={queryClient}>
      <HydrationBoundary state={pageProps.dehydratedState}>
        <Component {...pageProps} />
      </HydrationBoundary>
    </QueryClientProvider>
  )
}
```

----------------------------------------

TITLE: Using PersistQueryClientProvider with Local Storage
DESCRIPTION: Implementation example showing how to set up persistence using PersistQueryClientProvider with local storage in a React application.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/plugins/persistQueryClient.md#2025-04-19_snippet_1

LANGUAGE: tsx
CODE:
```
import { PersistQueryClientProvider } from '@tanstack/react-query-persist-client'
import { createSyncStoragePersister } from '@tanstack/query-sync-storage-persister'

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      gcTime: 1000 * 60 * 60 * 24, // 24 hours
    },
  },
})

const persister = createSyncStoragePersister({
  storage: window.localStorage,
})

ReactDOM.createRoot(rootElement).render(
  <PersistQueryClientProvider
    client={queryClient}
    persistOptions={{ persister }}
  >
    <App />
  </PersistQueryClientProvider>,
)
```

----------------------------------------

TITLE: Basic Query Invalidation with TanStack Angular Query
DESCRIPTION: Demonstrates basic query invalidation for todos using QueryClient. Shows how invalidation affects queries with matching base keys.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/query-invalidation.md#2025-04-19_snippet_0

LANGUAGE: typescript
CODE:
```
import { injectQuery, QueryClient } from '@tanstack/angular-query-experimental'

class QueryInvalidationExample {
  queryClient = inject(QueryClient)

  invalidateQueries() {
    this.queryClient.invalidateQueries({ queryKey: ['todos'] })
  }

  // Both queries below will be invalidated
  todoListQuery = injectQuery(() => ({
    queryKey: ['todos'],
    queryFn: fetchTodoList,
  }))
  todoListQuery = injectQuery(() => ({
    queryKey: ['todos', { page: 1 }],
    queryFn: fetchTodoList,
  }))
}
```

----------------------------------------

TITLE: Invalidating Query Cache After Mutation Success in TanStack Angular Query
DESCRIPTION: Example showing how to invalidate specific query keys after a successful mutation. This demonstrates using onSuccess callback to trigger cache invalidation for both 'todos' and 'reminders' query keys.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/invalidations-from-mutations.md#2025-04-19_snippet_1

LANGUAGE: typescript
CODE:
```
import {
  injectMutation,
  QueryClient,
} from '@tanstack/angular-query-experimental'

export class TodosComponent {
  queryClient = inject(QueryClient)

  // When this mutation succeeds, invalidate any queries with the `todos` or `reminders` query key
  mutation = injectMutation(() => ({
    mutationFn: addTodo,
    onSuccess: () => {
      this.queryClient.invalidateQueries({ queryKey: ['todos'] })
      this.queryClient.invalidateQueries({ queryKey: ['reminders'] })
    },
  }))
}
```

----------------------------------------

TITLE: Prefetching Query Data
DESCRIPTION: Shows how to prefetch query data without requiring immediate access to the results.
SOURCE: https://github.com/tanstack/query/blob/main/docs/reference/QueryClient.md#2025-04-19_snippet_4

LANGUAGE: tsx
CODE:
```
await queryClient.prefetchQuery({ queryKey, queryFn })
```

----------------------------------------

TITLE: Proper Typing of API Calls in React Query (TypeScript)
DESCRIPTION: Demonstrates how to properly type API calls to ensure correct type inference in React Query.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/typescript.md#2025-04-19_snippet_2

LANGUAGE: tsx
CODE:
```
const fetchGroups = (): Promise<Group[]> =>
  axios.get('/groups').then((response) => response.data)

const { data } = useQuery({ queryKey: ['groups'], queryFn: fetchGroups })
//      ^? const data: Group[] | undefined
```

----------------------------------------

TITLE: Optimized Client-Side Navigation with Prefetching
DESCRIPTION: This snippet demonstrates an optimized request waterfall for client-side navigation using prefetching techniques. It shows how parallel requests can be made to improve performance in modern frameworks like Next.js or Remix.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/ssr.md#2025-04-19_snippet_12

LANGUAGE: markdown
CODE:
```
```
1. |> JS for <Feed>
1. |> getFeed() + getGraphDataById()
2.   |> JS for <GraphFeedItem>
```
```

----------------------------------------

TITLE: Next.js Page Route Implementation with TanStack Query
DESCRIPTION: Implementation of TanStack Query in a Next.js page route, demonstrating prefetching and hydration patterns for server-side data fetching.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/ssr.md#2025-04-19_snippet_5

LANGUAGE: tsx
CODE:
```
// pages/posts.tsx
import {
  dehydrate,
  HydrationBoundary,
  QueryClient,
  useQuery,
} from '@tanstack/react-query'

export async function getStaticProps() {
  const queryClient = new QueryClient()

  await queryClient.prefetchQuery({
    queryKey: ['posts'],
    queryFn: getPosts,
  })

  return {
    props: {
      dehydratedState: dehydrate(queryClient),
    },
  }
}

function Posts() {
  const { data } = useQuery({ queryKey: ['posts'], queryFn: getPosts })
  const { data: commentsData } = useQuery({
    queryKey: ['posts-comments'],
    queryFn: getComments,
  })
}

export default function PostsRoute({ dehydratedState }) {
  return (
    <HydrationBoundary state={dehydratedState}>
      <Posts />
    </HydrationBoundary>
  )
}
```

----------------------------------------

TITLE: Implementing Infinite Scroll with TanStack Query in Angular
DESCRIPTION: This example demonstrates how to implement infinite scrolling using TanStack Query in an Angular component. It uses a list component with an endReached event to trigger fetching the next page.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/infinite-queries.md#2025-04-19_snippet_2

LANGUAGE: angular-ts
CODE:
```
@Component({
  template: ` <list-component (endReached)="fetchNextPage()" /> `,
})
export class Example {
  query = injectInfiniteQuery(() => ({
    queryKey: ['projects'],
    queryFn: async ({ pageParam }) => {
      return lastValueFrom(this.projectsService.getProjects(pageParam))
    },
  }))

  fetchNextPage() {
    // Do nothing if already fetching
    if (this.query.isFetching()) return
    this.query.fetchNextPage()
  }
}
```

----------------------------------------

TITLE: Using Placeholder Data as a Function in TanStack Query
DESCRIPTION: Illustrates how to use a function for placeholderData, allowing access to previous query data. This is useful for maintaining data continuity when transitioning between queries, such as in paginated scenarios.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/placeholder-query-data.md#2025-04-19_snippet_2

LANGUAGE: tsx
CODE:
```
const result = useQuery({
  queryKey: ['todos', id],
  queryFn: () => fetch(`/todos/${id}`),
  placeholderData: (previousData, previousQuery) => previousData,
})
```

----------------------------------------

TITLE: Predicate-based Query Invalidation
DESCRIPTION: Demonstrates advanced query invalidation using a predicate function to selectively invalidate queries based on custom conditions in their query keys.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/query-invalidation.md#2025-04-19_snippet_4

LANGUAGE: tsx
CODE:
```
queryClient.invalidateQueries({
  predicate: (query) =>
    query.queryKey[0] === 'todos' && query.queryKey[1]?.version >= 10,
})

// The query below will be invalidated
const todoListQuery = useQuery({
  queryKey: ['todos', { version: 20 }],
  queryFn: fetchTodoList,
})

// The query below will be invalidated
const todoListQuery = useQuery({
  queryKey: ['todos', { version: 10 }],
  queryFn: fetchTodoList,
})

// However, the following query below will NOT be invalidated
const todoListQuery = useQuery({
  queryKey: ['todos', { version: 5 }],
  queryFn: fetchTodoList,
})
```

----------------------------------------

TITLE: Configuring Vue Query Plugin for Nuxt 3
DESCRIPTION: This snippet shows how to set up the Vue Query plugin for Nuxt 3, including dehydration and hydration of query state. It creates a custom plugin that handles server-side prefetching and client-side rehydration.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/ssr.md#2025-04-19_snippet_0

LANGUAGE: typescript
CODE:
```
import type {
  DehydratedState,
  VueQueryPluginOptions,
} from '@tanstack/vue-query'
import {
  VueQueryPlugin,
  QueryClient,
  hydrate,
  dehydrate,
} from '@tanstack/vue-query'
// Nuxt 3 app aliases
import { defineNuxtPlugin, useState } from '#imports'

export default defineNuxtPlugin((nuxt) => {
  const vueQueryState = useState<DehydratedState | null>('vue-query')

  // Modify your Vue Query global settings here
  const queryClient = new QueryClient({
    defaultOptions: { queries: { staleTime: 5000 } },
  })
  const options: VueQueryPluginOptions = { queryClient }

  nuxt.vueApp.use(VueQueryPlugin, options)

  if (import.meta.server) {
    nuxt.hooks.hook('app:rendered', () => {
      vueQueryState.value = dehydrate(queryClient)
    })
  }

  if (import.meta.client) {
    hydrate(queryClient, vueQueryState.value)
  }
})
```

----------------------------------------

TITLE: Manual Query Cancellation in TanStack Query with Angular
DESCRIPTION: Demonstrates how to manually cancel a query using queryClient.cancelQueries() method. This example shows an Angular component with a cancel button that triggers the cancellation of an ongoing query based on its query key.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/query-cancellation.md#2025-04-19_snippet_3

LANGUAGE: angular-ts
CODE:
```
@Component({
  standalone: true,
  template: `<button (click)="onCancel()">Cancel</button>`,
})
export class TodosComponent {
  query = injectQuery(() => ({
    queryKey: ['todos'],
    queryFn: async ({ signal }) => {
      const resp = await fetch('/todos', { signal })
      return resp.json()
    },
  }))

  queryClient = inject(QueryClient)

  onCancel() {
    this.queryClient.cancelQueries(['todos'])
  }
}
```

----------------------------------------

TITLE: Basic Mutation Setup in TanStack Query
DESCRIPTION: Simple example showing how to set up a basic mutation for posting a todo item using useMutation hook.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/invalidations-from-mutations.md#2025-04-19_snippet_0

LANGUAGE: tsx
CODE:
```
const mutation = useMutation({ mutationFn: postTodo })
```

----------------------------------------

TITLE: Using Related Query Data as Initial Data in TanStack Query
DESCRIPTION: Shows how to populate a single-item query with data from a collection query. This approach leverages existing data in the query cache to provide immediate results for related queries.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/initial-query-data.md#2025-04-19_snippet_5

LANGUAGE: typescript
CODE:
```
result = injectQuery(() => ({
  queryKey: ['todo', this.todoId()],
  queryFn: () => fetch('/todos'),
  initialData: () => {
    // Use a todo from the 'todos' query as the initial data for this todo query
    return this.queryClient
      .getQueryData(['todos'])
      ?.find((d) => d.id === this.todoId())
  },
}))
```

----------------------------------------

TITLE: Implementing Query Cancellation with Axios v0.22.0+ in TanStack Query
DESCRIPTION: Shows how to use the AbortSignal with Axios version 0.22.0 or higher in a TanStack Query queryFn. The signal is passed directly to the Axios configuration object.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/query-cancellation.md#2025-04-19_snippet_1

LANGUAGE: tsx
CODE:
```
import axios from 'axios'

const query = useQuery({
  queryKey: ['todos'],
  queryFn: ({ signal }) =>
    axios.get('/todos', {
      // Pass the signal to `axios`
      signal,
    }),
})
```

----------------------------------------

TITLE: Executing Static Parallel Queries in Vue with TanStack Query
DESCRIPTION: This snippet demonstrates how to execute multiple queries in parallel using the useQuery hook from TanStack Query in a Vue component. It shows three separate queries for users, teams, and projects that will run concurrently.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/parallel-queries.md#2025-04-19_snippet_0

LANGUAGE: vue
CODE:
```
<script setup lang="ts">
// The following queries will execute in parallel
const usersQuery = useQuery({ queryKey: ['users'], queryFn: fetchUsers })
const teamsQuery = useQuery({ queryKey: ['teams'], queryFn: fetchTeams })
const projectsQuery = useQuery({
  queryKey: ['projects'],
  queryFn: fetchProjects,
})
</script>
```

----------------------------------------

TITLE: Implementing Infinite Query without API Cursor
DESCRIPTION: This snippet demonstrates how to implement an infinite query when the API doesn't return a cursor, using the pageParam as a cursor instead.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/infinite-queries.md#2025-04-19_snippet_8

LANGUAGE: tsx
CODE:
```
return useInfiniteQuery({
  queryKey: ['projects'],
  queryFn: fetchProjects,
  initialPageParam: 0,
  getNextPageParam: (lastPage, allPages, lastPageParam) => {
    if (lastPage.length === 0) {
      return undefined
    }
    return lastPageParam + 1
  },
  getPreviousPageParam: (firstPage, allPages, firstPageParam) => {
    if (firstPageParam <= 1) {
      return undefined
    }
    return firstPageParam - 1
  },
})
```

----------------------------------------

TITLE: Using Dynamic Placeholder Data from Cache
DESCRIPTION: Demonstrates how to implement dynamic placeholder data by accessing the query cache. This example shows retrieving a preview version of a blog post from an existing query cache to use as placeholder data.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/placeholder-query-data.md#2025-04-19_snippet_1

LANGUAGE: tsx
CODE:
```
const result = useQuery({
  queryKey: ['blogPost', blogPostId],
  queryFn: () => fetch(`/blogPosts/${blogPostId}`),
  placeholderData: () => {
    // Use the smaller/preview version of the blogPost from the 'blogPosts'
    // query as the placeholder data for this blogPost query
    return queryClient
      .getQueryData(['blogPosts'])
      ?.find((d) => d.id === blogPostId)
  },
})
```

----------------------------------------

TITLE: Setting Mutation Default Options with setMutationDefaults in TanStack Query
DESCRIPTION: The setMutationDefaults method sets default options for specific mutations identified by their mutation key. These defaults are automatically applied when using the corresponding mutation key.
SOURCE: https://github.com/tanstack/query/blob/main/docs/reference/QueryClient.md#2025-04-19_snippet_26

LANGUAGE: tsx
CODE:
```
queryClient.setMutationDefaults(['addPost'], { mutationFn: addPost })

function Component() {
  const { data } = useMutation({ mutationKey: ['addPost'] })
}
```

----------------------------------------

TITLE: Setting Maximum Pages in Infinite Query
DESCRIPTION: This snippet shows how to limit the number of pages fetched in an infinite query using the maxPages option. It also includes configuration for initial page parameter and pagination functions.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/infinite-queries.md#2025-04-19_snippet_5

LANGUAGE: ts
CODE:
```
injectInfiniteQuery(() => ({
  queryKey: ['projects'],
  queryFn: fetchProjects,
  initialPageParam: 0,
  getNextPageParam: (lastPage, pages) => lastPage.nextCursor,
  getPreviousPageParam: (firstPage, pages) => firstPage.prevCursor,
  maxPages: 3,
}))
```

----------------------------------------

TITLE: Implementing Basic Paginated Query with TanStack Query in React
DESCRIPTION: This snippet shows how to use the injectQuery function to create a paginated query in a React application. It uses a dynamic queryKey based on the current page and a fetchProjects function for data fetching.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/paginated-queries.md#2025-04-19_snippet_0

LANGUAGE: typescript
CODE:
```
const result = injectQuery(() => ({
  queryKey: ['projects', page()],
  queryFn: fetchProjects,
}))
```

----------------------------------------

TITLE: Manually Removing First Page from Infinite Query Data
DESCRIPTION: This code snippet demonstrates how to manually update the infinite query data by removing the first page using the queryClient.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/infinite-queries.md#2025-04-19_snippet_4

LANGUAGE: tsx
CODE:
```
queryClient.setQueryData(['projects'], (data) => ({
  pages: data.pages.slice(1),
  pageParams: data.pageParams.slice(1),
}))
```

----------------------------------------

TITLE: Using Angular HttpClient with TanStack Query in TypeScript
DESCRIPTION: This snippet demonstrates how to use Angular's HttpClient within a TanStack Query queryFn. It shows how to convert the HttpClient's observable to a promise using lastValueFrom from rxjs.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/angular-httpclient-and-other-data-fetching-clients.md#2025-04-19_snippet_0

LANGUAGE: typescript
CODE:
```
@Component({
  // ...
})
class ExampleComponent {
  private readonly http = inject(HttpClient)

  readonly query = injectQuery(() => ({
    queryKey: ['repoData'],
    queryFn: () =>
      lastValueFrom(
        this.http.get('https://api.github.com/repos/tanstack/query'),
      ),
  }))
}
```

----------------------------------------

TITLE: GitHub Repository Data Fetching Example
DESCRIPTION: Example showing how to fetch GitHub repository data using TanStack Query in SolidJS with proper reactive access patterns.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/solid/quick-start.md#2025-04-19_snippet_2

LANGUAGE: tsx
CODE:
```
import {
  QueryClient,
  QueryClientProvider,
  useQuery,
} from '@tanstack/solid-query'
import { Match, Switch } from 'solid-js'

const queryClient = new QueryClient()

export default function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <Example />
    </QueryClientProvider>
  )
}

function Example() {
  const query = useQuery(() => ({
    queryKey: ['repoData'],
    queryFn: () =>
      fetch('https://api.github.com/repos/tannerlinsley/react-query').then(
        (res) => res.json(),
      ),
  }))

  return (
    <Switch>
      <Match when={query.isPending}>Loading...</Match>
      <Match when={query.isError}>Error: {query.error.message}</Match>
      <Match when={query.isSuccess}>
        <div>
          <h1>{query.data.name}</h1>
          <p>{query.data.description}</p>
          <strong>üëÄ {query.data.subscribers_count}</strong>{' '}
          <strong>‚ú® {query.data.stargazers_count}</strong>{' '}
          <strong>üç¥ {query.data.forks_count}</strong>
        </div>
      </Match>
    </Switch>
  )
}
```

----------------------------------------

TITLE: Implementing Online Status Management in React Native with React Query
DESCRIPTION: This snippet demonstrates how to use the React Query onlineManager with NetInfo to manage online status in a React Native app. It sets up an event listener to update the online status based on network connectivity.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/react-native.md#2025-04-19_snippet_0

LANGUAGE: tsx
CODE:
```
import NetInfo from '@react-native-community/netinfo'
import { onlineManager } from '@tanstack/react-query'

onlineManager.setEventListener((setOnline) => {
  return NetInfo.addEventListener((state) => {
    setOnline(!!state.isConnected)
  })
})
```

----------------------------------------

TITLE: Retrieving Placeholder Data from Cache in TanStack Query
DESCRIPTION: Demonstrates how to provide placeholder data for a query from the cached result of another query. This example shows finding a preview version of a blog post from a list query to use as placeholder data for an individual post query.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/placeholder-query-data.md#2025-04-19_snippet_3

LANGUAGE: tsx
CODE:
```
function Todo({ blogPostId }) {
  const queryClient = useQueryClient()
  const result = useQuery({
    queryKey: ['blogPost', blogPostId],
    queryFn: () => fetch(`/blogPosts/${blogPostId}`),
    placeholderData: () => {
      // Use the smaller/preview version of the blogPost from the 'blogPosts'
      // query as the placeholder data for this blogPost query
      return queryClient
        .getQueryData(['blogPosts'])
        ?.find((d) => d.id === blogPostId)
    },
  })
}
```

----------------------------------------

TITLE: Invalidating Queries in TSX
DESCRIPTION: Example of using queryClient.invalidateQueries to invalidate and optionally refetch queries based on query keys and filters.
SOURCE: https://github.com/tanstack/query/blob/main/docs/reference/QueryClient.md#2025-04-19_snippet_14

LANGUAGE: tsx
CODE:
```
await queryClient.invalidateQueries(
  {
    queryKey: ['posts'],
    exact,
    refetchType: 'active',
  },
  { throwOnError, cancelRefetch },
)
```

----------------------------------------

TITLE: Specific Variable Query Invalidation
DESCRIPTION: Demonstrates how to invalidate queries with specific variables by using more detailed query keys. Shows selective invalidation based on query key matching.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/query-invalidation.md#2025-04-19_snippet_2

LANGUAGE: tsx
CODE:
```
queryClient.invalidateQueries({
  queryKey: ['todos', { type: 'done' }],
})

// The query below will be invalidated
const todoListQuery = useQuery({
  queryKey: ['todos', { type: 'done' }],
  queryFn: fetchTodoList,
})

// However, the following query below will NOT be invalidated
const todoListQuery = useQuery({
  queryKey: ['todos'],
  queryFn: fetchTodoList,
})
```

----------------------------------------

TITLE: Implementing App Focus Handling in React Native with React Query
DESCRIPTION: This snippet demonstrates how to handle app focus changes in React Native using the AppState module and React Query's focusManager. It sets up an event listener to update the focus status when the app state changes.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/react-native.md#2025-04-19_snippet_2

LANGUAGE: tsx
CODE:
```
import { useEffect } from 'react'
import { AppState, Platform } from 'react-native'
import type { AppStateStatus } from 'react-native'
import { focusManager } from '@tanstack/react-query'

function onAppStateChange(status: AppStateStatus) {
  if (Platform.OS !== 'web') {
    focusManager.setFocused(status === 'active')
  }
}

useEffect(() => {
  const subscription = AppState.addEventListener('change', onAppStateChange)

  return () => subscription.remove()
}, [])
```

----------------------------------------

TITLE: Dependent Query Waterfall Example
DESCRIPTION: Example showing how dependent queries in React Query can create request waterfalls, where the second query depends on data from the first query.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/request-waterfalls.md#2025-04-19_snippet_1

LANGUAGE: typescript
CODE:
```
const { data: user } = useQuery({
  queryKey: ['user', email],
  queryFn: getUserByEmail,
})

const userId = user?.id

const {
  status,
  fetchStatus,
  data: projects,
} = useQuery({
  queryKey: ['projects', userId],
  queryFn: getProjectsByUser,
  // The query will not execute until the userId exists
  enabled: !!userId,
})
```

----------------------------------------

TITLE: Implementing Dependent Queries with Code Splitting in React
DESCRIPTION: Demonstrates how to implement dependent queries with code splitting using React.lazy() and TanStack Query. Shows a pattern that creates a request waterfall when loading feed items.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/prefetching.md#2025-04-19_snippet_5

LANGUAGE: tsx
CODE:
```
const GraphFeedItem = React.lazy(() => import('./GraphFeedItem'))

function Feed() {
  const { data, isPending } = useQuery({
    queryKey: ['feed'],
    queryFn: getFeed,
  })

  if (isPending) {
    return 'Loading feed...'
  }

  return (
    <>
      {data.map((feedItem) => {
        if (feedItem.type === 'GRAPH') {
          return <GraphFeedItem key={feedItem.id} feedItem={feedItem} />
        }

        return <StandardFeedItem key={feedItem.id} feedItem={feedItem} />
      })}
    </>
  )}

// GraphFeedItem.tsx
function GraphFeedItem({ feedItem }) {
  const { data, isPending } = useQuery({
    queryKey: ['graph', feedItem.id],
    queryFn: getGraphDataById,
  })

  ...
}
```

----------------------------------------

TITLE: Creating Lazy Queries with Conditional Enabling in TanStack Query (TSX)
DESCRIPTION: This example shows how to create a lazy query that only executes when a filter is applied. The query is enabled conditionally based on the filter value, demonstrating the use of the 'enabled' option with a dynamic condition.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/disabling-queries.md#2025-04-19_snippet_1

LANGUAGE: tsx
CODE:
```
function Todos() {
  const [filter, setFilter] = React.useState('')

  const { data } = useQuery({
    queryKey: ['todos', filter],
    queryFn: () => fetchTodos(filter),
    // ‚¨áÔ∏è disabled as long as the filter is empty
    enabled: !!filter,
  })

  return (
    <div>
      // üöÄ applying the filter will enable and execute the query
      <FiltersForm onApply={setFilter} />
      {data && <TodosTable data={data} />}
    </div>
  )
}
```

----------------------------------------

TITLE: Multiple Mutations with Callback Behavior
DESCRIPTION: Demonstrates the behavior of callbacks when multiple mutations are triggered in sequence. The mutation's onSuccess callback will be called for each mutation, while the mutate's onSuccess will only be called once for the last mutation.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/mutations.md#2025-04-19_snippet_5

LANGUAGE: typescript
CODE:
```
export class Example {
  mutation = injectMutation(() => ({
    mutationFn: addTodo,
    onSuccess: (data, variables, context) => {
      // Will be called 3 times
    },
  }))

  doMutations() {
    ;['Todo 1', 'Todo 2', 'Todo 3'].forEach((todo) => {
      this.mutation.mutate(todo, {
        onSuccess: (data, variables, context) => {
          // Will execute only once, for the last mutation (Todo 3),
          // regardless which mutation resolves first
        },
      })
    })
  }
}
```

----------------------------------------

TITLE: Using HydrationBoundary Component in React Query
DESCRIPTION: The HydrationBoundary component adds a previously dehydrated state into the queryClient returned by useQueryClient(). It's used to wrap parts of the application that need access to the hydrated query state.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/reference/hydration.md#2025-04-19_snippet_3

LANGUAGE: tsx
CODE:
```
import { HydrationBoundary } from '@tanstack/react-query'

function App() {
  return <HydrationBoundary state={dehydratedState}>...</HydrationBoundary>
}
```

----------------------------------------

TITLE: Using Async Mutations with mutateAsync
DESCRIPTION: Shows how to use the mutateAsync method to handle mutations asynchronously with try/catch/finally blocks, providing cleaner error handling for async operations.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/mutations.md#2025-04-19_snippet_6

LANGUAGE: typescript
CODE:
```
mutation = injectMutation(() => ({ mutationFn: addTodo }))

try {
  const todo = await mutation.mutateAsync(todo)
  console.log(todo)
} catch (error) {
  console.error(error)
} finally {
  console.log('done')
}
```

----------------------------------------

TITLE: Invalidating Multiple Queries After Mutation Success
DESCRIPTION: Demonstrates how to invalidate multiple query keys (todos and reminders) after a successful mutation using queryClient.invalidateQueries. Shows integration with useMutation's onSuccess callback.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/invalidations-from-mutations.md#2025-04-19_snippet_1

LANGUAGE: tsx
CODE:
```
import { useMutation, useQueryClient } from '@tanstack/react-query'

const queryClient = useQueryClient()

// When this mutation succeeds, invalidate any queries with the `todos` or `reminders` query key
const mutation = useMutation({
  mutationFn: addTodo,
  onSuccess: () => {
    queryClient.invalidateQueries({ queryKey: ['todos'] })
    queryClient.invalidateQueries({ queryKey: ['reminders'] })
  },
})
```

----------------------------------------

TITLE: Deriving Placeholder Data from Cache in TanStack Query for Angular
DESCRIPTION: This advanced example demonstrates deriving placeholder data from another query's cached results. It retrieves a specific blog post from a list of blog posts already in the cache, providing a seamless user experience while the detailed data is being fetched.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/placeholder-query-data.md#2025-04-19_snippet_2

LANGUAGE: typescript
CODE:
```
export class BlogPostComponent {
  // Until Angular supports signal-based inputs, we have to set a signal
  @Input({ required: true, alias: 'postId' })
  set _postId(value: number) {
    this.postId.set(value)
  }
  postId = signal(0)
  queryClient = inject(QueryClient)

  result = injectQuery(() => ({
    queryKey: ['blogPost', this.postId()],
    queryFn: () => fetch(`/blogPosts/${this.postId()}`),
    placeholderData: () => {
      // Use the smaller/preview version of the blogPost from the 'blogPosts'
      // query as the placeholder data for this blogPost query
      return queryClient
        .getQueryData(['blogPosts'])
        ?.find((d) => d.id === this.postId())
    },
  }))
}
```

----------------------------------------

TITLE: Creating a Reusable QueryClient for Server Components
DESCRIPTION: This snippet shows how to create a single QueryClient that can be reused across all Server Components. It uses React's cache function to ensure the QueryClient is scoped per request and doesn't leak data between requests.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/advanced-ssr.md#2025-04-19_snippet_5

LANGUAGE: tsx
CODE:
```
// app/getQueryClient.tsx
import { QueryClient } from '@tanstack/react-query'
import { cache } from 'react'

// cache() is scoped per request, so we don't leak data between requests
const getQueryClient = cache(() => new QueryClient())
export default getQueryClient
```

----------------------------------------

TITLE: Correct Usage of useQuery in React Query Without Object Rest Destructuring
DESCRIPTION: This example shows the correct approach to using useQuery without object rest destructuring. It demonstrates assigning the query result to a variable and then using normal object destructuring to access specific properties.
SOURCE: https://github.com/tanstack/query/blob/main/docs/eslint/no-rest-destructuring.md#2025-04-19_snippet_1

LANGUAGE: tsx
CODE:
```
const todosQuery = useQuery({
  queryKey: ['todos'],
  queryFn: () => api.getTodos(),
})

// normal object destructuring is fine
const { data: todos } = todosQuery
```

----------------------------------------

TITLE: Implementing Query Cancellation in TanStack Query
DESCRIPTION: Example showing how to set up a cancellable query using the signal parameter and how to manually cancel queries using queryClient. The queryFn receives an AbortSignal that can be passed to fetch requests, while the cancelQueries method allows explicit cancellation of running queries.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/solid/guides/query-cancellation.md#2025-04-19_snippet_0

LANGUAGE: typescript
CODE:
```
const query = useQuery({
  queryKey: ['todos'],
  queryFn: async ({ signal }) => {
    const resp = await fetch('/todos', { signal })
    return resp.json()
  },
})

const queryClient = useQueryClient()

function onButtonClick() {
  queryClient.cancelQueries({ queryKey: ['todos'] })
}
```

----------------------------------------

TITLE: Using initialData with initialDataUpdatedAt from Cache (TypeScript/React)
DESCRIPTION: This snippet shows how to use 'initialDataUpdatedAt' when getting initial data from the cache. It passes the source query's 'dataUpdatedAt' to provide accurate information for determining when to refetch.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/initial-query-data.md#2025-04-19_snippet_6

LANGUAGE: tsx
CODE:
```
const result = useQuery({
  queryKey: ['todos', todoId],
  queryFn: () => fetch(`/todos/${todoId}`),
  initialData: () =>
    queryClient.getQueryData(['todos'])?.find((d) => d.id === todoId),
  initialDataUpdatedAt: () =>
    queryClient.getQueryState(['todos'])?.dataUpdatedAt,
})
```

----------------------------------------

TITLE: TanStack Router Integration with Query Prefetching
DESCRIPTION: Demonstrates how to integrate TanStack Query with TanStack Router, including route-level data prefetching and conditional rendering based on data availability.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/prefetching.md#2025-04-19_snippet_7

LANGUAGE: tsx
CODE:
```
const queryClient = new QueryClient()
const routerContext = new RouterContext()
const rootRoute = routerContext.createRootRoute({
  component: () => { ... }
})

const articleRoute = new Route({
  getParentRoute: () => rootRoute,
  path: 'article',
  beforeLoad: () => {
    return {
      articleQueryOptions: { queryKey: ['article'], queryFn: fetchArticle },
      commentsQueryOptions: { queryKey: ['comments'], queryFn: fetchComments },
    }
  },
  loader: async ({
    context: { queryClient },
    routeContext: { articleQueryOptions, commentsQueryOptions },
  }) => {
    // Fetch comments asap, but don't block
    queryClient.prefetchQuery(commentsQueryOptions)

    // Don't render the route at all until article has been fetched
    await queryClient.prefetchQuery(articleQueryOptions)
  },
  component: ({ useRouteContext }) => {
    const { articleQueryOptions, commentsQueryOptions } = useRouteContext()
    const articleQuery = useQuery(articleQueryOptions)
    const commentsQuery = useQuery(commentsQueryOptions)

    return (
      ...
    )
  },
  errorComponent: () => 'Oh crap!',
})
```

----------------------------------------

TITLE: Additional Mutation Callbacks
DESCRIPTION: Demonstrates how to add additional callback handlers when calling mutate, showing the execution order of multiple callbacks.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/mutations.md#2025-04-19_snippet_5

LANGUAGE: tsx
CODE:
```
useMutation({
  mutationFn: addTodo,
  onSuccess: (data, variables, context) => {
    // I will fire first
  },
  onError: (error, variables, context) => {
    // I will fire first
  },
  onSettled: (data, error, variables, context) => {
    // I will fire first
  },
})

mutate(todo, {
  onSuccess: (data, variables, context) => {
    // I will fire second!
  },
  onError: (error, variables, context) => {
    // I will fire second!
  },
  onSettled: (data, error, variables, context) => {
    // I will fire second!
  },
})
```

----------------------------------------

TITLE: Initializing QueryClient with Default Options
DESCRIPTION: Shows how to create a new QueryClient instance with custom default options for queries, setting infinite staleTime.
SOURCE: https://github.com/tanstack/query/blob/main/docs/reference/QueryClient.md#2025-04-19_snippet_0

LANGUAGE: tsx
CODE:
```
import { QueryClient } from '@tanstack/react-query'

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: Infinity,
    },
  },
})

await queryClient.prefetchQuery({ queryKey: ['posts'], queryFn: fetchPosts })
```

----------------------------------------

TITLE: Creating Global Loading Indicator for Background Fetches
DESCRIPTION: Shows how to implement a global loading indicator component that displays when any query is fetching in the background. Uses the injectIsFetching hook from TanStack Query to track global fetching state.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/background-fetching-indicators.md#2025-04-19_snippet_1

LANGUAGE: angular-ts
CODE:
```
import { injectIsFetching } from '@tanstack/angular-query-experimental'

@Component({
  selector: 'global-loading-indicator',
  template: `
    @if (isFetching()) {
      <div>Queries are fetching in the background...</div>
    }
  `,
})
export class GlobalLoadingIndicatorComponent {
  isFetching = injectIsFetching()
}
```

----------------------------------------

TITLE: Conditionally Enabling Queries in Vue Query
DESCRIPTION: This example shows how to conditionally enable a query based on a computed property. The query is only enabled when the 'filter' ref has a non-empty value, demonstrating dynamic query enabling.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/disabling-queries.md#2025-04-19_snippet_1

LANGUAGE: vue
CODE:
```
<script setup>
import { useQuery } from '@tanstack/vue-query'

const filter = ref('')
const isEnabled = computed(() => !!filter.value)
const { data } = useQuery({
  queryKey: ['todos', filter],
  queryFn: () => fetchTodos(filter),
  // ‚¨áÔ∏è disabled as long as the filter is empty
  enabled: isEnabled,
})
</script>

<template>
  <span v-if="data">Filter was set and data is here!</span>
</template>
```

----------------------------------------

TITLE: Immediate Display with Refetch in TanStack Query
DESCRIPTION: Shows how to display initial data immediately while also triggering an immediate refetch when the component or service is created. This ensures fresh data while avoiding an empty loading state.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/initial-query-data.md#2025-04-19_snippet_1

LANGUAGE: typescript
CODE:
```
// Will show initialTodos immediately, but also immediately refetch todos
// when an instance of the component or service is created
result = injectQuery(() => ({
  queryKey: ['todos'],
  queryFn: () => fetch('/todos'),
  initialData: initialTodos,
}))
```

----------------------------------------

TITLE: Configuring QueryClient for Advanced Mutation Handling in Vue
DESCRIPTION: This snippet shows how to configure QueryClient with default options for queries and mutations. It includes setting up mutation defaults, implementing client persistence, and handling paused mutations after page reload. This configuration is typically done at the application root level.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/mutations.md#2025-04-19_snippet_2

LANGUAGE: javascript
CODE:
```
const client = new QueryClient({
  defaultOptions: {
    queries: {
      gcTime: 1000 * 60 * 60 * 24, // 24 hours
    },
  },
})

// we need a default mutation function so that paused mutations can resume after a page reload
queryClient.setMutationDefaults({
  mutationKey: ['todos'],
  mutationFn: ({ id, data }) => {
    return api.updateTodo(id, data)
  },
})

const vueQueryOptions: VueQueryPluginOptions = {
  queryClient: client,
  clientPersister: (queryClient) => {
    return persistQueryClient({
      queryClient,
      persister: createSyncStoragePersister({ storage: localStorage }),
    })
  },
  clientPersisterOnSuccess: (queryClient) => {
    queryClient.resumePausedMutations()
  },
}

createApp(App).use(VueQueryPlugin, vueQueryOptions).mount('#app')
```

----------------------------------------

TITLE: Creating a Custom Hook for Refreshing Queries on Screen Focus in React Native
DESCRIPTION: This snippet defines a custom hook called useRefreshOnFocus that triggers a refetch function when a React Native screen comes into focus. It uses React Navigation's useFocusEffect to detect screen focus changes.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/react-native.md#2025-04-19_snippet_3

LANGUAGE: tsx
CODE:
```
import React from 'react'
import { useFocusEffect } from '@react-navigation/native'

export function useRefreshOnFocus<T>(refetch: () => Promise<T>) {
  const firstTimeRef = React.useRef(true)

  useFocusEffect(
    React.useCallback(() => {
      if (firstTimeRef.current) {
        firstTimeRef.current = false
        return
      }

      refetch()
    }, [refetch]),
  )
}
```

----------------------------------------

TITLE: Setting Query with initialData and Custom staleTime (TypeScript/React)
DESCRIPTION: This snippet illustrates how to configure a query with both 'initialData' and a custom 'staleTime'. It will show initial data immediately and delay refetching until after the specified stale time.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/initial-query-data.md#2025-04-19_snippet_2

LANGUAGE: tsx
CODE:
```
const result = useQuery({
  queryKey: ['todos'],
  queryFn: () => fetch('/todos'),
  initialData: initialTodos,
  staleTime: 1000,
})
```

----------------------------------------

TITLE: Basic Type Inference in TanStack Query
DESCRIPTION: Demonstrates basic type inference for query results without explicit type annotations.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/solid/typescript.md#2025-04-19_snippet_0

LANGUAGE: tsx
CODE:
```
import { useQuery } from '@tanstack/solid-query'

const query = useQuery(() => ({
  queryKey: ['number'],
  queryFn: () => Promise.resolve(5),
}))

query.data
//    ^? (property) data: number | undefined
```

----------------------------------------

TITLE: Implementing QueryErrorResetBoundary with ErrorBoundary in React
DESCRIPTION: This snippet demonstrates how to use the QueryErrorResetBoundary component from React Query along with an ErrorBoundary to handle and reset query errors. It shows the setup for catching errors, displaying a fallback UI, and providing a way to retry the query.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/reference/QueryErrorResetBoundary.md#2025-04-19_snippet_0

LANGUAGE: tsx
CODE:
```
import { QueryErrorResetBoundary } from '@tanstack/react-query'
import { ErrorBoundary } from 'react-error-boundary'

const App = () => (
  <QueryErrorResetBoundary>
    {({ reset }) => (
      <ErrorBoundary
        onReset={reset}
        fallbackRender={({ resetErrorBoundary }) => (
          <div>
            There was an error!
            <Button onClick={() => resetErrorBoundary()}>Try again</Button>
          </div>
        )}
      >
        <Page />
      </ErrorBoundary>
    )}
  </QueryErrorResetBoundary>
)
```

----------------------------------------

TITLE: Configuring Mutation Retry Logic
DESCRIPTION: Demonstrates how to configure retry behavior for mutations by setting the retry option, which specifies how many times a mutation should be retried before giving up.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/mutations.md#2025-04-19_snippet_7

LANGUAGE: typescript
CODE:
```
mutation = injectMutation(() => ({
  mutationFn: addTodo,
  retry: 3,
}))
```

----------------------------------------

TITLE: Implementing Query Cancellation with Angular HttpClient in TanStack Query
DESCRIPTION: An example of using Angular's HttpClient with TanStack Query's AbortSignal to create a cancellable query. This implementation converts the AbortSignal events to an Observable using fromEvent and pipes it with takeUntil to ensure the HTTP request is properly cancelled.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/query-cancellation.md#2025-04-19_snippet_0

LANGUAGE: typescript
CODE:
```
import { HttpClient } from '@angular/common/http'
import { injectQuery } from '@tanstack/angular-query-experimental'

postQuery = injectQuery(() => ({
  enabled: this.postId() > 0,
  queryKey: ['post', this.postId()],
  queryFn: async (context): Promise<Post> => {
    const abort$ = fromEvent(context.signal, 'abort')
    return lastValueFrom(this.getPost$(this.postId()).pipe(takeUntil(abort$)))
  },
}))
```

----------------------------------------

TITLE: Installing @tanstack/query-persist-client-core Package
DESCRIPTION: Commands for installing the @tanstack/query-persist-client-core package using various package managers.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/plugins/createPersister.md#2025-04-19_snippet_0

LANGUAGE: bash
CODE:
```
npm install @tanstack/query-persist-client-core
```

LANGUAGE: bash
CODE:
```
pnpm add @tanstack/query-persist-client-core
```

LANGUAGE: bash
CODE:
```
yarn add @tanstack/query-persist-client-core
```

LANGUAGE: bash
CODE:
```
bun add @tanstack/query-persist-client-core
```

----------------------------------------

TITLE: Dynamic Parallel Queries Using injectQueries in Angular
DESCRIPTION: This code snippet shows how to use injectQueries to dynamically execute multiple queries based on a variable number of items. It maps over an array of users and creates a query for each user to fetch their detailed information in parallel. Note that this feature is mentioned as being under development.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/parallel-queries.md#2025-04-19_snippet_1

LANGUAGE: TypeScript
CODE:
```
export class AppComponent {
  users = signal<Array<User>>([])

  // Please note injectQueries is under development and this code does not work yet
  userQueries = injectQueries(() => ({
    queries: users().map((user) => {
      return {
        queryKey: ['user', user.id],
        queryFn: () => fetchUserById(user.id),
      }
    }),
  }))
}
```

----------------------------------------

TITLE: Replacing isDataEqual with structuralSharing in TanStack Query v5
DESCRIPTION: This snippet demonstrates how to replace the removed isDataEqual option with a custom structuralSharing function to achieve the same functionality.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-v5.md#2025-04-19_snippet_6

LANGUAGE: tsx
CODE:
```
 import { replaceEqualDeep } from '@tanstack/react-query'

- isDataEqual: (oldData, newData) => customCheck(oldData, newData) // [!code --]
+ structuralSharing: (oldData, newData) => customCheck(oldData, newData) ? oldData : replaceEqualDeep(oldData, newData) // [!code ++]
```

----------------------------------------

TITLE: Basic Query with Initial Data in TanStack Query
DESCRIPTION: A simple example of using initialData with injectQuery to provide immediate data for a query. This allows the query to display data immediately while still fetching fresh data from the server.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/initial-query-data.md#2025-04-19_snippet_0

LANGUAGE: typescript
CODE:
```
result = injectQuery(() => ({
  queryKey: ['todos'],
  queryFn: () => fetch('/todos'),
  initialData: initialTodos,
}))
```

----------------------------------------

TITLE: Using Static Placeholder Data in TanStack Query
DESCRIPTION: Example showing how to set static placeholder data for a query using the placeholderData option. This allows displaying temporary data while the actual query is loading.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/placeholder-query-data.md#2025-04-19_snippet_0

LANGUAGE: tsx
CODE:
```
const result = useQuery({
  queryKey: ['todos'],
  queryFn: () => fetch('/todos'),
  placeholderData: placeholderTodos,
})
```

----------------------------------------

TITLE: Disabling Queries on Out-of-Focus Screens in React Native with React Query
DESCRIPTION: This snippet shows how to use the 'subscribed' prop of useQuery along with React Navigation's useIsFocused hook to disable queries when a screen is not in focus. This optimization helps manage resource usage in React Native apps.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/react-native.md#2025-04-19_snippet_4

LANGUAGE: tsx
CODE:
```
import React from 'react'
import { useIsFocused } from '@react-navigation/native'
import { useQuery } from '@tanstack/react-query'
import { Text } from 'react-native'

function MyComponent() {
  const isFocused = useIsFocused()

  const { dataUpdatedAt } = useQuery({
    queryKey: ['key'],
    queryFn: () => fetch(...),
    subscribed: isFocused,
  })

  return <Text>DataUpdatedAt: {dataUpdatedAt}</Text>
}
```

----------------------------------------

TITLE: Reactive Usage of injectQuery in Angular
DESCRIPTION: Shows how to use injectQuery with reactive programming concepts in Angular, using signals to dynamically enable/disable the query based on a filter value.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/functions/injectquery.md#2025-04-19_snippet_1

LANGUAGE: typescript
CODE:
```
class ServiceOrComponent {
  filter = signal('')

  todosQuery = injectQuery(() => ({
    queryKey: ['todos', this.filter()],
    queryFn: () => fetchTodos(this.filter()),
    // Signals can be combined with expressions
    enabled: !!this.filter(),
  }))
}
```

----------------------------------------

TITLE: Configuring QueryClient with Persister in Vue
DESCRIPTION: Example of creating a QueryClient with a persister configured for all queries. It uses localStorage for storage and sets a 12-hour maxAge for persisted data.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/plugins/createPersister.md#2025-04-19_snippet_1

LANGUAGE: tsx
CODE:
```
import { QueryClient } from '@tanstack/vue-query'
import { experimental_createPersister } from '@tanstack/query-persist-client-core'

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      gcTime: 1000 * 30, // 30 seconds
      persister: experimental_createPersister({
        storage: localStorage,
        maxAge: 1000 * 60 * 60 * 12, // 12 hours
      }),
    },
  },
})
```

----------------------------------------

TITLE: Data Ownership and Revalidation with Server Components
DESCRIPTION: This example illustrates potential issues with data ownership and revalidation when using React Query with Server Components. It shows how rendering query results in both Server and Client Components can lead to synchronization problems during client-side revalidation.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/advanced-ssr.md#2025-04-19_snippet_6

LANGUAGE: tsx
CODE:
```
// app/posts/page.tsx
import {
  dehydrate,
  HydrationBoundary,
  QueryClient,
} from '@tanstack/react-query'
import Posts from './posts'

export default async function PostsPage() {
  const queryClient = new QueryClient()

  // Note we are now using fetchQuery()
  const posts = await queryClient.fetchQuery({
    queryKey: ['posts'],
    queryFn: getPosts,
  })

  return (
    <HydrationBoundary state={dehydrate(queryClient)}>
      {/* This is the new part */}
      <div>Nr of posts: {posts.length}</div>
      <Posts />
    </HydrationBoundary>
  )
}
```

----------------------------------------

TITLE: Using onSettled for Error Handling in React Query Mutations
DESCRIPTION: Shows how to use the onSettled function instead of separate onError and onSuccess handlers in a mutation.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/optimistic-updates.md#2025-04-19_snippet_6

LANGUAGE: tsx
CODE:
```
useMutation({
  mutationFn: updateTodo,
  // ...
  onSettled: async (newTodo, error, variables, context) => {
    if (error) {
      // do something
    }
  },
})
```

----------------------------------------

TITLE: Implementing Custom Pagination Logic in Infinite Query
DESCRIPTION: This example demonstrates advanced pagination logic for an infinite query. It includes custom functions for determining next and previous page parameters based on current data and page numbers.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/infinite-queries.md#2025-04-19_snippet_6

LANGUAGE: ts
CODE:
```
injectInfiniteQuery(() => ({
  queryKey: ['projects'],
  queryFn: fetchProjects,
  initialPageParam: 0,
  getNextPageParam: (lastPage, allPages, lastPageParam) => {
    if (lastPage.length === 0) {
      return undefined
    }
    return lastPageParam + 1
  },
  getPreviousPageParam: (firstPage, allPages, firstPageParam) => {
    if (firstPageParam <= 1) {
      return undefined
    }
    return firstPageParam - 1
  },
}))
```

----------------------------------------

TITLE: Initializing TanStack Query with injectQuery Hook
DESCRIPTION: Example of using the injectQuery hook to fetch and cache todos data. The query is identified by its queryKey ['todos'] and uses the fetchTodos function to retrieve data. This snippet demonstrates how TanStack Query manages caching and refetching.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/caching.md#2025-04-19_snippet_0

LANGUAGE: javascript
CODE:
```
injectQuery(() => ({ queryKey: ['todos'], queryFn: fetchTodos }))
```

----------------------------------------

TITLE: Demonstrating Type Inference in React Query (TypeScript)
DESCRIPTION: Shows how React Query automatically infers types for query results without explicit type annotations.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/typescript.md#2025-04-19_snippet_0

LANGUAGE: tsx
CODE:
```
const { data } = useQuery({
  //    ^? const data: number | undefined
  queryKey: ['test'],
  queryFn: () => Promise.resolve(5),
})
```

----------------------------------------

TITLE: Using useIsMutating Hook in React with TanStack Query
DESCRIPTION: Demonstrates how to use the useIsMutating hook to get the count of ongoing mutations. It shows two examples: one for all mutations and another for mutations with a specific prefix.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/reference/useIsMutating.md#2025-04-19_snippet_0

LANGUAGE: tsx
CODE:
```
import { useIsMutating } from '@tanstack/react-query'
// How many mutations are fetching?
const isMutating = useIsMutating()
// How many mutations matching the posts prefix are fetching?
const isMutatingPosts = useIsMutating({ mutationKey: ['posts'] })
```

----------------------------------------

TITLE: Using skipToken to Conditionally Skip Queries in Vue Query
DESCRIPTION: This snippet demonstrates the use of 'skipToken' to conditionally skip a query when the filter is empty or undefined. It computes the queryFn based on the filter value, providing an alternative way to disable queries.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/disabling-queries.md#2025-04-19_snippet_2

LANGUAGE: vue
CODE:
```
<script setup>
import { useQuery, skipToken } from '@tanstack/vue-query'

const filter = ref('')
const queryFn = computed(() =>
  !!filter.value ? () => fetchTodos(filter) : skipToken,
)
const { data } = useQuery({
  queryKey: ['todos', filter],
  // ‚¨áÔ∏è disabled as long as the filter is undefined or empty
  queryFn: queryFn,
})
</script>

<template>
  <span v-if="data">Filter was set and data is here!</span>
</template>
```

----------------------------------------

TITLE: Controlling Data Freshness with initialDataUpdatedAt in TanStack Query
DESCRIPTION: Shows how to use both staleTime and initialDataUpdatedAt to precisely control when the provided initial data is considered stale. This allows effective management of cached data with timestamps.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/initial-query-data.md#2025-04-19_snippet_3

LANGUAGE: typescript
CODE:
```
// Show initialTodos immediately, but won't refetch until
// another interaction event is encountered after 1000 ms
result = injectQuery(() => ({
  queryKey: ['todos'],
  queryFn: () => fetch('/todos'),
  initialData: initialTodos,
  staleTime: 60 * 1000, // 1 minute
  // This could be 10 seconds ago or 10 minutes ago
  initialDataUpdatedAt: initialTodosUpdatedTimestamp, // eg. 1608412420052
}))
```

----------------------------------------

TITLE: Basic Todo Mutation with Query Invalidation in Angular
DESCRIPTION: Demonstrates setting up a basic mutation for adding a todo item with proper query invalidation. The mutation function waits for the query invalidation to complete before resolving.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/optimistic-updates.md#2025-04-19_snippet_0

LANGUAGE: typescript
CODE:
```
addTodo = injectMutation(() => ({
  mutationFn: (newTodo: string) => axios.post('/api/data', { text: newTodo }),
  // make sure to _return_ the Promise from the query invalidation
  // so that the mutation stays in `pending` state until the refetch is finished
  onSettled: async () => {
    return await queryClient.invalidateQueries({ queryKey: ['todos'] })
  },
}))
```

----------------------------------------

TITLE: Handling Error States in Optimistic UI Updates with React Query
DESCRIPTION: Shows how to display an error state and retry button for failed optimistic updates.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/optimistic-updates.md#2025-04-19_snippet_2

LANGUAGE: tsx
CODE:
```
{
  isError && (
    <li style={{ color: 'red' }}>
      {variables}
      <button onClick={() => mutate(variables)}>Retry</button>
    </li>
  )
}
```

----------------------------------------

TITLE: Suspense Integration with useQuery
DESCRIPTION: Example showing how to use useQuery with SolidJS Suspense and ErrorBoundary components for declarative loading and error states.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/solid/reference/useQuery.md#2025-04-19_snippet_3

LANGUAGE: tsx
CODE:
```
import { useQuery } from '@tanstack/solid-query'

function App() {
  const todos = useQuery(() => ({
    queryKey: 'todos',
    queryFn: async () => {
      const response = await fetch('/api/todos')
      if (!response.ok) {
        throw new Error('Failed to fetch todos')
      }
      return response.json()
    },
    throwOnError: true,
  }))

  return (
    <ErrorBoundary fallback={<div>Error: {todos.error.message}</div>}>
      <Suspense fallback={<div>Loading...</div>}>
        <div>
          <div>Todos:</div>
          <ul>
            <For each={todos.data}>{(todo) => <li>{todo.title}</li>}</For>
          </ul>
        </div>
      </Suspense>
    </ErrorBoundary>
  )
}
```

----------------------------------------

TITLE: Setting Default Options for Specific Queries in React Query
DESCRIPTION: This example demonstrates how to use the QueryClient.setQueryDefaults method to set default options for specific queries identified by their query key.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-react-query-3.md#2025-04-19_snippet_16

LANGUAGE: tsx
CODE:
```
queryClient.setQueryDefaults(['posts'], { queryFn: fetchPosts })

function Component() {
  const { data } = useQuery(['posts'])
}
```

----------------------------------------

TITLE: Setting Fixed Retry Delay for Individual Query in TanStack Query
DESCRIPTION: This snippet demonstrates how to set a fixed retry delay for an individual query using the useQuery hook. It sets a constant delay of 1000ms between retry attempts.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/query-retries.md#2025-04-19_snippet_2

LANGUAGE: tsx
CODE:
```
const result = useQuery({
  queryKey: ['todos'],
  queryFn: fetchTodoList,
  retryDelay: 1000, // Will always wait 1000ms to retry, regardless of how many retries
})
```

----------------------------------------

TITLE: Query Disabling Using skipToken
DESCRIPTION: Demonstrates using the skipToken utility to disable queries instead of the enabled option. The query will be disabled when the filter is empty.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/disabling-queries.md#2025-04-19_snippet_2

LANGUAGE: angular-ts
CODE:
```
import { skipToken, injectQuery } from '@tanstack/query-angular'

@Component({
  selector: 'todos',
  template: `
    <div>
      // üöÄ applying the filter will enable and execute the query
      <filters-form onApply="filter.set" />
      <todos-table data="query.data()" />
    </div>
  `,
})
export class TodosComponent {
  filter = signal('')

  todosQuery = injectQuery(() => ({
    queryKey: ['todos', this.filter()],
    queryFn: this.filter() ? () => fetchTodos(this.filter()) : skipToken,
  }))
}
```

----------------------------------------

TITLE: Using Function-Based Placeholder Data with TanStack Query in Angular
DESCRIPTION: This snippet shows how to use a function for the placeholderData property that can access previous query data and the previous query. The function returns the previous data, enabling a smooth transition between queries when parameters change.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/placeholder-query-data.md#2025-04-19_snippet_1

LANGUAGE: typescript
CODE:
```
class TodosComponent {
  result = injectQuery(() => ({
    queryKey: ['todos', id()],
    queryFn: () => fetch(`/todos/${id}`),
    placeholderData: (previousData, previousQuery) => previousData,
  }))
}
```

----------------------------------------

TITLE: Implementing Mutation Scopes in React Query
DESCRIPTION: This snippet demonstrates how to use mutation scopes in React Query. Scopes allow mutations with the same ID to run serially, preventing parallel execution and ensuring ordered processing.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/mutations.md#2025-04-19_snippet_11

LANGUAGE: tsx
CODE:
```
const mutation = useMutation({
  mutationFn: addTodo,
  scope: {
    id: 'todo',
  },
})
```

----------------------------------------

TITLE: Updating Function Signatures in TanStack Query v5
DESCRIPTION: This snippet demonstrates the changes in function signatures for various TanStack Query methods, moving from multiple parameters to a single object parameter.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-v5.md#2025-04-19_snippet_0

LANGUAGE: tsx
CODE:
```
useQuery(key, fn, options) // [!code --]
useQuery({ queryKey, queryFn, ...options }) // [!code ++]
useInfiniteQuery(key, fn, options) // [!code --]
useInfiniteQuery({ queryKey, queryFn, ...options }) // [!code ++]
useMutation(fn, options) // [!code --]
useMutation({ mutationFn, ...options }) // [!code ++]
useIsFetching(key, filters) // [!code --]
useIsFetching({ queryKey, ...filters }) // [!code ++]
useIsMutating(key, filters) // [!code --]
useIsMutating({ mutationKey, ...filters }) // [!code ++]
```

----------------------------------------

TITLE: Custom Error Handling in onSettled for Angular Mutations
DESCRIPTION: Demonstrates using the onSettled callback with error handling in an Angular mutation. This shows how to perform custom actions when a mutation settles, with access to error information.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/optimistic-updates.md#2025-04-19_snippet_6

LANGUAGE: typescript
CODE:
```
injectMutation({
  mutationFn: updateTodo,
  // ...
  onSettled: (newTodo, error, variables, context) => {
    if (error) {
      // do something
    }
  },
})
```

----------------------------------------

TITLE: Implementing a Feed Component with Lazy-Loaded GraphFeedItem in React
DESCRIPTION: This code demonstrates a Feed component that uses React Query to fetch data and conditionally renders either a lazy-loaded GraphFeedItem or a StandardFeedItem based on the feed item type. It illustrates how code splitting can introduce request waterfalls.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/request-waterfalls.md#2025-04-19_snippet_5

LANGUAGE: tsx
CODE:
```
const GraphFeedItem = React.lazy(() => import('./GraphFeedItem'))

function Feed() {
  const { data, isPending } = useQuery({
    queryKey: ['feed'],
    queryFn: getFeed,
  })

  if (isPending) {
    return 'Loading feed...'
  }

  return (
    <>
      {data.map((feedItem) => {
        if (feedItem.type === 'GRAPH') {
          return <GraphFeedItem key={feedItem.id} feedItem={feedItem} />
        }

        return <StandardFeedItem key={feedItem.id} feedItem={feedItem} />
      })}
    </>
  )
}

// GraphFeedItem.tsx
function GraphFeedItem({ feedItem }) {
  const { data, isPending } = useQuery({
    queryKey: ['graph', feedItem.id],
    queryFn: getGraphDataById,
  })

  ...
}
```

----------------------------------------

TITLE: Initializing QueryClient Provider with Server Components
DESCRIPTION: Sets up the QueryClient and Provider components with special handling for server/client environments and proper React suspense support.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/advanced-ssr.md#2025-04-19_snippet_0

LANGUAGE: tsx
CODE:
```
'use client'

import {
  isServer,
  QueryClient,
  QueryClientProvider,
} from '@tanstack/react-query'

function makeQueryClient() {
  return new QueryClient({
    defaultOptions: {
      queries: {
        staleTime: 60 * 1000,
      },
    },
  })
}

let browserQueryClient: QueryClient | undefined = undefined

function getQueryClient() {
  if (isServer) {
    return makeQueryClient()
  } else {
    if (!browserQueryClient) browserQueryClient = makeQueryClient()
    return browserQueryClient
  }
}

export default function Providers({ children }: { children: React.ReactNode }) {
  const queryClient = getQueryClient()

  return (
    <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
  )
}
```

----------------------------------------

TITLE: Configuring Vue Query for Vite SSR
DESCRIPTION: This snippet demonstrates how to set up Vue Query with Vite SSR, including the creation of a QueryClient, handling of server-side and client-side initialization, and hydration of query state.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/ssr.md#2025-04-19_snippet_4

LANGUAGE: javascript
CODE:
```
import App from './App.vue'
import viteSSR from 'vite-ssr/vue'
import {
  QueryClient,
  VueQueryPlugin,
  hydrate,
  dehydrate,
} from '@tanstack/vue-query'

export default viteSSR(App, { routes: [] }, ({ app, initialState }) => {
  // -- This is Vite SSR main hook, which is called once per request

  // Create a fresh VueQuery client
  const queryClient = new QueryClient()

  // Sync initialState with the client state
  if (import.meta.env.SSR) {
    // Indicate how to access and serialize VueQuery state during SSR
    initialState.vueQueryState = { toJSON: () => dehydrate(queryClient) }
  } else {
    // Reuse the existing state in the browser
    hydrate(queryClient, initialState.vueQueryState)
  }

  // Mount and provide the client to the app components
  app.use(VueQueryPlugin, { queryClient })
})
```

----------------------------------------

TITLE: Prefetching Queries in Nuxt 3 Components
DESCRIPTION: This snippet demonstrates how to prefetch queries in Nuxt 3 components using the onServerPrefetch hook. It shows the usage of useQuery and suspense for server-side data fetching.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/ssr.md#2025-04-19_snippet_1

LANGUAGE: typescript
CODE:
```
export default defineComponent({
  setup() {
    const { data, suspense } = useQuery({
      queryKey: ['test'],
      queryFn: fetcher,
    })

    onServerPrefetch(async () => {
      await suspense()
    })

    return { data }
  },
})
```

----------------------------------------

TITLE: Setting Default Options with setDefaultOptions in TanStack Query
DESCRIPTION: The setDefaultOptions method dynamically sets default options for the queryClient. Previously defined default options will be overwritten.
SOURCE: https://github.com/tanstack/query/blob/main/docs/reference/QueryClient.md#2025-04-19_snippet_22

LANGUAGE: tsx
CODE:
```
queryClient.setDefaultOptions({
  queries: {
    staleTime: Infinity,
  },
})
```

----------------------------------------

TITLE: Clearing QueryCache
DESCRIPTION: Demonstrates how to clear the entire query cache and reset it to an empty state.
SOURCE: https://github.com/tanstack/query/blob/main/docs/reference/QueryCache.md#2025-04-19_snippet_4

LANGUAGE: tsx
CODE:
```
queryCache.clear()
```

----------------------------------------

TITLE: Lazy Initial Data with Function in TanStack Query
DESCRIPTION: Demonstrates using a function for initialData to avoid expensive computations unless necessary. The function is only executed when the query needs the initial data, improving performance for expensive operations.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/initial-query-data.md#2025-04-19_snippet_4

LANGUAGE: typescript
CODE:
```
result = injectQuery(() => ({
  queryKey: ['todos'],
  queryFn: () => fetch('/todos'),
  initialData: () => getExpensiveTodos(),
}))
```

----------------------------------------

TITLE: Retrieving Data for Specific Mutations by MutationKey in React Query
DESCRIPTION: This example shows how to use useMutationState to get data for specific mutations using the mutationKey. It defines a mutation using useMutation and then uses useMutationState to access the data of mutations with the same key.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/reference/useMutationState.md#2025-04-19_snippet_1

LANGUAGE: tsx
CODE:
```
import { useMutation, useMutationState } from '@tanstack/react-query'

const mutationKey = ['posts']

// Some mutation that we want to get the state for
const mutation = useMutation({
  mutationKey,
  mutationFn: (newPost) => {
    return axios.post('/posts', newPost)
  },
})

const data = useMutationState({
  // this mutation key needs to match the mutation key of the given mutation (see above)
  filters: { mutationKey },
  select: (mutation) => mutation.state.data,
})
```

----------------------------------------

TITLE: Updating Query Data with Mutation Response in React Query
DESCRIPTION: This snippet demonstrates how to use the onSuccess callback in a mutation to update the query cache with the response data. It shows updating a todo item's title and automatically reflecting the change in the UI.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/updates-from-mutation-responses.md#2025-04-19_snippet_0

LANGUAGE: javascript
CODE:
```
const queryClient = useQueryClient()

const mutation = useMutation(
  (newTodo) => axios.post('/todos', newTodo),
  {
    onSuccess: (data) => {
      // Query invalidation
      queryClient.invalidateQueries('todos')

      // Instant update
      queryClient.setQueryData('todos', (oldData) => {
        return {
          ...oldData,
          todos: [...oldData.todos, data.todo],
        }
      })
    },
  }
)
```

----------------------------------------

TITLE: Using Query Status in Vue Template with TanStack Query
DESCRIPTION: This snippet illustrates an alternative approach to handling query states in a Vue component using the status property from the useQuery hook. It shows how to conditionally render content based on the query status (pending, error, success) and display the fetched data.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/queries.md#2025-04-19_snippet_2

LANGUAGE: vue
CODE:
```
<script setup>
import { useQuery } from '@tanstack/vue-query'

const { status, data, error } = useQuery({
  queryKey: ['todos'],
  queryFn: fetchTodoList,
})
</script>

<template>
  <span v-if="status === 'pending'">Loading...</span>
  <span v-else-if="status === 'error'">Error: {{ error.message }}</span>
  <!-- also status === 'success', but "else" logic works, too -->
  <ul v-else-if="data">
    <li v-for="todo in data" :key="todo.id">{{ todo.title }}</li>
  </ul>
</template>
```

----------------------------------------

TITLE: Vue Component Props Example
DESCRIPTION: Example showing how to handle query reactivity with component props.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/reactivity.md#2025-04-19_snippet_4

LANGUAGE: vue
CODE:
```
<script setup lang="ts">
const props = defineProps<{
  userId: string
}>()
</script>
```

----------------------------------------

TITLE: Creating and Using QueriesObserver in TanStack Query (TSX)
DESCRIPTION: This code snippet demonstrates how to create a QueriesObserver instance, initialize it with multiple queries, and subscribe to the results. The observer is created with two queries, each fetching a post with different IDs. The subscribe method is used to log the results and then unsubscribe.
SOURCE: https://github.com/tanstack/query/blob/main/docs/reference/QueriesObserver.md#2025-04-19_snippet_0

LANGUAGE: tsx
CODE:
```
const observer = new QueriesObserver(queryClient, [
  { queryKey: ['post', 1], queryFn: fetchPost },
  { queryKey: ['post', 2], queryFn: fetchPost },
])

const unsubscribe = observer.subscribe((result) => {
  console.log(result)
  unsubscribe()
})
```

----------------------------------------

TITLE: Next.js InitialData Implementation
DESCRIPTION: Example showing how to use initialData with getServerSideProps in Next.js for simple SSR data passing.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/ssr.md#2025-04-19_snippet_2

LANGUAGE: tsx
CODE:
```
export async function getServerSideProps() {
  const posts = await getPosts()
  return { props: { posts } }
}

function Posts(props) {
  const { data } = useQuery({
    queryKey: ['posts'],
    queryFn: getPosts,
    initialData: props.posts,
  })

  // ...
}
```

----------------------------------------

TITLE: Configuring Default Query Options in Angular Query
DESCRIPTION: This snippet demonstrates how to set default options for all queries in an Angular application using Angular Query. It shows how to override the default staleTime and refetchOnWindowFocus settings.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/important-defaults.md#2025-04-19_snippet_0

LANGUAGE: typescript
CODE:
```
import { QueryClient } from '@tanstack/angular-query'

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 1000 * 60 * 5, // 5 minutes
      refetchOnWindowFocus: false,
    },
  },
})
```

----------------------------------------

TITLE: Basic Dependent Query Implementation in TanStack Query
DESCRIPTION: Example showing how to implement a basic dependent query where projects fetch depends on user data. The second query will not execute until the user ID is available from the first query.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/dependent-queries.md#2025-04-19_snippet_0

LANGUAGE: javascript
CODE:
```
// Get the user
const { data: user } = useQuery({
  queryKey: ['user', email],
  queryFn: () => getUserByEmail(email.value),
})

const userId = computed(() => user.value?.id)
const enabled = computed(() => !!user.value?.id)

// Then get the user's projects
const { isIdle, data: projects } = useQuery({
  queryKey: ['projects', userId],
  queryFn: () => getProjectsByUser(userId.value),
  enabled, // The query will not execute until `enabled == true`
})
```

----------------------------------------

TITLE: Implementing Server-Side Page Component with Query Prefetching
DESCRIPTION: Next.js page component that sets up query prefetching without awaiting the results, using HydrationBoundary for server-side rendering.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/advanced-ssr.md#2025-04-19_snippet_8

LANGUAGE: tsx
CODE:
```
import { dehydrate, HydrationBoundary } from '@tanstack/react-query'
import { getQueryClient } from './get-query-client'
import Posts from './posts'

export default function PostsPage() {
  const queryClient = getQueryClient()

  queryClient.prefetchQuery({
    queryKey: ['posts'],
    queryFn: getPosts,
  })

  return (
    <HydrationBoundary state={dehydrate(queryClient)}>
      <Posts />
    </HydrationBoundary>
  )
}
```

----------------------------------------

TITLE: Conditional Initial Data with Time-Based Cache in TanStack Query
DESCRIPTION: Shows an advanced pattern for conditionally providing initial data based on the age of existing query data. This ensures data is only shared between queries when it's sufficiently fresh, falling back to fetching otherwise.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/initial-query-data.md#2025-04-19_snippet_7

LANGUAGE: typescript
CODE:
```
result = injectQuery(() => ({
  queryKey: ['todo', this.todoId()],
  queryFn: () => fetch(`/todos/${this.todoId()}`),
  initialData: () => {
    // Get the query state
    const state = queryClient.getQueryState(['todos'])

    // If the query exists and has data that is no older than 10 seconds...
    if (state && Date.now() - state.dataUpdatedAt <= 10 * 1000) {
      // return the individual todo
      return state.data.find((d) => d.id === this.todoId())
    }

    // Otherwise, return undefined and let it fetch from a hard loading state!
  },
}))
```

----------------------------------------

TITLE: Using Query Options with Data Transformation in Angular
DESCRIPTION: This snippet shows how to use the select option to transform query results while maintaining type inference. It demonstrates combining reusable query options from a groupOptions function with a select transformer to extract only the title from the returned data.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/query-options.md#2025-04-19_snippet_1

LANGUAGE: typescript
CODE:
```
// Type inference still works, so query.data will be the return type of select instead of queryFn
queries = inject(QueriesService)

query = injectQuery(() => ({
  ...groupOptions(1),
  select: (data) => data.title,
}))
```

----------------------------------------

TITLE: Comparing Client-Side and Server-Side Rendering Request Waterfalls
DESCRIPTION: This snippet illustrates the difference in request waterfalls between client-side and server-side rendering for a nested component structure. It shows how server-side rendering can reduce the number of sequential requests.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/ssr.md#2025-04-19_snippet_9

LANGUAGE: markdown
CODE:
```
```
1. |> Markup (without content)
2.   |> JS for <Feed>
3.     |> getFeed()
4.       |> JS for <GraphFeedItem>
5.         |> getGraphDataById()
```

The nice thing about server rendering is that we can turn the above into:

```
1. |> Markup (with content AND initial data)
2.   |> JS for <Feed>
2.   |> JS for <GraphFeedItem>
```
```

----------------------------------------

TITLE: Mutation Promise Handling
DESCRIPTION: Demonstrates using mutateAsync for promise-based mutation execution with proper error handling.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/mutations.md#2025-04-19_snippet_7

LANGUAGE: tsx
CODE:
```
const mutation = useMutation({ mutationFn: addTodo })

try {
  const todo = await mutation.mutateAsync(todo)
  console.log(todo)
} catch (error) {
  console.error(error)
} finally {
  console.log('done')
}
```

----------------------------------------

TITLE: Handling Query States in Angular Component Template
DESCRIPTION: Illustrates how to handle different query states (pending, error, success) in an Angular component template. It uses structural directives to conditionally render content based on the query state.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/queries.md#2025-04-19_snippet_2

LANGUAGE: angular-ts
CODE:
```
@Component({
  selector: 'todos',
  standalone: true,
  template: `
    @if (todos.isPending()) {
      <span>Loading...</span>
    } @else if (todos.isError()) {
      <span>Error: {{ todos.error()?.message }}</span>
    } @else {
      <!-- We can assume by this point that status === 'success' -->
      @for (todo of todos.data(); track todo.id) {
        <li>{{ todo.title }}</li>
      } @empty {
        <li>No todos found</li>
      }
    }
  `,
})
export class PostsComponent {
  todos = injectQuery(() => ({
    queryKey: ['todos'],
    queryFn: fetchTodoList,
  }))
}
```

----------------------------------------

TITLE: Using Arrays for Query Keys in TanStack Query (TypeScript)
DESCRIPTION: This snippet shows how to use arrays for query keys, demonstrating that the order of elements matters. It also shows how to handle undefined values in the query key array.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/query-keys.md#2025-04-19_snippet_3

LANGUAGE: typescript
CODE:
```
injectQuery(() => ({ queryKey: ['todos', status, page], ... }))
injectQuery(() => ({ queryKey: ['todos', page, status], ...}))
injectQuery(() => ({ queryKey: ['todos', undefined, page, status], ...}))
```

----------------------------------------

TITLE: Memoizing Placeholder Data in TanStack Query
DESCRIPTION: Shows how to memoize placeholder data generation to optimize performance when the process is intensive. This approach prevents unnecessary recalculations on every render.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/placeholder-query-data.md#2025-04-19_snippet_1

LANGUAGE: tsx
CODE:
```
function Todos() {
  const placeholderData = useMemo(() => generateFakeTodos(), [])
  const result = useQuery({
    queryKey: ['todos'],
    queryFn: () => fetch('/todos'),
    placeholderData,
  })
}
```

----------------------------------------

TITLE: Remix Loader InitialData Implementation
DESCRIPTION: Shows how to implement initialData pattern using Remix loader function for server-side data fetching.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/ssr.md#2025-04-19_snippet_3

LANGUAGE: tsx
CODE:
```
export async function loader() {
  const posts = await getPosts()
  return json({ posts })
}

function Posts() {
  const { posts } = useLoaderData<typeof loader>()

  const { data } = useQuery({
    queryKey: ['posts'],
    queryFn: getPosts,
    initialData: posts,
  })

  // ...
}
```

----------------------------------------

TITLE: Accessing Latest Mutation Data by MutationKey in React Query
DESCRIPTION: This snippet demonstrates how to access the latest mutation data using useMutationState. It filters mutations by mutationKey, selects the data from each mutation state, and then retrieves the last item from the resulting array to get the most recent mutation data.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/reference/useMutationState.md#2025-04-19_snippet_2

LANGUAGE: tsx
CODE:
```
import { useMutation, useMutationState } from '@tanstack/react-query'

const mutationKey = ['posts']

// Some mutation that we want to get the state for
const mutation = useMutation({
  mutationKey,
  mutationFn: (newPost) => {
    return axios.post('/posts', newPost)
  },
})

const data = useMutationState({
  // this mutation key needs to match the mutation key of the given mutation (see above)
  filters: { mutationKey },
  select: (mutation) => mutation.state.data,
})

// Latest mutation data
const latest = data[data.length - 1]
```

----------------------------------------

TITLE: Accessing Query Function Variables in TanStack Query (TSX)
DESCRIPTION: Demonstrates how to access query key variables in the query function. This allows for the extraction of query functions when needed.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/query-functions.md#2025-04-19_snippet_3

LANGUAGE: tsx
CODE:
```
function Todos({ status, page }) {
  const result = useQuery({
    queryKey: ['todos', { status, page }],
    queryFn: fetchTodoList,
  })
}

// Access the key, status and page variables in your query function!
function fetchTodoList({ queryKey }) {
  const [_key, { status, page }] = queryKey
  return new Promise()
}
```

----------------------------------------

TITLE: Predicate-Based Query Invalidation
DESCRIPTION: Shows advanced query invalidation using a predicate function to selectively invalidate queries based on custom logic, specifically targeting queries with version numbers.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/query-invalidation.md#2025-04-19_snippet_3

LANGUAGE: typescript
CODE:
```
queryClient.invalidateQueries({
  predicate: (query) =>
    query.queryKey[0] === 'todos' && query.queryKey[1]?.version >= 10,
})

// The query below will be invalidated
todoListQuery = injectQuery(() => ({
  queryKey: ['todos', { version: 20 }],
  queryFn: fetchTodoList,
}))

// The query below will be invalidated
todoListQuery = injectQuery(() => ({
  queryKey: ['todos', { version: 10 }],
  queryFn: fetchTodoList,
}))

// However, the following query below will NOT be invalidated
todoListQuery = injectQuery(() => ({
  queryKey: ['todos', { version: 5 }],
  queryFn: fetchTodoList,
}))
```

----------------------------------------

TITLE: Implementing Server Component Page with React Query
DESCRIPTION: Creates a Server Component page that prefetches data and sets up hydration boundary for React Query.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/advanced-ssr.md#2025-04-19_snippet_2

LANGUAGE: tsx
CODE:
```
import {
  dehydrate,
  HydrationBoundary,
  QueryClient,
} from '@tanstack/react-query'
import Posts from './posts'

export default async function PostsPage() {
  const queryClient = new QueryClient()

  await queryClient.prefetchQuery({
    queryKey: ['posts'],
    queryFn: getPosts,
  })

  return (
    <HydrationBoundary state={dehydrate(queryClient)}>
      <Posts />
    </HydrationBoundary>
  )
}
```

----------------------------------------

TITLE: Specific Key Query Invalidation
DESCRIPTION: Shows how to invalidate queries with specific variables by providing a more detailed query key. Demonstrates selective invalidation based on matching criteria.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/query-invalidation.md#2025-04-19_snippet_1

LANGUAGE: typescript
CODE:
```
queryClient.invalidateQueries({
  queryKey: ['todos', { type: 'done' }],
})

// The query below will be invalidated
todoListQuery = injectQuery(() => ({
  queryKey: ['todos', { type: 'done' }],
  queryFn: fetchTodoList,
}))

// However, the following query below will NOT be invalidated
todoListQuery = injectQuery(() => ({
  queryKey: ['todos'],
  queryFn: fetchTodoList,
}))
```

----------------------------------------

TITLE: Disabling Window Focus Refetching Globally in TanStack Query
DESCRIPTION: This snippet demonstrates how to disable window focus refetching globally by configuring the QueryClient with default options.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/window-focus-refetching.md#2025-04-19_snippet_0

LANGUAGE: tsx
CODE:
```
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      refetchOnWindowFocus: false, // default: true
    },
  },
})

function App() {
  return <QueryClientProvider client={queryClient}>...</QueryClientProvider>
}
```

----------------------------------------

TITLE: Importing useMutation from TanStack Solid Query
DESCRIPTION: This snippet shows how to import the useMutation hook from the @tanstack/solid-query package. It demonstrates the correct import statement for using mutations in a Solid.js application with TanStack Query.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/solid/reference/useMutation.md#2025-04-19_snippet_0

LANGUAGE: javascript
CODE:
```
import { useMutation } from '@tanstack/solid-query'
```

----------------------------------------

TITLE: Configuring Global Query Retry Settings in Vue Query Plugin
DESCRIPTION: This snippet demonstrates how to configure global retry settings for all queries using the VueQueryPlugin. It sets up a custom retryDelay function that implements an exponential backoff strategy, with a maximum delay of 30 seconds.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/query-retries.md#2025-04-19_snippet_1

LANGUAGE: ts
CODE:
```
import { VueQueryPlugin } from '@tanstack/vue-query'

const vueQueryPluginOptions = {
  queryClientConfig: {
    defaultOptions: {
      queries: {
        retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
      },
    },
  },
}
app.use(VueQueryPlugin, vueQueryPluginOptions)
```

----------------------------------------

TITLE: Internal Context Key Generation Example
DESCRIPTION: Demonstrates how the custom query client key is combined with the default key internally.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/custom-client.md#2025-04-19_snippet_5

LANGUAGE: tsx
CODE:
```
const vueQueryPluginOptions: VueQueryPluginOptions = {
  queryClientKey: 'Foo',
}
app.use(VueQueryPlugin, vueQueryPluginOptions) // -> VUE_QUERY_CLIENT:Foo
```

----------------------------------------

TITLE: Type Narrowing for Specific Error Types in React Query (TypeScript)
DESCRIPTION: Demonstrates how to use type narrowing to handle specific error types like AxiosError in React Query.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/typescript.md#2025-04-19_snippet_6

LANGUAGE: tsx
CODE:
```
import axios from 'axios'

const { error } = useQuery({ queryKey: ['groups'], queryFn: fetchGroups })
//      ^? const error: Error | null

if (axios.isAxiosError(error)) {
  error
  // ^? const error: AxiosError
}
```

----------------------------------------

TITLE: Using staleTime with Initial Data in TanStack Query
DESCRIPTION: Demonstrates how to combine initialData with staleTime to control when refetching occurs. This prevents immediate refetching by marking the initial data as fresh for a specified duration.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/initial-query-data.md#2025-04-19_snippet_2

LANGUAGE: typescript
CODE:
```
// Show initialTodos immediately, but won't refetch until
// another interaction event is encountered after 1000 ms
result = injectQuery(() => ({
  queryKey: ['todos'],
  queryFn: () => fetch('/todos'),
  initialData: initialTodos,
  staleTime: 1000,
}))
```

----------------------------------------

TITLE: Setting Query Data with QueryClient in TSX
DESCRIPTION: Examples of using queryClient.setQueryData to update cached query data synchronously, both with direct value updates and updater functions.
SOURCE: https://github.com/tanstack/query/blob/main/docs/reference/QueryClient.md#2025-04-19_snippet_11

LANGUAGE: tsx
CODE:
```
queryClient.setQueryData(queryKey, updater)
```

LANGUAGE: tsx
CODE:
```
setQueryData(queryKey, newData)
```

LANGUAGE: tsx
CODE:
```
setQueryData(queryKey, (oldData) => newData)
```

----------------------------------------

TITLE: Prefetching Queries in Nuxt 2 Components
DESCRIPTION: This snippet demonstrates how to prefetch queries in Nuxt 2 components using the onServerPrefetch hook. It shows how to use useQuery, handle server-side prefetching, and dehydrate the query state.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/ssr.md#2025-04-19_snippet_3

LANGUAGE: vue
CODE:
```
<template>
  <div>
    <button @click="refetch">Refetch</button>
    <p>{{ data }}</p>
  </div>
</template>

<script lang="ts">
import {
  defineComponent,
  onServerPrefetch,
  useContext,
} from '@nuxtjs/composition-api'
import { useQuery, useQueryClient, dehydrate } from '@tanstack/vue-query'

export default defineComponent({
  setup() {
    // Get QueryClient either from SSR context, or Vue context
    const { ssrContext } = useContext()
    // Make sure to provide `queryClient` as a second parameter to `useQuery` calls
    const queryClient =
      (ssrContext != null && ssrContext.VueQuery) || useQueryClient()

    // This will be prefetched and sent from the server
    const { data, refetch, suspense } = useQuery(
      {
        queryKey: ['todos'],
        queryFn: getTodos,
      },
      queryClient,
    )
    // This won't be prefetched, it will start fetching on client side
    const { data2 } = useQuery(
      {
        queryKey: 'todos2',
        queryFn: getTodos,
      },
      queryClient,
    )

    onServerPrefetch(async () => {
      await suspense()
      ssrContext.nuxt.vueQueryState = dehydrate(queryClient)
    })

    return {
      refetch,
      data,
    }
  },
})
</script>
```

----------------------------------------

TITLE: Implementing Dependent Queries with TanStack Query in Angular
DESCRIPTION: Demonstrates fetching user data first and then using the user's ID to fetch their projects. The second query is conditionally executed only when user data is available using the enabled option.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/dependent-queries.md#2025-04-19_snippet_0

LANGUAGE: typescript
CODE:
```
// Get the user
userQuery = injectQuery(() => ({
  queryKey: ['user', email],
  queryFn: getUserByEmail,
}))

// Then get the user's projects
projectsQuery = injectQuery(() => ({
  queryKey: ['projects', this.userQuery.data()?.id],
  queryFn: getProjectsByUser,
  // The query will not execute until the user id exists
  enabled: !!this.userQuery.data()?.id,
}))
```

----------------------------------------

TITLE: Initializing TanStack Query with Next.js App Setup
DESCRIPTION: Basic setup for TanStack Query in Next.js _app.tsx file, configuring QueryClient with default stale time for SSR optimization.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/ssr.md#2025-04-19_snippet_4

LANGUAGE: tsx
CODE:
```
// _app.tsx
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'

export default function MyApp({ Component, pageProps }) {
  const [queryClient] = React.useState(
    () =>
      new QueryClient({
        defaultOptions: {
          queries: {
            // With SSR, we usually want to set some default staleTime
            // above 0 to avoid refetching immediately on the client
            staleTime: 60 * 1000,
          },
        },
      }),
  )

  return (
    <QueryClientProvider client={queryClient}>
      <Component {...pageProps} />
    </QueryClientProvider>
  )
}
```

----------------------------------------

TITLE: Implementing Async Storage Persister with React Query
DESCRIPTION: Example of creating an async storage persister and using it with PersistQueryClientProvider in a React Native application. It demonstrates how to set up the QueryClient and create the persister using AsyncStorage.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/plugins/createAsyncStoragePersister.md#2025-04-19_snippet_1

LANGUAGE: tsx
CODE:
```
import AsyncStorage from '@react-native-async-storage/async-storage'
import { QueryClient } from '@tanstack/react-query'
import { PersistQueryClientProvider } from '@tanstack/react-query-persist-client'
import { createAsyncStoragePersister } from '@tanstack/query-async-storage-persister'

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      gcTime: 1000 * 60 * 60 * 24, // 24 hours
    },
  },
})

const asyncStoragePersister = createAsyncStoragePersister({
  storage: AsyncStorage,
})

const Root = () => (
  <PersistQueryClientProvider
    client={queryClient}
    persistOptions={{ persister: asyncStoragePersister }}
  >
    <App />
  </PersistQueryClientProvider>
)

export default Root
```

----------------------------------------

TITLE: Accessing QueryClient with useQueryClient Hook in TypeScript
DESCRIPTION: Demonstrates how to import and use the useQueryClient hook to access the current QueryClient instance. The hook optionally accepts a custom QueryClient parameter, otherwise uses the nearest context's QueryClient instance.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/reference/useQueryClient.md#2025-04-19_snippet_0

LANGUAGE: tsx
CODE:
```
import { useQueryClient } from '@tanstack/react-query'

const queryClient = useQueryClient(queryClient?: QueryClient)
```

----------------------------------------

TITLE: Initializing QueryClientProvider in Svelte
DESCRIPTION: This snippet demonstrates how to set up the QueryClientProvider near the root of a Svelte project. It creates a QueryClient instance and wraps a child component with the provider.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/overview.md#2025-04-19_snippet_0

LANGUAGE: svelte
CODE:
```
<script lang="ts">
  import { QueryClient, QueryClientProvider } from '@tanstack/svelte-query'
  import Example from './lib/Example.svelte'

  const queryClient = new QueryClient()
</script>

<QueryClientProvider client={queryClient}>
  <Example />
</QueryClientProvider>
```

----------------------------------------

TITLE: Configuring Retry Count for a Specific Query in Angular
DESCRIPTION: Demonstrates how to make a specific query retry a certain number of times before displaying an error. This example uses injectQuery to define a query with a retry limit of 10 attempts.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/query-retries.md#2025-04-19_snippet_0

LANGUAGE: ts
CODE:
```
import { injectQuery } from '@tanstack/angular-query-experimental'

// Make a specific query retry a certain number of times
const result = injectQuery(() => ({
  queryKey: ['todos', 1],
  queryFn: fetchTodoListPage,
  retry: 10, // Will retry failed requests 10 times before displaying an error
}))
```

----------------------------------------

TITLE: Mutation Retry Configuration
DESCRIPTION: Shows how to configure retry behavior for failed mutations using the retry option.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/mutations.md#2025-04-19_snippet_8

LANGUAGE: tsx
CODE:
```
const mutation = useMutation({
  mutationFn: addTodo,
  retry: 3,
})
```

----------------------------------------

TITLE: Resetting Queries in TSX
DESCRIPTION: Example of using queryClient.resetQueries to reset queries to their initial state.
SOURCE: https://github.com/tanstack/query/blob/main/docs/reference/QueryClient.md#2025-04-19_snippet_18

LANGUAGE: tsx
CODE:
```
queryClient.resetQueries({ queryKey, exact: true })
```

----------------------------------------

TITLE: Updating Query Defaults Order in TanStack Query
DESCRIPTION: Demonstrates the new order for setting query defaults, from most generic to least generic keys.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-v5.md#2025-04-19_snippet_14

LANGUAGE: typescript
CODE:
```
+ queryClient.setQueryDefaults(['todo'], {
+   retry: false,
+   staleTime: 60_000,
+ })
queryClient.setQueryDefaults(['todo', 'detail'], {
+   retry: true,
  retryDelay: 1_000,
  staleTime: 10_000,
})
- queryClient.setQueryDefaults(['todo'], {
-   retry: false,
-   staleTime: 60_000,
- })
```

----------------------------------------

TITLE: Type Narrowing in React Query Results (TypeScript)
DESCRIPTION: Shows how to use type narrowing with React Query's discriminated union types to ensure data is defined.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/typescript.md#2025-04-19_snippet_3

LANGUAGE: tsx
CODE:
```
const { data, isSuccess } = useQuery({
  queryKey: ['test'],
  queryFn: () => Promise.resolve(5),
})

if (isSuccess) {
  data
  //  ^? const data: number
}
```

----------------------------------------

TITLE: Type Transformation with Select Function
DESCRIPTION: Shows how to transform query result types using the select option in injectQuery. The data type is transformed from number to string using a select function.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/typescript.md#2025-04-19_snippet_1

LANGUAGE: angular-ts
CODE:
```
@Component({
  // ...
  template: `@let data = query.data();`,
  //               ^? data: string | undefined
})
class MyComponent {
  query = injectQuery(() => ({
    queryKey: ['test'],
    queryFn: () => Promise.resolve(5),
    select: (data) => data.toString(),
  }))
}
```

----------------------------------------

TITLE: Implementing Batch Calls Higher-Order Function
DESCRIPTION: Definition of batchCalls, a higher-order function that wraps callbacks for batch scheduling. All calls to the wrapped function are scheduled for the next batch execution.
SOURCE: https://github.com/tanstack/query/blob/main/docs/reference/notifyManager.md#2025-04-19_snippet_1

LANGUAGE: typescript
CODE:
```
type BatchCallsCallback<T extends Array<unknown>> = (...args: T) => void

function batchCalls<T extends Array<unknown>>(
  callback: BatchCallsCallback<T>,
): BatchCallsCallback<T>
```

----------------------------------------

TITLE: Hydrating Query Client State in React Query
DESCRIPTION: The hydrate function adds a previously dehydrated state into a query cache. It's used to restore query states, typically on the client-side after server-side rendering or retrieving from storage.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/reference/hydration.md#2025-04-19_snippet_2

LANGUAGE: tsx
CODE:
```
import { hydrate } from '@tanstack/react-query'

hydrate(queryClient, dehydratedState, options)
```

----------------------------------------

TITLE: Default Options for broadcastQueryClient in TypeScript
DESCRIPTION: This snippet shows the default options used by the broadcastQueryClient function when no custom options are provided. It sets the default broadcastChannel to 'tanstack-query'.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/plugins/broadcastQueryClient.md#2025-04-19_snippet_2

LANGUAGE: tsx
CODE:
```
{
  broadcastChannel = 'tanstack-query',
}
```

----------------------------------------

TITLE: Configuring TanStack Query Client in Angular Standalone App
DESCRIPTION: Shows how to provide TanStack Query client and HTTP client to a standalone Angular application using dependency injection providers.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/quick-start.md#2025-04-19_snippet_0

LANGUAGE: typescript
CODE:
```
import { provideHttpClient } from '@angular/common/http'
import {
  provideTanStackQuery,
  QueryClient,
} from '@tanstack/angular-query-experimental'

bootstrapApplication(AppComponent, {
  providers: [provideHttpClient(), provideTanStackQuery(new QueryClient())],
})
```

----------------------------------------

TITLE: Ensuring Immutability when Updating Query Data in TanStack Query
DESCRIPTION: This snippet illustrates the importance of immutability when updating query data using setQueryData. It shows an incorrect approach of directly mutating the data, followed by the correct approach of creating a new object with spread syntax to update the data immutably.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/updates-from-mutation-responses.md#2025-04-19_snippet_2

LANGUAGE: tsx
CODE:
```
queryClient.setQueryData(['posts', { id }], (oldData) => {
  if (oldData) {
    // ‚ùå do not try this
    oldData.title = 'my new post title'
  }
  return oldData
})

queryClient.setQueryData(
  ['posts', { id }],
  // ‚úÖ this is the way
  (oldData) =>
    oldData
      ? {
          ...oldData,
          title: 'my new post title',
        }
      : oldData,
)
```

----------------------------------------

TITLE: Using useIsFetching Hook in React Query
DESCRIPTION: Demonstrates how to use the useIsFetching hook to get the number of queries currently fetching. It shows examples of using the hook without filters and with a query key filter.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/reference/useIsFetching.md#2025-04-19_snippet_0

LANGUAGE: tsx
CODE:
```
import { useIsFetching } from '@tanstack/react-query'
// How many queries are fetching?
const isFetching = useIsFetching()
// How many queries matching the posts prefix are fetching?
const isFetchingPosts = useIsFetching({ queryKey: ['posts'] })
```

----------------------------------------

TITLE: Initializing Infinite Query in Angular Component
DESCRIPTION: This snippet demonstrates how to set up an infinite query in an Angular component using TanStack Query. It includes query configuration, pagination handling, and computed properties for UI state.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/infinite-queries.md#2025-04-19_snippet_0

LANGUAGE: angular-ts
CODE:
```
import { Component, computed, inject } from '@angular/core'
import { injectInfiniteQuery } from '@tanstack/angular-query-experimental'
import { lastValueFrom } from 'rxjs'
import { ProjectsService } from './projects-service'

@Component({
  selector: 'example',
  templateUrl: './example.component.html',
})
export class Example {
  projectsService = inject(ProjectsService)

  query = injectInfiniteQuery(() => ({
    queryKey: ['projects'],
    queryFn: async ({ pageParam }) => {
      return lastValueFrom(this.projectsService.getProjects(pageParam))
    },
    initialPageParam: 0,
    getPreviousPageParam: (firstPage) => firstPage.previousId ?? undefined,
    getNextPageParam: (lastPage) => lastPage.nextId ?? undefined,
    maxPages: 3,
  }))

  nextButtonDisabled = computed(
    () => !this.#hasNextPage() || this.#isFetchingNextPage(),
  )
  nextButtonText = computed(() =>
    this.#isFetchingNextPage()
      ? 'Loading more...'
      : this.#hasNextPage()
        ? 'Load newer'
        : 'Nothing more to load',
  )

  #hasNextPage = this.query.hasNextPage
  #isFetchingNextPage = this.query.isFetchingNextPage
}
```

----------------------------------------

TITLE: Fetching Infinite Query Data
DESCRIPTION: Example of fetching paginated data using fetchInfiniteQuery with access to pages array.
SOURCE: https://github.com/tanstack/query/blob/main/docs/reference/QueryClient.md#2025-04-19_snippet_3

LANGUAGE: tsx
CODE:
```
try {
  const data = await queryClient.fetchInfiniteQuery({ queryKey, queryFn })
  console.log(data.pages)
} catch (error) {
  console.log(error)
}
```

----------------------------------------

TITLE: Custom Hook with Network Request
DESCRIPTION: Example of a custom hook that makes an API request using React Query.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/testing.md#2025-04-19_snippet_4

LANGUAGE: tsx
CODE:
```
function useFetchData() {
  return useQuery({
    queryKey: ['fetchData'],
    queryFn: () => request('/api/data'),
  })
}
```

----------------------------------------

TITLE: Implementing Query Cancellation with graphql-request (pre-v4.0.0) in TanStack Query
DESCRIPTION: Shows how to use the AbortSignal with graphql-request versions prior to 4.0.0 in a TanStack Query queryFn. The signal is passed to the GraphQLClient constructor.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/query-cancellation.md#2025-04-19_snippet_5

LANGUAGE: tsx
CODE:
```
const query = useQuery({
  queryKey: ['todos'],
  queryFn: ({ signal }) => {
    const client = new GraphQLClient(endpoint, {
      signal,
    })
    return client.request(query, variables)
  },
})
```

----------------------------------------

TITLE: Conditional Fetching of Next Page in React
DESCRIPTION: This snippet shows how to conditionally fetch the next page of data in a list component, ensuring that a new fetch is not triggered while the previous one is still in progress.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/infinite-queries.md#2025-04-19_snippet_1

LANGUAGE: jsx
CODE:
```
<List onEndReached={() => !isFetchingNextPage && fetchNextPage()} />
```

----------------------------------------

TITLE: Keeping Only the First Page in Infinite Query Data
DESCRIPTION: This snippet demonstrates how to manually update the infinite query data to keep only the first page, discarding all subsequent pages.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/infinite-queries.md#2025-04-19_snippet_6

LANGUAGE: tsx
CODE:
```
queryClient.setQueryData(['projects'], (data) => ({
  pages: data.pages.slice(0, 1),
  pageParams: data.pageParams.slice(0, 1),
}))
```

----------------------------------------

TITLE: Basic Query Usage in Vue Component
DESCRIPTION: Example of using the useQuery hook within a Vue component's setup function. This demonstrates the basic pattern for fetching data with Vue Query.
SOURCE: https://github.com/tanstack/query/blob/main/packages/vue-query/README.md#2025-04-19_snippet_5

LANGUAGE: tsx
CODE:
```
import { defineComponent } from 'vue'
import { useQuery } from '@tanstack/vue-query'

export default defineComponent({
  name: 'MyComponent',
  setup() {
    const query = useQuery({ queryKey: ['todos'], queryFn: getTodos })

    return {
      query,
    }
  },
})
```

----------------------------------------

TITLE: Installing Vue Query via Yarn
DESCRIPTION: This code snippet shows how to add Vue Query to your project using Yarn package manager.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/installation.md#2025-04-19_snippet_2

LANGUAGE: bash
CODE:
```
yarn add @tanstack/vue-query
```

----------------------------------------

TITLE: Lazy Loading React Query Devtools in Production
DESCRIPTION: Example of how to lazy load React Query Devtools in a production environment, allowing them to be toggled on demand without including them in the initial bundle.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/devtools.md#2025-04-19_snippet_4

LANGUAGE: typescript
CODE:
```
import * as React from 'react'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { ReactQueryDevtools } from '@tanstack/react-query-devtools'
import { Example } from './Example'

const queryClient = new QueryClient()

const ReactQueryDevtoolsProduction = React.lazy(() =>
  import('@tanstack/react-query-devtools/build/modern/production.js').then(
    (d) => ({
      default: d.ReactQueryDevtools,
    }),
  ),
)

function App() {
  const [showDevtools, setShowDevtools] = React.useState(false)

  React.useEffect(() => {
    // @ts-expect-error
    window.toggleDevtools = () => setShowDevtools((old) => !old)
  }, [])

  return (
    <QueryClientProvider client={queryClient}>
      <Example />
      <ReactQueryDevtools initialIsOpen />
      {showDevtools && (
        <React.Suspense fallback={null}>
          <ReactQueryDevtoolsProduction />
        </React.Suspense>
      )}
    </QueryClientProvider>
  )
}

export default App
```

----------------------------------------

TITLE: React.use() with Query Promise
DESCRIPTION: Example of using React.use() with query promises for experimental prefetch functionality
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/suspense.md#2025-04-19_snippet_4

LANGUAGE: tsx
CODE:
```
import React from 'react'
import { useQuery } from '@tanstack/react-query'
import { fetchTodos, type Todo } from './api'

function TodoList({ query }: { query: UseQueryResult<Todo[]> }) {
  const data = React.use(query.promise)

  return (
    <ul>
      {data.map((todo) => (
        <li key={todo.id}>{todo.title}</li>
      ))}
    </ul>
  )
}

export function App() {
  const query = useQuery({ queryKey: ['todos'], queryFn: fetchTodos })

  return (
    <>
      <h1>Todos</h1>
      <React.Suspense fallback={<div>Loading...</div>}>
        <TodoList query={query} />
      </React.Suspense>
    </>
  )
}
```

----------------------------------------

TITLE: Initializing TanStack Query with Standalone Component App
DESCRIPTION: Example showing how to initialize TanStack Query in an Angular application using the standalone component architecture by providing the QueryClient to the application.
SOURCE: https://github.com/tanstack/query/blob/main/packages/angular-query-experimental/README.md#2025-04-19_snippet_4

LANGUAGE: typescript
CODE:
```
import { provideTanStackQuery } from '@tanstack/angular-query-experimental'
import { QueryClient } from '@tanstack/angular-query-experimental'

bootstrapApplication(AppComponent, {
  providers: [provideTanStackQuery(new QueryClient())],
})
```

----------------------------------------

TITLE: Client-Side Posts Component with Suspense Query
DESCRIPTION: Client component that uses suspense query to fetch posts data, working with server-side prefetched data.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/advanced-ssr.md#2025-04-19_snippet_9

LANGUAGE: tsx
CODE:
```
'use client'

export default function Posts() {
  const { data } = useSuspenseQuery({ queryKey: ['posts'], queryFn: getPosts })

  // ...
}
```

----------------------------------------

TITLE: Type Inference with HttpClient
DESCRIPTION: Demonstrates type inference when using Angular's HttpClient with TanStack Query. The query result is typed based on the generic type provided to HttpClient's get method.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/typescript.md#2025-04-19_snippet_2

LANGUAGE: angular-ts
CODE:
```
@Component({
  template: `@let data = query.data();`,
  //               ^? data: Group[] | undefined
})
class MyComponent {
  http = inject(HttpClient)

  query = injectQuery(() => ({
    queryKey: ['groups'],
    queryFn: () => lastValueFrom(this.http.get<Group[]>('/groups')),
  }))
}
```

----------------------------------------

TITLE: Configuring Global Window Focus Refetching in Angular Query
DESCRIPTION: This snippet shows how to configure the global default for window focus refetching in Angular Query. It sets up the QueryClient with default options to disable refetching on window focus.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/window-focus-refetching.md#2025-04-19_snippet_0

LANGUAGE: typescript
CODE:
```
export const appConfig: ApplicationConfig = {
  providers: [
    provideTanStackQuery(
      new QueryClient({
        defaultOptions: {
          queries: {
            refetchOnWindowFocus: false, // default: true
          },
        },
      }),
    ),
  ],
}
```

----------------------------------------

TITLE: Error Type Handling in Vue Query
DESCRIPTION: Demonstrates error type handling and narrowing using instanceof check. The error type starts as unknown and can be narrowed to Error.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/typescript.md#2025-04-19_snippet_4

LANGUAGE: tsx
CODE:
```
const { error } = useQuery({ queryKey: ['groups'], queryFn: fetchGroups })
//      ^? const error: Ref<unknown>

if (error.value instanceof Error) {
  error.value
  //     ^? const error: Error
}
```

----------------------------------------

TITLE: Implementing a Custom Hook with Query Keys in TanStack Query
DESCRIPTION: This snippet demonstrates how to create a custom hook 'useTodos' that utilizes TanStack Query's useQuery hook with a dynamic query key. The query key is an array containing 'todos' and the todoId, which allows for unique identification of different todo queries.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/query-keys.md#2025-04-19_snippet_0

LANGUAGE: javascript
CODE:
```
function useTodos(todoId) {
  const queryKey = ['todos', todoId]
  return useQuery({
    queryKey,
    queryFn: () => fetchTodoById(todoId.value),
  })
}
```

----------------------------------------

TITLE: Configuring Global Query Retry Settings in Angular
DESCRIPTION: Shows how to configure retry behavior for all queries using QueryClient. This example implements an exponential backoff strategy for retry delays, limiting the maximum delay to 30 seconds.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/query-retries.md#2025-04-19_snippet_1

LANGUAGE: ts
CODE:
```
// Configure for all queries
import {
  QueryCache,
  QueryClient,
  QueryClientProvider,
} from '@tanstack/angular-query-experimental'

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
    },
  },
})

bootstrapApplication(AppComponent, {
  providers: [provideTanStackQuery(queryClient)],
})
```

----------------------------------------

TITLE: Initializing MutationCache with Callbacks in TypeScript
DESCRIPTION: Creates a new MutationCache instance with error and success callback handlers. The callbacks will be triggered for all mutations in the cache.
SOURCE: https://github.com/tanstack/query/blob/main/docs/reference/MutationCache.md#2025-04-19_snippet_0

LANGUAGE: tsx
CODE:
```
import { MutationCache } from '@tanstack/react-query'

const mutationCache = new MutationCache({
  onError: (error) => {
    console.log(error)
  },
  onSuccess: (data) => {
    console.log(data)
  },
})
```

----------------------------------------

TITLE: Implementing Online Status Management in React Native with Expo
DESCRIPTION: This snippet shows an alternative implementation of online status management using Expo's Network module instead of NetInfo. It sets up an event listener to update the online status based on network connectivity.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/react-native.md#2025-04-19_snippet_1

LANGUAGE: tsx
CODE:
```
import { onlineManager } from '@tanstack/react-query'
import * as Network from 'expo-network'

onlineManager.setEventListener((setOnline) => {
  const eventSubscription = Network.addNetworkStateListener((state) => {
    setOnline(!!state.isConnected)
  })
  return eventSubscription.remove
})
```

----------------------------------------

TITLE: Manually Managing Focus State in TanStack Query
DESCRIPTION: This snippet demonstrates how to manually set the focus state using TanStack Query's focusManager.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/window-focus-refetching.md#2025-04-19_snippet_4

LANGUAGE: tsx
CODE:
```
import { focusManager } from '@tanstack/react-query'

// Override the default focus state
focusManager.setFocused(true)

// Fallback to the default focus check
focusManager.setFocused(undefined)
```

----------------------------------------

TITLE: Type-Safe Data Access with queryOptions
DESCRIPTION: Shows how queryOptions enables type-safe data access with queryClient methods like getQueryData. The return type is correctly inferred without needing explicit type parameters.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/typescript.md#2025-04-19_snippet_9

LANGUAGE: ts
CODE:
```
data = this.queryClient.getQueryData(groupOptions().queryKey)
// ^? data: Post | undefined
```

----------------------------------------

TITLE: Using useQueries Hook for Parallel Queries in React Query
DESCRIPTION: This snippet shows how to use the new useQueries hook to execute multiple queries in parallel, which is useful when the number of queries is variable.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-react-query-3.md#2025-04-19_snippet_13

LANGUAGE: tsx
CODE:
```
import { useQueries } from 'react-query'

function Overview() {
  const results = useQueries([
    { queryKey: ['post', 1], queryFn: fetchPost },
    { queryKey: ['post', 2], queryFn: fetchPost },
  ])
  return (
    <ul>
      {results.map(({ data }) => data && <li key={data.id}>{data.title})</li>)}
    </ul>
  )
}
```

----------------------------------------

TITLE: Default Error Typing
DESCRIPTION: Shows the default error typing in TanStack Query for Angular. By default, the error type is Error | null when not specified.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/typescript.md#2025-04-19_snippet_4

LANGUAGE: angular-ts
CODE:
```
@Component({
  // ...
  template: `@let error = query.error();`,
  //                ^? error: Error | null
})
class MyComponent {
  query = injectQuery(() => ({
    queryKey: ['groups'],
    queryFn: fetchGroups
  }))
}
```

----------------------------------------

TITLE: Basic Query Disabling in Angular Component
DESCRIPTION: Demonstrates a basic implementation of a disabled query using the enabled: false option. The query won't automatically execute but can be triggered manually using refetch().
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/disabling-queries.md#2025-04-19_snippet_0

LANGUAGE: angular-ts
CODE:
```
@Component({
  selector: 'todos',
  template: `<div>
    <button (click)="query.refetch()">Fetch Todos</button>

    @if (query.data()) {
      <ul>
        @for (todo of query.data(); track todo.id) {
          <li>{{ todo.title }}</li>
        }
      </ul>
    } @else {
      @if (query.isError()) {
        <span>Error: {{ query.error().message }}</span>
      } @else if (query.isLoading()) {
        <span>Loading...</span>
      } @else if (!query.isLoading() && !query.isError()) {
        <span>Not ready ...</span>
      }
    }

    <div>{{ query.isLoading() ? 'Fetching...' : '' }}</div>
  </div>`,
})
export class TodosComponent {
  query = injectQuery(() => ({
    queryKey: ['todos'],
    queryFn: fetchTodoList,
    enabled: false,
  }))
}
```

----------------------------------------

TITLE: Using Infinite Queries in React Query 3
DESCRIPTION: Shows implementation of bi-directional infinite queries with new naming conventions and structure.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-react-query-3.md#2025-04-19_snippet_4

LANGUAGE: tsx
CODE:
```
const { data, fetchNextPage, hasNextPage, isFetchingNextPage } = useInfiniteQuery(
  'projects',
  ({ pageParam = 0 }) => fetchProjects(pageParam),
  {
    getNextPageParam: (lastPage, pages) => lastPage.nextCursor,
  },
)
```

----------------------------------------

TITLE: Installing React Query via pnpm
DESCRIPTION: Command to install React Query using pnpm package manager.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/installation.md#2025-04-19_snippet_1

LANGUAGE: bash
CODE:
```
pnpm add @tanstack/react-query
```

----------------------------------------

TITLE: Initializing Vue Query Plugin
DESCRIPTION: This code snippet shows how to initialize Vue Query in a Vue application using the VueQueryPlugin.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/installation.md#2025-04-19_snippet_4

LANGUAGE: tsx
CODE:
```
import { VueQueryPlugin } from '@tanstack/vue-query'

app.use(VueQueryPlugin)
```

----------------------------------------

TITLE: Prefetching Query with Default QueryFn
DESCRIPTION: Demonstrates prefetching a query using the default queryFn from configuration.
SOURCE: https://github.com/tanstack/query/blob/main/docs/reference/QueryClient.md#2025-04-19_snippet_5

LANGUAGE: tsx
CODE:
```
await queryClient.prefetchQuery({ queryKey })
```

----------------------------------------

TITLE: Fetching Data with Solid Query
DESCRIPTION: This snippet shows how to use Solid Query to fetch data from an API, demonstrating its integration with SolidJS's Suspense and ErrorBoundary, as well as additional features like caching and error handling.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/solid/overview.md#2025-04-19_snippet_1

LANGUAGE: tsx
CODE:
```
import { ErrorBoundary, Suspense } from 'solid-js'
import {
  useQuery,
  QueryClient,
  QueryClientProvider,
} from '@tanstack/solid-query'

function App() {
  const repositoryQuery = useQuery(() => ({
    queryKey: ['TanStack Query'],
    queryFn: async () => {
      const result = await fetch('https://api.github.com/repos/TanStack/query')
      if (!result.ok) throw new Error('Failed to fetch data')
      return result.json()
    },
    staleTime: 1000 * 60 * 5, // 5 minutes
    throwOnError: true, // Throw an error if the query fails
  }))

  return (
    <div>
      <div>Static Content</div>
      {/* An error while fetching will be caught by the ErrorBoundary */}
      <ErrorBoundary fallback={<div>Something went wrong!</div>}>
        {/* Suspense will trigger a loading state while the data is being fetched */}
        <Suspense fallback={<div>Loading...</div>}>
          {/* 
            The `data` property on a query is a SolidJS resource  
            so it will work with Suspense and transitions out of the box! 
          */}
          <div>{repositoryQuery.data?.updated_at}</div>
        </Suspense>
      </ErrorBoundary>
    </div>
  )
}

const root = document.getElementById('root')
const client = new QueryClient()

render(
  () => (
    <QueryClientProvider client={client}>
      <App />
    </QueryClientProvider>
  ),
  root!,
)
```

----------------------------------------

TITLE: Subscribing to QueryCache Events
DESCRIPTION: Shows how to subscribe to query cache updates and handle cache events through a callback function. Returns an unsubscribe function.
SOURCE: https://github.com/tanstack/query/blob/main/docs/reference/QueryCache.md#2025-04-19_snippet_3

LANGUAGE: tsx
CODE:
```
const callback = (event) => {
  console.log(event.type, event.query)
}

const unsubscribe = queryCache.subscribe(callback)
```

----------------------------------------

TITLE: Basic Devtools Integration in Angular
DESCRIPTION: Shows how to enable TanStack Query devtools in an Angular application using provideTanStackQuery and withDevtools.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/devtools.md#2025-04-19_snippet_0

LANGUAGE: typescript
CODE:
```
import {
  QueryClient,
  provideTanStackQuery,
  withDevtools,
} from '@tanstack/angular-query-experimental'

export const appConfig: ApplicationConfig = {
  providers: [provideTanStackQuery(new QueryClient(), withDevtools())],
}
```

----------------------------------------

TITLE: Customizing Window Focus Event Listener in TanStack Query
DESCRIPTION: This snippet demonstrates how to set a custom event listener for window focus events using the focusManager.setEventListener function.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/window-focus-refetching.md#2025-04-19_snippet_2

LANGUAGE: tsx
CODE:
```
focusManager.setEventListener((handleFocus) => {
  // Listen to visibilitychange
  if (typeof window !== 'undefined' && window.addEventListener) {
    const visibilitychangeHandler = () => {
      handleFocus(document.visibilityState === 'visible')
    }
    window.addEventListener('visibilitychange', visibilitychangeHandler, false)
    return () => {
      // Be sure to unsubscribe if a new handler is set
      window.removeEventListener('visibilitychange', visibilitychangeHandler)
    }
  }
})
```

----------------------------------------

TITLE: Basic Type Inference in Vue Query
DESCRIPTION: Demonstrates basic type inference for query results using useQuery hook. The returned data is automatically typed as a Ref<number> | Ref<undefined>.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/typescript.md#2025-04-19_snippet_0

LANGUAGE: tsx
CODE:
```
const { data } = useQuery({
  //    ^? const data: Ref<number> | Ref<undefined>
  queryKey: ['test'],
  queryFn: () => Promise.resolve(5),
})
```

----------------------------------------

TITLE: Injecting Query in Angular Component
DESCRIPTION: Demonstrates how to use injectQuery to fetch a list of todos in an Angular component. The query key is set to ['todos'] and the queryFn is set to fetchTodoList.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/queries.md#2025-04-19_snippet_0

LANGUAGE: typescript
CODE:
```
import { injectQuery } from '@tanstack/angular-query-experimental'

export class TodosComponent {
  info = injectQuery(() => ({ queryKey: ['todos'], queryFn: fetchTodoList }))
}
```

----------------------------------------

TITLE: Creating Client Component with React Query Hooks
DESCRIPTION: Implements a Client Component that uses React Query hooks to access prefetched and client-side data.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/advanced-ssr.md#2025-04-19_snippet_3

LANGUAGE: tsx
CODE:
```
'use client'

export default function Posts() {
  const { data } = useQuery({
    queryKey: ['posts'],
    queryFn: () => getPosts(),
  })

  const { data: commentsData } = useQuery({
    queryKey: ['posts-comments'],
    queryFn: getComments,
  })

  // ...
}
```

----------------------------------------

TITLE: Using skipToken for Typesafe Query Disabling in TanStack Query (TSX)
DESCRIPTION: This snippet illustrates the use of 'skipToken' to disable a query in a type-safe manner. It's particularly useful for TypeScript users and provides an alternative to the 'enabled' option for conditional query execution.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/disabling-queries.md#2025-04-19_snippet_2

LANGUAGE: tsx
CODE:
```
import { skipToken, useQuery } from '@tanstack/react-query'

function Todos() {
  const [filter, setFilter] = React.useState<string | undefined>()

  const { data } = useQuery({
    queryKey: ['todos', filter],
    // ‚¨áÔ∏è disabled as long as the filter is undefined or empty
    queryFn: filter ? () => fetchTodos(filter) : skipToken,
  })

  return (
    <div>
      // üöÄ applying the filter will enable and execute the query
      <FiltersForm onApply={setFilter} />
      {data && <TodosTable data={data} />}
    </div>
  )
}
```

----------------------------------------

TITLE: Mocked Response Generator
DESCRIPTION: Helper function to generate mock responses for pagination testing.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/testing.md#2025-04-19_snippet_6

LANGUAGE: tsx
CODE:
```
function generateMockedResponse(page) {
  return {
    page: page,
    items: [...]
  }
}
```

----------------------------------------

TITLE: Non-Reactive Query Implementation in Svelte
DESCRIPTION: Example showing a non-reactive implementation of a query where refetchInterval won't update when the input value changes. This demonstrates the incorrect way of handling reactive query options.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/reactivity.md#2025-04-19_snippet_0

LANGUAGE: svelte
CODE:
```
<script lang="ts">
  import { createQuery } from '@tanstack/svelte-query'

  const endpoint = 'http://localhost:5173/api/data'

  let intervalMs = 1000

  const query = createQuery({
    queryKey: ['refetch'],
    queryFn: async () => await fetch(endpoint).then((r) => r.json()),
    refetchInterval: intervalMs,
  })
</script>

<input type="number" bind:value={intervalMs} />
```

----------------------------------------

TITLE: Remix Root QueryClient Setup
DESCRIPTION: Demonstrates QueryClient initialization in a Remix root.tsx file with proper staleTime configuration for SSR.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/ssr.md#2025-04-19_snippet_1

LANGUAGE: tsx
CODE:
```
// app/root.tsx
import { Outlet } from '@remix-run/react'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'

export default function MyApp() {
  const [queryClient] = React.useState(
    () =>
      new QueryClient({
        defaultOptions: {
          queries: {
            staleTime: 60 * 1000,
          },
        },
      }),
  )

  return (
    <QueryClientProvider client={queryClient}>
      <Outlet />
    </QueryClientProvider>
  )
}
```

----------------------------------------

TITLE: Basic Type Inference in Angular Query Component
DESCRIPTION: Demonstrates basic type inference in TanStack Query for Angular, where the data type is inferred from the queryFn return type. The query result data is typed as number | undefined.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/typescript.md#2025-04-19_snippet_0

LANGUAGE: angular-ts
CODE:
```
@Component({
  // ...
  template: `@let data = query.data();`,
  //               ^? data: number | undefined
})
class MyComponent {
  query = injectQuery(() => ({
    queryKey: ['test'],
    queryFn: () => Promise.resolve(5),
  }))
}
```

----------------------------------------

TITLE: Setting Up QueryClientProvider
DESCRIPTION: Implements the QueryClientProvider component to connect a QueryClient instance to a React application.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-react-query-3.md#2025-04-19_snippet_2

LANGUAGE: tsx
CODE:
```
import { QueryClient, QueryClientProvider } from 'react-query'

const queryClient = new QueryClient()

function App() {
  return <QueryClientProvider client={queryClient}>...</QueryClientProvider>
}
```

----------------------------------------

TITLE: Handling Non-Serializable Data in React Query Dehydration
DESCRIPTION: Example of how to handle non-JSON-serializable data when dehydrating query state. This is necessary when working with storage systems that require JSON serialization, such as browser Web Storage API.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/reference/hydration.md#2025-04-19_snippet_1

LANGUAGE: tsx
CODE:
```
// server
const state = dehydrate(client, { shouldDehydrateQuery: () => true }) // to also include Errors
const serializedState = mySerialize(state) // transform Error instances to objects

// client
const state = myDeserialize(serializedState) // transform objects back to Error instances
hydrate(client, state)
```

----------------------------------------

TITLE: Implementing Query-Specific Background Fetching Indicator in Vue
DESCRIPTION: This snippet demonstrates how to use the useQuery hook from @tanstack/vue-query to manage a query's state and display loading, error, and success states. It includes a background fetching indicator for the specific query.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/background-fetching-indicators.md#2025-04-19_snippet_0

LANGUAGE: vue
CODE:
```
<script setup>
import { useQuery } from '@tanstack/vue-query'

const { isPending, isFetching, isError, data, error } = useQuery({
  queryKey: ['todos'],
  queryFn: getTodos,
})
</script>

<template>
  <div v-if="isFetching">Refreshing...</div>
  <span v-if="isPending">Loading...</span>
  <span v-else-if="isError">Error: {{ error.message }}</span>
  <!-- We can assume by this point that `isSuccess === true` -->
  <ul v-else-if="data">
    <li v-for="todo in data" :key="todo.id">{{ todo.title }}</li>
  </ul>
</template>
```

----------------------------------------

TITLE: Traditional Global State Structure in TSX
DESCRIPTION: Example showing typical global state structure including both server and client state properties before using TanStack Query.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/does-this-replace-client-state.md#2025-04-19_snippet_0

LANGUAGE: tsx
CODE:
```
const globalState = {
  projects,
  teams,
  tasks,
  users,
  themeMode,
  sidebarStatus,
}
```

----------------------------------------

TITLE: Installing ESLint Plugin Query via pnpm
DESCRIPTION: Command to install ESLint Plugin Query as a dev dependency using pnpm package manager.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/installation.md#2025-04-19_snippet_7

LANGUAGE: bash
CODE:
```
pnpm add -D @tanstack/eslint-plugin-query
```

----------------------------------------

TITLE: StoragePersisterOptions Interface Definition
DESCRIPTION: TypeScript interface defining the options for the experimental_createPersister function, including storage, serialization methods, and filtering options.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/plugins/createPersister.md#2025-04-19_snippet_2

LANGUAGE: tsx
CODE:
```
export interface StoragePersisterOptions {
  /** The storage client used for setting and retrieving items from cache.
   * For SSR pass in `undefined`.
   */
  storage: AsyncStorage | Storage | undefined | null
  /**
   * How to serialize the data to storage.
   * @default `JSON.stringify`
   */
  serialize?: (persistedQuery: PersistedQuery) => string
  /**
   * How to deserialize the data from storage.
   * @default `JSON.parse`
   */
  deserialize?: (cachedString: string) => PersistedQuery
  /**
   * A unique string that can be used to forcefully invalidate existing caches,
   * if they do not share the same buster string
   */
  buster?: string
  /**
   * The max-allowed age of the cache in milliseconds.
   * If a persisted cache is found that is older than this
   * time, it will be discarded
   * @default 24 hours
   */
  maxAge?: number
  /**
   * Prefix to be used for storage key.
   * Storage key is a combination of prefix and query hash in a form of `prefix-queryHash`.
   */
  prefix?: string
  /**
   * Filters to narrow down which Queries should be persisted.
   */
  filters?: QueryFilters
}

interface AsyncStorage {
  getItem: (key: string) => Promise<string | undefined | null>
  setItem: (key: string, value: string) => Promise<unknown>
  removeItem: (key: string) => Promise<void>
}
```

----------------------------------------

TITLE: Configuring QueryClient in SvelteKit Layout Load Function
DESCRIPTION: Sets up the QueryClient instance in the layout load function for prefetching data approach.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/ssr.md#2025-04-19_snippet_3

LANGUAGE: typescript
CODE:
```
import { browser } from '$app/environment'
import { QueryClient } from '@tanstack/svelte-query'

export async function load() {
  const queryClient = new QueryClient({
    defaultOptions: {
      queries: {
        enabled: browser,
      },
    },
  })

  return { queryClient }
}
```

----------------------------------------

TITLE: Registering Global Meta Type in React Query (TypeScript)
DESCRIPTION: Demonstrates how to register a global Meta type for queries and mutations in React Query.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/typescript.md#2025-04-19_snippet_8

LANGUAGE: ts
CODE:
```
import '@tanstack/react-query'

interface MyMeta extends Record<string, unknown> {
  // Your meta type definition.
}

declare module '@tanstack/react-query' {
  interface Register {
    queryMeta: MyMeta
    mutationMeta: MyMeta
  }
}
```

----------------------------------------

TITLE: Reactive Options with useQuery
DESCRIPTION: Example demonstrating reactive query options that update based on signal changes. Shows how to implement filtering with dynamic queryKey and queryFn updates.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/solid/reference/useQuery.md#2025-04-19_snippet_2

LANGUAGE: tsx
CODE:
```
import { useQuery } from '@tanstack/solid-query'

function App() {
  const [filter, setFilter] = createSignal('all')

  const todos = useQuery(() => ({
    queryKey: ['todos', filter()],
    queryFn: async () => {
      const response = await fetch(`/api/todos?filter=${filter()}`)
      if (!response.ok) {
        throw new Error('Failed to fetch todos')
      }
      return response.json()
    },
  }))

  return (
    <div>
      <div>
        <button onClick={() => setFilter('all')}>All</button>
        <button onClick={() => setFilter('active')}>Active</button>
        <button onClick={() => setFilter('completed')}>Completed</button>
      </div>
      <Show when={todos.isError}>
        <div>Error: {todos.error.message}</div>
      </Show>
      <Show when={todos.isLoading}>
        <div>Loading...</div>
      </Show>
      <Show when={todos.isSuccess}>
        <div>
          <div>Todos:</div>
          <ul>
            <For each={todos.data}>{(todo) => <li>{todo.title}</li>}</For>
          </ul>
        </div>
      </Show>
    </div>
  )
}
```

----------------------------------------

TITLE: Defining CreateMutationResult Type Alias in TypeScript
DESCRIPTION: This type alias defines the structure of mutation results in the Angular experimental version of TanStack Query. It combines BaseMutationNarrowing with signal-mapped state properties, providing type safety for mutation operations with various generic parameters.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/type-aliases/createmutationresult.md#2025-04-19_snippet_0

LANGUAGE: typescript
CODE:
```
type CreateMutationResult<TData, TError, TVariables, TContext, TState>: BaseMutationNarrowing<TData, TError, TVariables, TContext> & MapToSignals<OmitKeyof<TState, keyof BaseMutationNarrowing, "safely">>
```

----------------------------------------

TITLE: Configuring Custom Event Listener in TanStack Query OnlineManager
DESCRIPTION: Demonstrates how to set up a custom event listener using NetInfo for React Native to manage online state detection. The example shows integration with @react-native-community/netinfo to monitor connection status.
SOURCE: https://github.com/tanstack/query/blob/main/docs/reference/onlineManager.md#2025-04-19_snippet_0

LANGUAGE: tsx
CODE:
```
import NetInfo from '@react-native-community/netinfo'
import { onlineManager } from '@tanstack/react-query'

onlineManager.setEventListener((setOnline) => {
  return NetInfo.addEventListener((state) => {
    setOnline(!!state.isConnected)
  })
})
```

----------------------------------------

TITLE: Configuring Query Options in TanStack Query using TypeScript
DESCRIPTION: Demonstrates how to use the queryOptions function to configure query settings. The function accepts a queryKey parameter and additional options that are compatible with useQuery. Includes support for experimental features like prefetchInRender.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/reference/queryOptions.md#2025-04-19_snippet_0

LANGUAGE: tsx
CODE:
```
queryOptions({
  queryKey,
  ...options,
})
```

----------------------------------------

TITLE: Using useSuspenseInfiniteQuery Hook in TanStack Query (TSX)
DESCRIPTION: This snippet demonstrates how to use the useSuspenseInfiniteQuery hook. It returns a result object with properties similar to useInfiniteQuery, but with some key differences in behavior and available options.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/reference/useSuspenseInfiniteQuery.md#2025-04-19_snippet_0

LANGUAGE: tsx
CODE:
```
const result = useSuspenseInfiniteQuery(options)
```

----------------------------------------

TITLE: Disabling Window Focus Refetching Per-Query in TanStack Query
DESCRIPTION: This example shows how to disable window focus refetching for a specific query using the useQuery hook.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/window-focus-refetching.md#2025-04-19_snippet_1

LANGUAGE: tsx
CODE:
```
useQuery({
  queryKey: ['todos'],
  queryFn: fetchTodos,
  refetchOnWindowFocus: false,
})
```

----------------------------------------

TITLE: Replacing React Query Hooks with Solid Query Equivalents
DESCRIPTION: This snippet shows the mapping of React Query hooks to their Solid Query counterparts. It demonstrates how to replace React-specific syntax with Solid.js syntax for various query operations.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/solid/guides/query-options.md#2025-04-19_snippet_0

LANGUAGE: javascript
CODE:
```
{
  '@tanstack/react-query': '@tanstack/solid-query',
  'useMutationState[(]': 'useMutationState(() => ',
  'useMutation[(]': 'useMutation(() => ',
  'useQuery[(]': 'useQuery(() => ',
  'useQueries[(]': 'useQueries(() => ',
  'useInfiniteQuery[(]': 'useInfiniteQuery(() => ',
}
```

----------------------------------------

TITLE: Using useIsMutating Hook in React with TanStack Query
DESCRIPTION: This snippet demonstrates how to use the useIsMutating hook from @tanstack/react-query to check the number of mutations in progress. It can be used without arguments to check all mutations or with a filter to check specific mutations.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/solid/reference/useIsMutating.md#2025-04-19_snippet_0

LANGUAGE: javascript
CODE:
```
import { useIsMutating } from '@tanstack/react-query'

// Check if any mutations are in progress
const isMutating = useIsMutating()

// Check if specific mutations are in progress
const isMutatingPosts = useIsMutating({ mutationKey: ['posts'] })
```

----------------------------------------

TITLE: Dynamic Query with Dependency Injection in Angular
DESCRIPTION: Advanced example showing how to implement a query that uses dynamic inputs and Angular's dependency injection. The query fetches a post based on a route parameter and uses an injected service for data fetching.
SOURCE: https://github.com/tanstack/query/blob/main/packages/angular-query-experimental/README.md#2025-04-19_snippet_7

LANGUAGE: typescript
CODE:
```
@Component({})
export class PostComponent {
  #postsService = inject(PostsService)
  postId = input.required({
    transform: numberAttribute,
  })

  postQuery = injectQuery(() => ({
    queryKey: ['post', this.postId()],
    queryFn: () => {
      return lastValueFrom(this.#postsService.postById$(this.postId()))
    },
  }))
}

@Injectable({
  providedIn: 'root',
})
export class PostsService {
  #http = inject(HttpClient)

  postById$ = (postId: number) =>
    this.#http.get<Post>(`https://jsonplaceholder.typicode.com/posts/${postId}`)
}

export interface Post {
  id: number
  title: string
  body: string
}
```

----------------------------------------

TITLE: Configuring Retry for Mutations in React Query
DESCRIPTION: This example demonstrates how to use the retry option to configure automatic retries for failed mutations in React Query.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-react-query-3.md#2025-04-19_snippet_14

LANGUAGE: tsx
CODE:
```
const mutation = useMutation({
  mutationFn: addTodo,
  retry: 3,
})
```

----------------------------------------

TITLE: Implementing Query Cancellation with Fetch API in TanStack Query
DESCRIPTION: Demonstrates how to use the browser's native fetch API with TanStack Query's AbortSignal. This example shows passing the signal to both a primary fetch request and to multiple subsequent requests in a Promise.all chain.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/query-cancellation.md#2025-04-19_snippet_1

LANGUAGE: typescript
CODE:
```
query = injectQuery(() => ({
  queryKey: ['todos'],
  queryFn: async ({ signal }) => {
    const todosResponse = await fetch('/todos', {
      // Pass the signal to one fetch
      signal,
    })
    const todos = await todosResponse.json()

    const todoDetails = todos.map(async ({ details }) => {
      const response = await fetch(details, {
        // Or pass it to several
        signal,
      })
      return response.json()
    })

    return Promise.all(todoDetails)
  },
}))
```

----------------------------------------

TITLE: Implementing Global Background Fetching Indicator in Vue
DESCRIPTION: This snippet shows how to use the useIsFetching hook from @tanstack/vue-query to create a global background fetching indicator. It monitors the fetching status of all queries in the application.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/background-fetching-indicators.md#2025-04-19_snippet_1

LANGUAGE: vue
CODE:
```
<script setup>
import { useIsFetching } from '@tanstack/vue-query'

const isFetching = useIsFetching()
</script>

<template>
  <div v-if="isFetching">Queries are fetching in the background...</div>
</template>
```

----------------------------------------

TITLE: Importing React Query via CDN
DESCRIPTION: HTML script tag to import React Query and its dependencies from ESM.sh CDN. This method is for use without a module bundler or package manager.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/installation.md#2025-04-19_snippet_4

LANGUAGE: html
CODE:
```
<script type="module">
  import React from 'https://esm.sh/react@18.2.0'
  import ReactDOM from 'https://esm.sh/react-dom@18.2.0'
  import { QueryClient } from 'https://esm.sh/@tanstack/react-query'
</script>
```

----------------------------------------

TITLE: Exact Match Query Invalidation
DESCRIPTION: Demonstrates using exact:true option to invalidate only queries that exactly match the provided query key, without affecting queries with additional parameters.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/query-invalidation.md#2025-04-19_snippet_2

LANGUAGE: typescript
CODE:
```
queryClient.invalidateQueries({
  queryKey: ['todos'],
  exact: true,
})

// The query below will be invalidated
todoListQuery = injectQuery(() => ({
  queryKey: ['todos'],
  queryFn: fetchTodoList,
}))

// However, the following query below will NOT be invalidated
const todoListQuery = injectQuery(() => ({
  queryKey: ['todos', { type: 'done' }],
  queryFn: fetchTodoList,
}))
```

----------------------------------------

TITLE: Dehydrating Query Client State in React Query
DESCRIPTION: The dehydrate function creates a frozen representation of a query cache that can be later hydrated. It's useful for server-side rendering or persisting query states. By default, it only includes successful queries.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/reference/hydration.md#2025-04-19_snippet_0

LANGUAGE: tsx
CODE:
```
import { dehydrate } from '@tanstack/react-query'

const dehydratedState = dehydrate(queryClient, {
  shouldDehydrateQuery,
  shouldDehydrateMutation,
})
```

----------------------------------------

TITLE: Defining CreateMutateFunction Type Alias in TypeScript
DESCRIPTION: This code snippet defines the CreateMutateFunction type alias, which is a function type that takes variable arguments and returns void. It is used for creating mutation functions in TanStack Query, with generic types for data, error, variables, and context.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/reference/type-aliases/createmutatefunction.md#2025-04-19_snippet_0

LANGUAGE: TypeScript
CODE:
```
type CreateMutateFunction<TData, TError, TVariables, TContext>: (...args) => void;
```

----------------------------------------

TITLE: Setting Fixed Retry Delay for a Specific Query in Angular
DESCRIPTION: Demonstrates how to override the retry delay with a fixed time value for a specific query. This sets a constant 1000ms delay between retry attempts regardless of how many retries have occurred.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/query-retries.md#2025-04-19_snippet_2

LANGUAGE: ts
CODE:
```
const result = injectQuery(() => ({
  queryKey: ['todos'],
  queryFn: fetchTodoList,
  retryDelay: 1000, // Will always wait 1000ms to retry, regardless of how many retries
}))
```

----------------------------------------

TITLE: Dynamic Devtools Loading with Keyboard Shortcut
DESCRIPTION: Advanced implementation showing how to dynamically load devtools based on a keyboard shortcut trigger using RxJS and signals.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/devtools.md#2025-04-19_snippet_4

LANGUAGE: typescript
CODE:
```
@Injectable({ providedIn: 'root' })
class DevtoolsOptionsManager {
  loadDevtools = toSignal(
    fromEvent<KeyboardEvent>(document, 'keydown').pipe(
      map(
        (event): boolean =>
          event.metaKey && event.ctrlKey && event.shiftKey && event.key === 'D',
      ),
      scan((acc, curr) => acc || curr, false),
    ),
    {
      initialValue: false,
    },
  )
}

export const appConfig: ApplicationConfig = {
  providers: [
    provideHttpClient(),
    provideTanStackQuery(
      new QueryClient(),
      withDevtools(() => ({
        initialIsOpen: true,
        loadDevtools: inject(DevtoolsOptionsManager).loadDevtools(),
      })),
    ),
  ],
}
```

----------------------------------------

TITLE: Using Static Placeholder Data with TanStack Query in Angular
DESCRIPTION: This snippet demonstrates how to provide static placeholder data for a TanStack Query in an Angular component. It uses the injectQuery function with a static 'placeholderData' property to display temporary data while the actual query is loading.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/placeholder-query-data.md#2025-04-19_snippet_0

LANGUAGE: typescript
CODE:
```
class TodosComponent {
  result = injectQuery(() => ({
    queryKey: ['todos'],
    queryFn: () => fetch('/todos'),
    placeholderData: placeholderTodos,
  }))
}
```

----------------------------------------

TITLE: Implementing Manual Query Cancellation in TanStack Query
DESCRIPTION: Demonstrates how to manually cancel a query using queryClient.cancelQueries(). This example shows a cancel button that, when clicked, cancels the 'todos' query.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/query-cancellation.md#2025-04-19_snippet_6

LANGUAGE: tsx
CODE:
```
const query = useQuery({
  queryKey: ['todos'],
  queryFn: async ({ signal }) => {
    const resp = await fetch('/todos', { signal })
    return resp.json()
  },
})

const queryClient = useQueryClient()

return (
  <button
    onClick={(e) => {
      e.preventDefault()
      queryClient.cancelQueries({ queryKey: ['todos'] })
    }}
  >
    Cancel
  </button>
)
```

----------------------------------------

TITLE: Query Keys with Variable Dependencies
DESCRIPTION: Shows how to include query function dependencies in query keys to ensure proper caching and automatic refetching.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/query-keys.md#2025-04-19_snippet_4

LANGUAGE: tsx
CODE:
```
function Todos({ todoId }) {
  const result = useQuery({
    queryKey: ['todos', todoId],
    queryFn: () => fetchTodoById(todoId),
  })
}
```

----------------------------------------

TITLE: Dependent Nested Component Waterfall Example
DESCRIPTION: Example demonstrating a dependent nested component waterfall where child queries depend on parent data for execution.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/request-waterfalls.md#2025-04-19_snippet_4

LANGUAGE: typescript
CODE:
```
function Feed() {
  const { data, isPending } = useQuery({
    queryKey: ['feed'],
    queryFn: getFeed,
  })

  if (isPending) {
    return 'Loading feed...'
  }

  return (
    <>
      {data.map((feedItem) => {
        if (feedItem.type === 'GRAPH') {
          return <GraphFeedItem key={feedItem.id} feedItem={feedItem} />
        }

        return <StandardFeedItem key={feedItem.id} feedItem={feedItem} />
      })}
    </>
  )
}

function GraphFeedItem({ feedItem }) {
  const { data, isPending } = useQuery({
    queryKey: ['graph', feedItem.id],
    queryFn: getGraphDataById,
  })

  ...
}
```

----------------------------------------

TITLE: Manually Setting Focus State in TanStack Query
DESCRIPTION: Illustrates how to use focusManager.setFocused to manually set the focus state. It can be set to true, false, or undefined to fall back to the default focus check.
SOURCE: https://github.com/tanstack/query/blob/main/docs/reference/focusManager.md#2025-04-19_snippet_2

LANGUAGE: tsx
CODE:
```
import { focusManager } from '@tanstack/react-query'

// Set focused
focusManager.setFocused(true)

// Set unfocused
focusManager.setFocused(false)

// Fallback to the default focus check
focusManager.setFocused(undefined)
```

----------------------------------------

TITLE: Using useSuspenseQueries Hook in React with TanStack Query
DESCRIPTION: Demonstrates the basic usage of useSuspenseQueries hook. This hook returns query results with guaranteed defined data and simplified status states, but doesn't support certain options like suspense, throwOnError, enabled, or placeholderData.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/reference/useSuspenseQueries.md#2025-04-19_snippet_0

LANGUAGE: tsx
CODE:
```
const result = useSuspenseQueries(options)
```

----------------------------------------

TITLE: Basic Usage of injectQuery in Angular
DESCRIPTION: Demonstrates how to use injectQuery to create a simple query in an Angular service or component.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/functions/injectquery.md#2025-04-19_snippet_0

LANGUAGE: typescript
CODE:
```
class ServiceOrComponent {
  query = injectQuery(() => ({
    queryKey: ['repoData'],
    queryFn: () =>
      this.#http.get<Response>('https://api.github.com/repos/tanstack/query'),
  }))
}
```

----------------------------------------

TITLE: Typed API Request Function
DESCRIPTION: Example of proper typing for API request functions to ensure type safety throughout the query chain.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/solid/typescript.md#2025-04-19_snippet_2

LANGUAGE: tsx
CODE:
```
const fetchGroups = (): Promise<Group[]> =>
  axios.get('/groups').then((response) => response.data)

const query = useQuery(() => ({
  queryKey: ['groups'],
  queryFn: fetchGroups,
}))

query.data
//    ^? (property) data: Group[] | undefined
```

----------------------------------------

TITLE: Basic useQuery Implementation
DESCRIPTION: Basic example showing how to fetch data from an API using useQuery. Demonstrates error handling, loading states, and data rendering patterns.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/solid/reference/useQuery.md#2025-04-19_snippet_1

LANGUAGE: tsx
CODE:
```
import { useQuery } from '@tanstack/solid-query'

function App() {
  const todos = useQuery(() => ({
    queryKey: 'todos',
    queryFn: async () => {
      const response = await fetch('/api/todos')
      if (!response.ok) {
        throw new Error('Failed to fetch todos')
      }
      return response.json()
    },
  }))

  return (
    <div>
      <Show when={todos.isError}>
        <div>Error: {todos.error.message}</div>
      </Show>
      <Show when={todos.isLoading}>
        <div>Loading...</div>
      </Show>
      <Show when={todos.isSuccess}>
        <div>
          <div>Todos:</div>
          <ul>
            <For each={todos.data}>{(todo) => <li>{todo.title}</li>}</For>
          </ul>
        </div>
      </Show>
    </div>
  )
}
```

----------------------------------------

TITLE: Setting Up Vue Query with Custom QueryClient Instance
DESCRIPTION: Demonstrates how to create and use a custom QueryClient instance with the Vue Query plugin.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/custom-client.md#2025-04-19_snippet_1

LANGUAGE: tsx
CODE:
```
const myClient = new QueryClient(queryClientConfig)
const vueQueryPluginOptions: VueQueryPluginOptions = {
  queryClient: myClient,
}
app.use(VueQueryPlugin, vueQueryPluginOptions)
```

----------------------------------------

TITLE: Updating React Query Import Statements
DESCRIPTION: Changes required to update import statements from react-query to @tanstack/react-query.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-react-query-4.md#2025-04-19_snippet_1

LANGUAGE: typescript
CODE:
```
- import { useQuery } from 'react-query'
- import { ReactQueryDevtools } from 'react-query/devtools'

+ import { useQuery } from '@tanstack/react-query'
+ import { ReactQueryDevtools } from '@tanstack/react-query-devtools'
```

----------------------------------------

TITLE: Subscribing to Focus State Changes in TanStack Query
DESCRIPTION: Shows how to use focusManager.subscribe to listen for changes in the visibility state. The function returns an unsubscribe function to remove the listener when needed.
SOURCE: https://github.com/tanstack/query/blob/main/docs/reference/focusManager.md#2025-04-19_snippet_1

LANGUAGE: tsx
CODE:
```
import { focusManager } from '@tanstack/react-query'

const unsubscribe = focusManager.subscribe((isVisible) => {
  console.log('isVisible', isVisible)
})
```

----------------------------------------

TITLE: injectQuery Function Signature (Create Result)
DESCRIPTION: Type definition for injectQuery function that returns a CreateQueryResult. It includes type parameters and descriptions for the function parameters.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/functions/injectquery.md#2025-04-19_snippet_3

LANGUAGE: typescript
CODE:
```
function injectQuery<TQueryFnData, TError, TData, TQueryKey>(
  optionsFn,
  injector?,
): CreateQueryResult<TData, TError>
```

----------------------------------------

TITLE: Type Narrowing with Success State
DESCRIPTION: Shows how to narrow types using the isSuccess flag with Vue's reactive wrapper. When isSuccess is true, data is narrowed to the specific type.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/typescript.md#2025-04-19_snippet_3

LANGUAGE: tsx
CODE:
```
const { data, isSuccess } = reactive(
  useQuery({
    queryKey: ['test'],
    queryFn: () => Promise.resolve(5),
  }),
)

if (isSuccess) {
  data
  // ^? const data: number
}
```

----------------------------------------

TITLE: Configuring Root Layout with React Query Provider
DESCRIPTION: Sets up the root layout component to wrap the application with the React Query provider.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/advanced-ssr.md#2025-04-19_snippet_1

LANGUAGE: tsx
CODE:
```
import Providers from './providers'

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en">
      <head />
      <body>
        <Providers>{children}</Providers>
      </body>
    </html>
  )
}
```

----------------------------------------

TITLE: Implementing Query Client with Persister
DESCRIPTION: Example showing how to create a QueryClient with a persister configuration using AsyncStorage.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/plugins/createPersister.md#2025-04-19_snippet_1

LANGUAGE: tsx
CODE:
```
import AsyncStorage from '@react-native-async-storage/async-storage'
import { QueryClient } from '@tanstack/react-query'
import { experimental_createPersister } from '@tanstack/query-persist-client-core'

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      gcTime: 1000 * 30, // 30 seconds
      persister: experimental_createPersister({
        storage: AsyncStorage,
        maxAge: 1000 * 60 * 60 * 12, // 12 hours
      }),
    },
  },
})
```

----------------------------------------

TITLE: Conditional Query Enabling with Signal
DESCRIPTION: Shows how to conditionally enable a query based on a signal value. The query will only execute when the filter signal has a value.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/disabling-queries.md#2025-04-19_snippet_1

LANGUAGE: angular-ts
CODE:
```
@Component({
  selector: 'todos',
  template: `
    <div>
      // üöÄ applying the filter will enable and execute the query
      <filters-form onApply="filter.set" />
      <todos-table data="query.data()" />
    </div>
  `,
})
export class TodosComponent {
  filter = signal('')

  todosQuery = injectQuery(() => ({
    queryKey: ['todos', this.filter()],
    queryFn: () => fetchTodos(this.filter()),
    enabled: !!this.filter(),
  }))
}
```

----------------------------------------

TITLE: Using QueryCache.findAll Method
DESCRIPTION: Demonstrates how to retrieve multiple existing query instances from the cache that partially match a query key.
SOURCE: https://github.com/tanstack/query/blob/main/docs/reference/QueryCache.md#2025-04-19_snippet_2

LANGUAGE: tsx
CODE:
```
const queries = queryCache.findAll(queryKey)
```

----------------------------------------

TITLE: Implementing Query Cancellation with Axios (pre-v0.22.0) in TanStack Query
DESCRIPTION: Demonstrates how to implement query cancellation with Axios versions prior to 0.22.0 in TanStack Query. It uses a CancelToken source and manually links it to the AbortSignal.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/query-cancellation.md#2025-04-19_snippet_2

LANGUAGE: tsx
CODE:
```
import axios from 'axios'

const query = useQuery({
  queryKey: ['todos'],
  queryFn: ({ signal }) => {
    // Create a new CancelToken source for this request
    const CancelToken = axios.CancelToken
    const source = CancelToken.source()

    const promise = axios.get('/todos', {
      // Pass the source token to your request
      cancelToken: source.token,
    })

    // Cancel the request if TanStack Query signals to abort
    signal?.addEventListener('abort', () => {
      source.cancel('Query was cancelled by TanStack Query')
    })

    return promise
  },
})
```

----------------------------------------

TITLE: Default Options for StoragePersisterOptions
DESCRIPTION: Default configuration options for the StoragePersisterOptions, including prefix, maxAge, and serialization methods.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/plugins/createPersister.md#2025-04-19_snippet_3

LANGUAGE: tsx
CODE:
```
{
  prefix = 'tanstack-query',
  maxAge = 1000 * 60 * 60 * 24,
  serialize = JSON.stringify,
  deserialize = JSON.parse,
}
```

----------------------------------------

TITLE: Incorrect Usage of Query Hook Result in React Hook Dependency Array
DESCRIPTION: This example demonstrates the incorrect pattern of putting the entire 'mutation' object returned from useMutation directly into a useCallback dependency array, which can cause unnecessary re-renders due to referential instability.
SOURCE: https://github.com/tanstack/query/blob/main/docs/eslint/no-unstable-deps.md#2025-04-19_snippet_0

LANGUAGE: tsx
CODE:
```
/* eslint "@tanstack/query/no-unstable-deps": "warn" */
import { useCallback } from 'React'
import { useMutation } from '@tanstack/react-query'

function Component() {
  const mutation = useMutation({ mutationFn: (value: string) => value })
  const callback = useCallback(() => {
    mutation.mutate('hello')
  }, [mutation])
  return null
}
```

----------------------------------------

TITLE: Implementing Floating Mode React Query Devtools
DESCRIPTION: Example of how to implement React Query Devtools in floating mode, which mounts the devtools as a fixed, floating element in the app with a toggle in the corner of the screen.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/devtools.md#2025-04-19_snippet_2

LANGUAGE: typescript
CODE:
```
import { ReactQueryDevtools } from '@tanstack/react-query-devtools'

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      {/* The rest of your application */}
      <ReactQueryDevtools initialIsOpen={false} />
    </QueryClientProvider>
  )
}
```

----------------------------------------

TITLE: injectQuery Function Signature (Defined Result)
DESCRIPTION: Type definition for injectQuery function that returns a DefinedCreateQueryResult. It includes type parameters and descriptions for the function parameters.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/functions/injectquery.md#2025-04-19_snippet_2

LANGUAGE: typescript
CODE:
```
function injectQuery<TQueryFnData, TError, TData, TQueryKey>(
  optionsFn,
  injector?,
): DefinedCreateQueryResult<TData, TError>
```

----------------------------------------

TITLE: Incorrect Usage of QueryClient in React Component
DESCRIPTION: This example shows incorrect code where a new QueryClient is created on every render of the App component, which goes against the best practice of maintaining a stable client.
SOURCE: https://github.com/tanstack/query/blob/main/docs/eslint/stable-query-client.md#2025-04-19_snippet_0

LANGUAGE: tsx
CODE:
```
/* eslint "@tanstack/query/stable-query-client": "error" */

function App() {
  const queryClient = new QueryClient()
  return (
    <QueryClientProvider client={queryClient}>
      <Home />
    </QueryClientProvider>
  )
}
```

----------------------------------------

TITLE: Initializing QueryCache in TanStack Query
DESCRIPTION: Demonstrates how to create and configure a new QueryCache instance with error, success, and settled event handlers. Shows basic query finding functionality.
SOURCE: https://github.com/tanstack/query/blob/main/docs/reference/QueryCache.md#2025-04-19_snippet_0

LANGUAGE: tsx
CODE:
```
import { QueryCache } from '@tanstack/react-query'

const queryCache = new QueryCache({
  onError: (error) => {
    console.log(error)
  },
  onSuccess: (data) => {
    console.log(data)
  },
  onSettled: (data, error) => {
    console.log(data, error)
  },
})

const query = queryCache.find(['posts'])
```

----------------------------------------

TITLE: Setting Custom Event Listener for Focus Management in TanStack Query
DESCRIPTION: Demonstrates how to use focusManager.setEventListener to set a custom event listener for focus management. This example listens for the visibilitychange event on the window object.
SOURCE: https://github.com/tanstack/query/blob/main/docs/reference/focusManager.md#2025-04-19_snippet_0

LANGUAGE: tsx
CODE:
```
import { focusManager } from '@tanstack/react-query'

focusManager.setEventListener((handleFocus) => {
  // Listen to visibilitychange
  if (typeof window !== 'undefined' && window.addEventListener) {
    window.addEventListener('visibilitychange', handleFocus, false)
  }

  return () => {
    // Be sure to unsubscribe if a new handler is set
    window.removeEventListener('visibilitychange', handleFocus)
  }
})
```

----------------------------------------

TITLE: TypeScript Codemod Command
DESCRIPTION: Command to run the codemod for updating imports in TypeScript/TSX files.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-react-query-4.md#2025-04-19_snippet_3

LANGUAGE: bash
CODE:
```
npx jscodeshift ./path/to/src/ \
  --extensions=ts,tsx \
  --parser=tsx \
  --transform=./node_modules/@tanstack/react-query/codemods/v4/replace-import-specifier.js
```

----------------------------------------

TITLE: Basic Usage of queryOptions Function in TypeScript
DESCRIPTION: Demonstrates how to use the queryOptions function to create type-safe query options. The example shows creating a queryKey with proper type inference and using it with QueryClient.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/functions/queryoptions.md#2025-04-19_snippet_0

LANGUAGE: typescript
CODE:
```
const { queryKey } = queryOptions({
  queryKey: ['key'],
  queryFn: () => Promise.resolve(5),
  //  ^?  Promise<number>
})

const queryClient = new QueryClient()
const data = queryClient.getQueryData(queryKey)
//    ^?  number | undefined
```

----------------------------------------

TITLE: Using Initial Data in Svelte Query Component
DESCRIPTION: Implementation of a Svelte component that uses the server-loaded data as initialData for TanStack Query.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/ssr.md#2025-04-19_snippet_2

LANGUAGE: svelte
CODE:
```
<script>
  import { createQuery } from '@tanstack/svelte-query'
  import type { PageData } from './$types'

  export let data: PageData

  const query = createQuery({
    queryKey: ['posts'],
    queryFn: getPosts,
    initialData: data.posts,
  })
</script>
```

----------------------------------------

TITLE: Correct usage of query function returning data in TanStack Query
DESCRIPTION: This example demonstrates the proper way to implement a query function that returns data for TanStack Query to cache, ensuring the expected behavior of the library.
SOURCE: https://github.com/tanstack/query/blob/main/docs/eslint/no-void-query-fn.md#2025-04-19_snippet_1

LANGUAGE: tsx
CODE:
```
/* eslint "@tanstack/query/no-void-query-fn": "error" */
useQuery({
  queryKey: ['todos'],
  queryFn: async () => {
    const todos = await api.todos.fetch()
    return todos
  },
})
```

----------------------------------------

TITLE: Using useIsMutating Hook in Solid.js with TanStack Query
DESCRIPTION: This snippet shows how to use the useIsMutating hook from @tanstack/solid-query in a Solid.js application. It functions similarly to the React version, allowing you to check for all mutations or specific ones using a filter.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/solid/reference/useIsMutating.md#2025-04-19_snippet_1

LANGUAGE: javascript
CODE:
```
import { useIsMutating } from '@tanstack/solid-query'

// Check if any mutations are in progress
const isMutating = useIsMutating()

// Check if specific mutations are in progress
const isMutatingPosts = useIsMutating({ mutationKey: ['posts'] })
```

----------------------------------------

TITLE: Clearing All Caches with clear in TanStack Query
DESCRIPTION: The clear method clears all connected caches, removing all queries and mutations from their respective caches.
SOURCE: https://github.com/tanstack/query/blob/main/docs/reference/QueryClient.md#2025-04-19_snippet_29

LANGUAGE: tsx
CODE:
```
queryClient.clear()
```

----------------------------------------

TITLE: Managing Focus in React Native with TanStack Query
DESCRIPTION: This example shows how to manage focus in React Native using the AppState module and TanStack Query's focusManager.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/window-focus-refetching.md#2025-04-19_snippet_3

LANGUAGE: tsx
CODE:
```
import { AppState } from 'react-native'
import { focusManager } from '@tanstack/react-query'

function onAppStateChange(status: AppStateStatus) {
  if (Platform.OS !== 'web') {
    focusManager.setFocused(status === 'active')
  }
}

useEffect(() => {
  const subscription = AppState.addEventListener('change', onAppStateChange)

  return () => subscription.remove()
}, [])
```

----------------------------------------

TITLE: Type Inference with Custom API Response
DESCRIPTION: Demonstrates type inference with a custom API response type using axios. The query result is typed as Ref<Group[]> | Ref<undefined>.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/typescript.md#2025-04-19_snippet_2

LANGUAGE: tsx
CODE:
```
const fetchGroups = (): Promise<Group[]> =>
  axios.get('/groups').then((response) => response.data)

const { data } = useQuery({ queryKey: ['groups'], queryFn: fetchGroups })
//      ^? const data: Ref<Group[]> | Ref<undefined>
```

----------------------------------------

TITLE: Defining BroadcastQueryClientOptions Interface in TypeScript
DESCRIPTION: This code snippet defines the interface for the options object passed to the broadcastQueryClient function. It specifies the structure of the options, including the required QueryClient instance and optional broadcastChannel and BroadcastChannelOptions.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/plugins/broadcastQueryClient.md#2025-04-19_snippet_1

LANGUAGE: tsx
CODE:
```
interface BroadcastQueryClientOptions {
  /** The QueryClient to sync */
  queryClient: QueryClient
  /** This is the unique channel name that will be used
   * to communicate between tabs and windows */
  broadcastChannel?: string
  /** Options for the BroadcastChannel API */
  options?: BroadcastChannelOptions
}
```

----------------------------------------

TITLE: Defining createInfiniteQuery Function in TypeScript
DESCRIPTION: This code snippet defines the createInfiniteQuery function with its type parameters, parameters, and return type. It is used for creating infinite queries in the TanStack Query library.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/reference/functions/createinfinitequery.md#2025-04-19_snippet_0

LANGUAGE: typescript
CODE:
```
function createInfiniteQuery<
  TQueryFnData,
  TError,
  TData,
  TQueryKey,
  TPageParam,
>(options, queryClient?): CreateInfiniteQueryResult<TData, TError>
```

----------------------------------------

TITLE: Defining QueriesOptions Type for TanStack Query
DESCRIPTION: A recursive type definition that unwraps function arguments to infer and enforce type parameters for query options. It handles arrays of query observer options with support for maximum depth checking and proper type inference of query function data, errors, and keys.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/reference/type-aliases/queriesoptions.md#2025-04-19_snippet_0

LANGUAGE: typescript
CODE:
```
type QueriesOptions<T, TResults, TDepth>: TDepth["length"] extends MAXIMUM_DEPTH ? QueryObserverOptionsForCreateQueries[] : T extends [] ? [] : T extends [infer Head] ? [...TResults, GetQueryObserverOptionsForCreateQueries<Head>] : T extends [infer Head, ...(infer Tails)] ? QueriesOptions<[...Tails], [...TResults, GetQueryObserverOptionsForCreateQueries<Head>], [...TDepth, 1]> : ReadonlyArray<unknown> extends T ? T : T extends QueryObserverOptionsForCreateQueries<infer TQueryFnData, infer TError, infer TData, infer TQueryKey>[] ? QueryObserverOptionsForCreateQueries<TQueryFnData, TError, TData, TQueryKey>[] : QueryObserverOptionsForCreateQueries[];
```

----------------------------------------

TITLE: Defining Basic Query Keys in TanStack Query (TypeScript)
DESCRIPTION: This snippet demonstrates how to define basic query keys for different queries using TanStack Query. It shows examples for a list of todos and a custom query key.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/query-keys.md#2025-04-19_snippet_0

LANGUAGE: typescript
CODE:
```
// A list of todos
injectQuery(() => ({ queryKey: ['todos'], ... }))

// Something else, whatever!
injectQuery(() => ({ queryKey: ['something', 'special'], ... }))
```

----------------------------------------

TITLE: queryOptions Function with UndefinedInitialDataOptions
DESCRIPTION: Implementation of queryOptions function that accepts UndefinedInitialDataOptions. This version handles query options where initial data is not defined, providing type safety for queryKey.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/functions/queryoptions.md#2025-04-19_snippet_1

LANGUAGE: typescript
CODE:
```
function queryOptions<TQueryFnData, TError, TData, TQueryKey>(
  options,
): UndefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey> & object
```

----------------------------------------

TITLE: Custom Error Type in TypeScript Query
DESCRIPTION: Demonstrates how to specify a custom error type when throwing non-Error objects in TypeScript queries. Shows the usage of generic type parameters for query results and errors.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-v5.md#2025-04-19_snippet_8

LANGUAGE: ts
CODE:
```
useQuery<number, string>({
  queryKey: ['some-query'],
  queryFn: async () => {
    if (Math.random() > 0.5) {
      throw 'some error'
    }
    return 42
  },
})
```

----------------------------------------

TITLE: Initializing and Using InfiniteQueryObserver in TypeScript
DESCRIPTION: This snippet demonstrates how to create an InfiniteQueryObserver instance, configure it with query options, and subscribe to its results. It shows the setup for an infinite query for fetching posts, including pagination parameters.
SOURCE: https://github.com/tanstack/query/blob/main/docs/reference/InfiniteQueryObserver.md#2025-04-19_snippet_0

LANGUAGE: tsx
CODE:
```
const observer = new InfiniteQueryObserver(queryClient, {
  queryKey: ['posts'],
  queryFn: fetchPosts,
  getNextPageParam: (lastPage, allPages) => lastPage.nextCursor,
  getPreviousPageParam: (firstPage, allPages) => firstPage.prevCursor,
})

const unsubscribe = observer.subscribe((result) => {
  console.log(result)
  unsubscribe()
})
```

----------------------------------------

TITLE: Fetching Data with createResource in SolidJS
DESCRIPTION: This snippet demonstrates how to fetch data from an API using SolidJS's createResource primitive, handling loading and error states with Suspense and ErrorBoundary.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/solid/overview.md#2025-04-19_snippet_0

LANGUAGE: tsx
CODE:
```
import { createResource, ErrorBoundary, Suspense } from 'solid-js'
import { render } from 'solid-js/web'

function App() {
  const [repository] = createResource(async () => {
    const result = await fetch('https://api.github.com/repos/TanStack/query')
    if (!result.ok) throw new Error('Failed to fetch data')
    return result.json()
  })

  return (
    <div>
      <div>Static Content</div>
      {/* An error while fetching will be caught by the ErrorBoundary */}
      <ErrorBoundary fallback={<div>Something went wrong!</div>}>
        {/* Suspense will trigger a loading state while the data is being fetched */}
        <Suspense fallback={<div>Loading...</div>}>
          <div>{repository()?.updated_at}</div>
        </Suspense>
      </ErrorBoundary>
    </div>
  )
}

const root = document.getElementById('root')

render(() => <App />, root!)
```

----------------------------------------

TITLE: Error Type Narrowing with Type Guards
DESCRIPTION: Shows how to narrow error types using type guards like axios.isAxiosError. This allows for type-safe handling of specific error types.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/typescript.md#2025-04-19_snippet_6

LANGUAGE: ts
CODE:
```
import axios from 'axios'

query = injectQuery(() => ({ queryKey: ['groups'], queryFn: fetchGroups }))

computed(() => {
  const error = query.error()
  //     ^? error: Error | null

  if (axios.isAxiosError(error)) {
    error
    // ^? const error: AxiosError
  }
})
```

----------------------------------------

TITLE: Prefetching Infinite Query Data
DESCRIPTION: Shows how to prefetch infinite query data for pagination scenarios.
SOURCE: https://github.com/tanstack/query/blob/main/docs/reference/QueryClient.md#2025-04-19_snippet_6

LANGUAGE: tsx
CODE:
```
await queryClient.prefetchInfiniteQuery({ queryKey, queryFn })
```

----------------------------------------

TITLE: Configuring Query Retries for Individual Queries in Vue
DESCRIPTION: This snippet shows how to set a specific number of retry attempts for an individual query using the useQuery hook from @tanstack/vue-query. It demonstrates setting the retry option to 10 for a query fetching a todo list page.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/query-retries.md#2025-04-19_snippet_0

LANGUAGE: tsx
CODE:
```
import { useQuery } from '@tanstack/vue-query'

// Make a specific query retry a certain number of times
const result = useQuery({
  queryKey: ['todos', 1],
  queryFn: fetchTodoListPage,
  retry: 10, // Will retry failed requests 10 times before displaying an error
})
```

----------------------------------------

TITLE: Setting Multiple Queries Data in TSX
DESCRIPTION: Example of using queryClient.setQueriesData to update multiple queries simultaneously using filters.
SOURCE: https://github.com/tanstack/query/blob/main/docs/reference/QueryClient.md#2025-04-19_snippet_13

LANGUAGE: tsx
CODE:
```
queryClient.setQueriesData(filters, updater)
```

----------------------------------------

TITLE: Refetching Data with useQuery in SolidJS
DESCRIPTION: Example of using the refetch function provided by useQuery. This function allows manual refetching of the query data with options for error handling and cancellation.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/solid/reference/useQuery.md#2025-04-19_snippet_8

LANGUAGE: javascript
CODE:
```
const { refetch } = useQuery(...);

// Later in your code
refetch({ throwOnError: true, cancelRefetch: false })
```

----------------------------------------

TITLE: Serial Suspense Queries Example
DESCRIPTION: Demonstration of how using multiple useSuspenseQuery calls creates serial request waterfalls and how to optimize them using useSuspenseQueries.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/request-waterfalls.md#2025-04-19_snippet_2

LANGUAGE: typescript
CODE:
```
const [usersQuery, teamsQuery, projectsQuery] = useSuspenseQueries({
  queries: [
    { queryKey: ['users'], queryFn: fetchUsers },
    { queryKey: ['teams'], queryFn: fetchTeams },
    { queryKey: ['projects'], queryFn: fetchProjects },
  ],
})
```

----------------------------------------

TITLE: Type Narrowing with Status Checks
DESCRIPTION: Demonstrates type narrowing using discriminated union types and status checks.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/solid/typescript.md#2025-04-19_snippet_3

LANGUAGE: tsx
CODE:
```
const query = useQuery(() => ({
  queryKey: ['number'],
  queryFn: () => Promise.resolve(5),
}))

if (query.isSuccess) {
  const data = query.data
  //     ^? const data: number
}
```

----------------------------------------

TITLE: Using Vue Query in Vite SSR Components
DESCRIPTION: This snippet shows how to use Vue Query in a component with Vite SSR, demonstrating the usage of useQuery and onServerPrefetch for server-side data fetching.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/ssr.md#2025-04-19_snippet_5

LANGUAGE: vue
CODE:
```
<template>
  <div>
    <button @click="refetch">Refetch</button>
    <p>{{ data }}</p>
  </div>
</template>

<script setup>
  import { useQuery } from '@tanstack/vue-query'
  import { onServerPrefetch } from 'vue'

  // This will be prefetched and sent from the server
  const { refetch, data, suspense } = useQuery({
    queryKey: ['todos'],
    queryFn: getTodos,
  })

  onServerPrefetch(suspense)
</script>
```

----------------------------------------

TITLE: Removing Queries in TSX
DESCRIPTION: Example of using queryClient.removeQueries to remove queries from the cache.
SOURCE: https://github.com/tanstack/query/blob/main/docs/reference/QueryClient.md#2025-04-19_snippet_17

LANGUAGE: tsx
CODE:
```
queryClient.removeQueries({ queryKey, exact: true })
```

----------------------------------------

TITLE: Defining DefinedInitialDataInfiniteOptions Type Alias in TypeScript
DESCRIPTION: This type alias extends CreateInfiniteQueryOptions with an additional object. It includes type parameters for query function data, error, data, query key, and page param. The initialData property is specifically defined within the type declaration.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/type-aliases/definedinitialdatainfiniteoptions.md#2025-04-19_snippet_0

LANGUAGE: typescript
CODE:
```
type DefinedInitialDataInfiniteOptions<TQueryFnData, TError, TData, TQueryKey, TPageParam>: CreateInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryFnData, TQueryKey, TPageParam> & object;
```

----------------------------------------

TITLE: Query Options Type Helper
DESCRIPTION: Shows how to use the queryOptions helper for type-safe query configuration sharing.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/solid/typescript.md#2025-04-19_snippet_4

LANGUAGE: ts
CODE:
```
import { queryOptions } from '@tanstack/solid-query'

function groupOptions() {
  return queryOptions({
    queryKey: ['groups'],
    queryFn: fetchGroups,
    staleTime: 5 * 1000,
  })
}

useQuery(groupOptions)
queryClient.prefetchQuery(groupOptions())
```

----------------------------------------

TITLE: Defining CreateInfiniteQueryOptions Interface in TypeScript
DESCRIPTION: TypeScript interface definition that extends InfiniteQueryObserverOptions, providing type parameters for query function data, error handling, data transformation, query key, and pagination parameters. Omits the 'suspense' property from the base interface.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/interfaces/createinfinitequeryoptions.md#2025-04-19_snippet_0

LANGUAGE: typescript
CODE:
```
interface CreateInfiniteQueryOptions<
  TQueryFnData = unknown,
  TError = DefaultError,
  TData = TQueryFnData,
  TQueryData = TQueryFnData,
  TQueryKey extends QueryKey = QueryKey,
  TPageParam = unknown
> extends OmitKeyof<
  InfiniteQueryObserverOptions<TQueryFnData, TError, TData, TQueryData, TQueryKey, TPageParam>,
  "suspense"
>
```

----------------------------------------

TITLE: Updating Refetch Flags in TypeScript
DESCRIPTION: This code demonstrates the changes to refetch flags in invalidateQueries, combining separate boolean flags into a single type with multiple options.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-react-query-4.md#2025-04-19_snippet_8

LANGUAGE: tsx
CODE:
```
- refetchActive?: boolean // [!code --]
- refetchInactive?: boolean // [!code --]
+ refetchType?: 'active' | 'inactive' | 'all' | 'none' // [!code ++]
```

----------------------------------------

TITLE: Idle State Removal Changes
DESCRIPTION: Changes related to the removal of the idle state and introduction of fetchStatus.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-react-query-4.md#2025-04-19_snippet_5

LANGUAGE: typescript
CODE:
```
- status: 'idle'
+ status: 'loading'
+ fetchStatus: 'idle'
```

----------------------------------------

TITLE: Retrieving Query Default Options with getQueryDefaults in TanStack Query
DESCRIPTION: The getQueryDefaults method returns the default options which have been set for specific queries. Multiple matching query defaults are merged based on registration order.
SOURCE: https://github.com/tanstack/query/blob/main/docs/reference/QueryClient.md#2025-04-19_snippet_23

LANGUAGE: tsx
CODE:
```
const defaultOptions = queryClient.getQueryDefaults(['posts'])
```

----------------------------------------

TITLE: Registering Default Error Types
DESCRIPTION: Demonstrates how to register a default error type for all queries using module augmentation. This sets AxiosError as the default error type for all queries.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/typescript.md#2025-04-19_snippet_7

LANGUAGE: ts
CODE:
```
import '@tanstack/angular-query-experimental'

declare module '@tanstack/angular-query-experimental' {
  interface Register {
    defaultError: AxiosError
  }
}

const query = injectQuery(() => ({
  queryKey: ['groups'],
  queryFn: fetchGroups,
}))

computed(() => {
  const error = query.error()
  //      ^? error: AxiosError | null
})
```

----------------------------------------

TITLE: Implementing Vue Query Devtools Component
DESCRIPTION: Example of implementing the VueQueryDevtools component in a Vue 3 application template. The component should be placed as high as possible in the component tree for optimal functionality.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/devtools.md#2025-04-19_snippet_1

LANGUAGE: vue
CODE:
```
<script setup>
import { VueQueryDevtools } from '@tanstack/vue-query-devtools'
</script>

<template>
  <h1>The app!</h1>
  <VueQueryDevtools />
</template>
```

----------------------------------------

TITLE: Incorrect Query Key Implementation in TanStack Query (TSX)
DESCRIPTION: These examples demonstrate incorrect usage of query keys where not all dependencies are included. This can lead to caching issues and prevent automatic refetching when variables change.
SOURCE: https://github.com/tanstack/query/blob/main/docs/eslint/exhaustive-deps.md#2025-04-19_snippet_0

LANGUAGE: tsx
CODE:
```
/* eslint "@tanstack/query/exhaustive-deps": "error" */

useQuery({
  queryKey: ['todo'],
  queryFn: () => api.getTodo(todoId),
})

const todoQueries = {
  detail: (id) => ({ queryKey: ['todo'], queryFn: () => api.getTodo(id) }),
}
```

----------------------------------------

TITLE: Hook Replacement Configuration for TanStack Query
DESCRIPTION: Configuration object that defines mapping rules for converting React query hooks to Solid query hooks. It includes replacements for mutation state, queries, and utility functions.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/solid/guides/placeholder-query-data.md#2025-04-19_snippet_0

LANGUAGE: javascript
CODE:
```
{
  'React': 'Solid',
  '@tanstack/react-query': '@tanstack/solid-query',
  'useMutationState[(]': 'useMutationState(() => ',
  'useMutation[(]': 'useMutation(() => ',
  'useQuery[(]': 'useQuery(() => ',
  'useQueries[(]': 'useQueries(() => ',
  'useInfiniteQuery[(]': 'useInfiniteQuery(() => ',
  'useMemo': 'createMemo'
}
```

----------------------------------------

TITLE: Canceling Queries in TSX
DESCRIPTION: Example of using queryClient.cancelQueries to cancel ongoing query operations.
SOURCE: https://github.com/tanstack/query/blob/main/docs/reference/QueryClient.md#2025-04-19_snippet_16

LANGUAGE: tsx
CODE:
```
await queryClient.cancelQueries({ queryKey: ['posts'], exact: true })
```

----------------------------------------

TITLE: Implementing Data Prefetching in Page Load Function
DESCRIPTION: Page load function implementation that prefetches query data using the QueryClient.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/ssr.md#2025-04-19_snippet_5

LANGUAGE: typescript
CODE:
```
export async function load({ parent, fetch }) {
  const { queryClient } = await parent()

  await queryClient.prefetchQuery({
    queryKey: ['posts'],
    queryFn: async () => (await fetch('/api/posts')).json(),
  })
}
```

----------------------------------------

TITLE: Server-Side Rendering Request Waterfall
DESCRIPTION: This snippet shows the request waterfall that occurs on the server when fetching dependent data. It demonstrates that while some requests are still sequential, the overall process is typically faster due to lower latency on the server.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/ssr.md#2025-04-19_snippet_10

LANGUAGE: markdown
CODE:
```
```
1. |> getFeed()
2.   |> getGraphDataById()
```
```

----------------------------------------

TITLE: Type Inference with Data Transformation
DESCRIPTION: Shows type inference when using the select option to transform query results. The return type is automatically inferred as Ref<string> | Ref<undefined>.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/typescript.md#2025-04-19_snippet_1

LANGUAGE: tsx
CODE:
```
const { data } = useQuery({
  //      ^? const data: Ref<string> | Ref<undefined>
  queryKey: ['test'],
  queryFn: () => Promise.resolve(5),
  select: (data) => data.toString(),
})
```

----------------------------------------

TITLE: Defining infiniteQueryOptions Function in TypeScript
DESCRIPTION: Generic function definition for configuring infinite queries in TanStack Query. The function accepts options for query configuration and returns CreateInfiniteQueryOptions with specified type parameters for query data, error handling, pagination, and key management.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/reference/functions/infinitequeryoptions.md#2025-04-19_snippet_0

LANGUAGE: typescript
CODE:
```
function infiniteQueryOptions<
  TQueryFnData,
  TError,
  TData,
  TQueryKey,
  TPageParam,
>(
  options,
): CreateInfiniteQueryOptions<
  TQueryFnData,
  TError,
  TData,
  TQueryFnData,
  TQueryKey,
  TPageParam
>
```

----------------------------------------

TITLE: Implementing Schedule Function in NotifyManager
DESCRIPTION: Definition of the schedule method that queues a callback for execution in the next batch. By default uses setTimeout but can be configured differently.
SOURCE: https://github.com/tanstack/query/blob/main/docs/reference/notifyManager.md#2025-04-19_snippet_2

LANGUAGE: typescript
CODE:
```
function schedule(callback: () => void): void
```

----------------------------------------

TITLE: Hook Replacement Mapping for TanStack Query
DESCRIPTION: Configuration object defining replacement patterns for converting React Query hooks to Solid Query equivalents. Includes mappings for mutation state, mutations, queries, and infinite queries.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/solid/guides/query-invalidation.md#2025-04-19_snippet_0

LANGUAGE: javascript
CODE:
```
{
  '@tanstack/react-query': '@tanstack/solid-query',
  'useMutationState[(]': 'useMutationState(() => ',
  'useMutation[(]': 'useMutation(() => ',
  'useQuery[(]': 'useQuery(() => ',
  'useQueries[(]': 'useQueries(() => ',
  'useInfiniteQuery[(]': 'useInfiniteQuery(() => '
}
```

----------------------------------------

TITLE: Implementing isSuccess Method for Mutation State Narrowing in TypeScript
DESCRIPTION: Type predicate method that narrows a mutation result to the success state, providing type-safe access to success-specific properties and data.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/interfaces/basemutationnarrowing.md#2025-04-19_snippet_3

LANGUAGE: typescript
CODE:
```
isSuccess: (this) => this is CreateMutationResult<TData, TError, TVariables, TContext, Override<MutationObserverSuccessResult<TData, TError, TVariables, TContext>, Object> & Object>;
```

----------------------------------------

TITLE: Implementing InfiniteQueryOptions with Undefined Initial Data in TypeScript
DESCRIPTION: Function implementation for handling infinite query options with undefined initial data. Takes generic type parameters for query function data, error handling, data structure, query key, and page parameters. Returns tagged infinite query options.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/functions/infinitequeryoptions.md#2025-04-19_snippet_0

LANGUAGE: typescript
CODE:
```
function infiniteQueryOptions<
  TQueryFnData,
  TError,
  TData,
  TQueryKey,
  TPageParam,
>(
  options,
): UndefinedInitialDataInfiniteOptions<
  TQueryFnData,
  TError,
  TData,
  TQueryKey,
  TPageParam
> &
  object
```

----------------------------------------

TITLE: Checking Current Online State in TanStack Query
DESCRIPTION: Shows how to check the current online state using the isOnline method of the OnlineManager.
SOURCE: https://github.com/tanstack/query/blob/main/docs/reference/onlineManager.md#2025-04-19_snippet_3

LANGUAGE: tsx
CODE:
```
const isOnline = onlineManager.isOnline()
```

----------------------------------------

TITLE: Updating Query Filter Types in TypeScript
DESCRIPTION: This snippet shows the changes to query filter types in v4, combining boolean flags into a single filter for better clarity and to avoid impossible states.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-react-query-4.md#2025-04-19_snippet_7

LANGUAGE: tsx
CODE:
```
- active?: boolean // [!code --]
- inactive?: boolean // [!code --]
+ type?: 'active' | 'inactive' | 'all' // [!code ++]
```

----------------------------------------

TITLE: Defining CreateQueryOptions Interface in TypeScript
DESCRIPTION: Interface definition for CreateQueryOptions which extends the CreateBaseQueryOptions interface while omitting the 'suspense' property. It defines four generic type parameters for managing query function data, errors, returned data, and query keys.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/interfaces/createqueryoptions.md#2025-04-19_snippet_0

LANGUAGE: typescript
CODE:
```
# Interface: CreateQueryOptions\<TQueryFnData, TError, TData, TQueryKey\>

## Extends

- `OmitKeyof`\<[`CreateBaseQueryOptions`](createbasequeryoptions.md)\<`TQueryFnData`, `TError`, `TData`, `TQueryFnData`, `TQueryKey`\>, `"suspense"`\>

## Type Parameters

‚Ä¢ **TQueryFnData** = `unknown`

‚Ä¢ **TError** = `DefaultError`

‚Ä¢ **TData** = `TQueryFnData`

‚Ä¢ **TQueryKey** _extends_ `QueryKey` = `QueryKey`
```

----------------------------------------

TITLE: Configuring Default Options in QueryClient
DESCRIPTION: Sets default options for queries and mutations using the QueryClient constructor.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-react-query-3.md#2025-04-19_snippet_1

LANGUAGE: tsx
CODE:
```
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      // query options
    },
    mutations: {
      // mutation options
    },
  },
})
```

----------------------------------------

TITLE: Correct Usage with Module-level QueryClient
DESCRIPTION: This example shows another correct approach where the QueryClient is created at the module level, outside of any component, ensuring it remains stable throughout the application lifecycle.
SOURCE: https://github.com/tanstack/query/blob/main/docs/eslint/stable-query-client.md#2025-04-19_snippet_2

LANGUAGE: tsx
CODE:
```
const queryClient = new QueryClient()
function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <Home />
    </QueryClientProvider>
  )
}
```

----------------------------------------

TITLE: Simplified Optimistic Updates in React Query
DESCRIPTION: Shows a new approach to optimistic updates using the returned variables from useMutation in React Query.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-v5.md#2025-04-19_snippet_15

LANGUAGE: tsx
CODE:
```
const queryInfo = useTodos()
const addTodoMutation = useMutation({
  mutationFn: (newTodo: string) => axios.post('/api/data', { text: newTodo }),
  onSettled: () => queryClient.invalidateQueries({ queryKey: ['todos'] }),
})

if (queryInfo.data) {
  return (
    <ul>
      {queryInfo.data.items.map((todo) => (
        <li key={todo.id}>{todo.text}</li>
      ))}
      {addTodoMutation.isPending && (
        <li key={String(addTodoMutation.submittedAt)} style={{ opacity: 0.5 }}>
          {addTodoMutation.variables}
        </li>
      )}
    </ul>
  )
}
```

----------------------------------------

TITLE: Configuring Network Mode in TanStack Query for React
DESCRIPTION: This snippet demonstrates how to set up the network mode for a TanStack Query client in a React application. It shows different configuration options for the networkMode property.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/network-mode.md#2025-04-19_snippet_0

LANGUAGE: javascript
CODE:
```
import { QueryClient } from '@tanstack/react-query'

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      networkMode: 'online',
    },
    mutations: {
      networkMode: 'always',
    },
  },
})
```

----------------------------------------

TITLE: Query Error Reset Hook Implementation
DESCRIPTION: Demonstrates using the useQueryErrorResetBoundary hook for managing query errors
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/suspense.md#2025-04-19_snippet_2

LANGUAGE: tsx
CODE:
```
import { useQueryErrorResetBoundary } from '@tanstack/react-query'
import { ErrorBoundary } from 'react-error-boundary'

const App = () => {
  const { reset } = useQueryErrorResetBoundary()
  return (
    <ErrorBoundary
      onReset={reset}
      fallbackRender={({ resetErrorBoundary }) => (
        <div>
          There was an error!
          <Button onClick={() => resetErrorBoundary()}>Try again</Button>
        </div>
      )}
    >
      <Page />
    </ErrorBoundary>
  )
}
```

----------------------------------------

TITLE: Getting Query State in TSX
DESCRIPTION: Example of using queryClient.getQueryState to retrieve the current state of a query synchronously.
SOURCE: https://github.com/tanstack/query/blob/main/docs/reference/QueryClient.md#2025-04-19_snippet_12

LANGUAGE: tsx
CODE:
```
const state = queryClient.getQueryState(queryKey)
console.log(state.dataUpdatedAt)
```

----------------------------------------

TITLE: Combining Mutation and Mutation Function Callbacks
DESCRIPTION: Shows how to use callbacks both in the mutation definition and when calling mutate. Callbacks defined in the mutate function will fire after the callbacks defined in the mutation.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/mutations.md#2025-04-19_snippet_4

LANGUAGE: typescript
CODE:
```
mutation = injectMutation(() => ({
  mutationFn: addTodo,
  onSuccess: (data, variables, context) => {
    // I will fire first
  },
  onError: (error, variables, context) => {
    // I will fire first
  },
  onSettled: (data, error, variables, context) => {
    // I will fire first
  },
}))

mutation.mutate(todo, {
  onSuccess: (data, variables, context) => {
    // I will fire second!
  },
  onError: (error, variables, context) => {
    // I will fire second!
  },
  onSettled: (data, error, variables, context) => {
    // I will fire second!
  },
})
```

----------------------------------------

TITLE: Updating getQueryData and getQueryState in TanStack Query v5
DESCRIPTION: This snippet shows the changes in getQueryData and getQueryState methods, which now only accept a queryKey as an argument.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-v5.md#2025-04-19_snippet_3

LANGUAGE: tsx
CODE:
```
queryClient.getQueryData(queryKey, filters) // [!code --]
queryClient.getQueryData(queryKey) // [!code ++]

queryClient.getQueryState(queryKey, filters) // [!code --]
queryClient.getQueryState(queryKey) // [!code ++]
```

----------------------------------------

TITLE: Type Parameters for CreateBaseQueryOptions Interface
DESCRIPTION: Defines the five generic type parameters used in the CreateBaseQueryOptions interface, including default types for each parameter. These types control the data flow and error handling within TanStack Query operations.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/interfaces/createbasequeryoptions.md#2025-04-19_snippet_1

LANGUAGE: typescript
CODE:
```
/**
‚Ä¢ **TQueryFnData** = `unknown`

‚Ä¢ **TError** = `DefaultError`

‚Ä¢ **TData** = `TQueryFnData`

‚Ä¢ **TQueryData** = `TQueryFnData`

‚Ä¢ **TQueryKey** _extends_ `QueryKey` = `QueryKey`
*/
```

----------------------------------------

TITLE: Subscribing to Online State Changes in TanStack Query
DESCRIPTION: Shows how to subscribe to online state changes using the OnlineManager. Returns an unsubscribe function that can be used to clean up the subscription.
SOURCE: https://github.com/tanstack/query/blob/main/docs/reference/onlineManager.md#2025-04-19_snippet_1

LANGUAGE: tsx
CODE:
```
import { onlineManager } from '@tanstack/react-query'

const unsubscribe = onlineManager.subscribe((isOnline) => {
  console.log('isOnline', isOnline)
})
```

----------------------------------------

TITLE: Defining CreateMutateFunction Type Alias in TypeScript
DESCRIPTION: This code snippet defines the CreateMutateFunction type alias. It's a generic type that takes four type parameters (TData, TError, TVariables, and TContext) and returns a function type that accepts variable arguments and returns void.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/type-aliases/createmutatefunction.md#2025-04-19_snippet_0

LANGUAGE: typescript
CODE:
```
type CreateMutateFunction<TData, TError, TVariables, TContext>: (...args) => void;
```

----------------------------------------

TITLE: Page Component with Serialized Data Handling
DESCRIPTION: Next.js page component implementing data serialization during prefetching for non-JSON data types.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/advanced-ssr.md#2025-04-19_snippet_11

LANGUAGE: tsx
CODE:
```
import {
  dehydrate,
  HydrationBoundary,
  QueryClient,
} from '@tanstack/react-query'
import { getQueryClient } from './get-query-client'
import { serialize } from './transformer'
import Posts from './posts'

export default function PostsPage() {
  const queryClient = getQueryClient()

  queryClient.prefetchQuery({
    queryKey: ['posts'],
    queryFn: () => getPosts().then(serialize),
  })

  return (
    <HydrationBoundary state={dehydrate(queryClient)}>
      <Posts />
    </HydrationBoundary>
  )
}
```

----------------------------------------

TITLE: Implementing isIdle Method for Mutation State Narrowing in TypeScript
DESCRIPTION: Type predicate method that narrows a mutation result to the idle state, enabling type-safe access to idle-specific properties.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/interfaces/basemutationnarrowing.md#2025-04-19_snippet_1

LANGUAGE: typescript
CODE:
```
isIdle: (this) => this is CreateMutationResult<TData, TError, TVariables, TContext, Override<MutationObserverIdleResult<TData, TError, TVariables, TContext>, Object> & Object>;
```

----------------------------------------

TITLE: Using matchMutation Utility in TanStack Query
DESCRIPTION: Example of using the matchMutation utility function to check if a mutation matches specified filter conditions.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/filters.md#2025-04-19_snippet_3

LANGUAGE: tsx
CODE:
```
const isMatching = matchMutation(filters, mutation)
```

----------------------------------------

TITLE: Updating React Query Import Path
DESCRIPTION: Shows the required import path change from react-query/react to @tanstack/react-query/reactjs due to directory renaming.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-react-query-4.md#2025-04-19_snippet_11

LANGUAGE: tsx
CODE:
```
- import { QueryClientProvider } from 'react-query/react'; // [!code --]
+ import { QueryClientProvider } from '@tanstack/react-query/reactjs'; // [!code ++]
```

----------------------------------------

TITLE: Custom Error Typing with Generic Parameters
DESCRIPTION: Demonstrates how to specify a custom error type using generic type parameters in injectQuery. The error type is explicitly set to string | null.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/typescript.md#2025-04-19_snippet_5

LANGUAGE: angular-ts
CODE:
```
@Component({
  // ...
  template: `@let error = query.error();`,
  //                ^? error: string | null
})
class MyComponent {
  query = injectQuery<Group[], string>(() => ({
    queryKey: ['groups'],
    queryFn: fetchGroups,
  }))
}
```

----------------------------------------

TITLE: Simplified Global State with TanStack Query
DESCRIPTION: Example showing reduced global state structure after moving server state management to TanStack Query, leaving only client-side state.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/does-this-replace-client-state.md#2025-04-19_snippet_1

LANGUAGE: tsx
CODE:
```
const globalState = {
  themeMode,
  sidebarStatus,
}
```

----------------------------------------

TITLE: Initializing QueryClient in React Query 3
DESCRIPTION: Creates a new QueryClient instance which automatically creates QueryCache and MutationCache instances if not supplied.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-react-query-3.md#2025-04-19_snippet_0

LANGUAGE: tsx
CODE:
```
import { QueryClient } from 'react-query'

const queryClient = new QueryClient()
```

----------------------------------------

TITLE: Initializing QueryClientProvider with React Query
DESCRIPTION: Demonstrates how to set up and implement the QueryClientProvider component to provide a QueryClient instance throughout a React application. The QueryClient instance is created and passed as a required prop to wrap the application components.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/reference/QueryClientProvider.md#2025-04-19_snippet_0

LANGUAGE: tsx
CODE:
```
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'

const queryClient = new QueryClient()

function App() {
  return <QueryClientProvider client={queryClient}>...</QueryClientProvider>
}
```

----------------------------------------

TITLE: Wrapping Component with Suspense in Solid
DESCRIPTION: This snippet demonstrates how to wrap a suspendable component with Solid's Suspense component. It uses a LoadingSpinner as a fallback while the suspendable component is loading.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/solid/guides/suspense.md#2025-04-19_snippet_0

LANGUAGE: tsx
CODE:
```
import { Suspense } from 'solid-js'
;<Suspense fallback={<LoadingSpinner />}>
  <SuspendableComponent />
</Suspense>
```

----------------------------------------

TITLE: Using Async/Await with Mutations
DESCRIPTION: Shows how to use the new mutateAsync function with async/await pattern for handling mutations.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-react-query-3.md#2025-04-19_snippet_6

LANGUAGE: tsx
CODE:
```
const { mutateAsync } = useMutation({ mutationFn: addTodo })

try {
  const data = await mutateAsync('todo')
  console.log(data)
} catch (error) {
  console.error(error)
} finally {
  console.log('settled')
}
```

----------------------------------------

TITLE: Ensuring Infinite Query Data
DESCRIPTION: Demonstrates ensuring infinite query data is available with pagination parameters.
SOURCE: https://github.com/tanstack/query/blob/main/docs/reference/QueryClient.md#2025-04-19_snippet_9

LANGUAGE: tsx
CODE:
```
const data = await queryClient.ensureInfiniteQueryData({
  queryKey,
  queryFn,
  initialPageParam,
  getNextPageParam,
})
```

----------------------------------------

TITLE: Combining Custom QueryClient with Custom Context Key
DESCRIPTION: Demonstrates how to use both a custom QueryClient instance and a custom context key together.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/custom-client.md#2025-04-19_snippet_3

LANGUAGE: tsx
CODE:
```
const myClient = new QueryClient(queryClientConfig)
const vueQueryPluginOptions: VueQueryPluginOptions = {
  queryClient: myClient,
  queryClientKey: 'Foo',
}
app.use(VueQueryPlugin, vueQueryPluginOptions)
```

----------------------------------------

TITLE: Implementing Query Functions with Parameter Access in TanStack Query
DESCRIPTION: Shows how to define a query with parameters and access those parameters within the query function using destructuring. The example demonstrates passing status and page parameters through the queryKey and accessing them in the fetchTodoList function.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/query-functions.md#2025-04-19_snippet_0

LANGUAGE: javascript
CODE:
```
const result = useQuery({
  queryKey: ['todos', { status, page }],
  queryFn: fetchTodoList,
})

// Access the key, status and page variables in your query function!
function fetchTodoList({ queryKey }) {
  const [_key, { status, page }] = queryKey
  return new Promise()
}
```

----------------------------------------

TITLE: Injecting Mutation Counter Signal in Angular
DESCRIPTION: A function that creates a signal tracking the number of active mutations in an Angular application. Takes optional mutation filters and an Angular injector as parameters. Returns a signal containing the count of currently fetching mutations. Useful for implementing application-wide loading indicators.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/functions/injectismutating.md#2025-04-19_snippet_0

LANGUAGE: typescript
CODE:
```
function injectIsMutating(filters?, injector?): Signal<number>
```

----------------------------------------

TITLE: Declaring createQueries Function Signature in TypeScript
DESCRIPTION: Function signature for createQueries that handles multiple query creation. It accepts generic type parameters T and TCombinedResult, takes named parameters and an optional queryClient, and returns a Svelte Readable store containing the combined query results.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/reference/functions/createqueries.md#2025-04-19_snippet_0

LANGUAGE: typescript
CODE:
```
function createQueries<T, TCombinedResult>(
  __namedParameters,
  queryClient?,
): Readable<TCombinedResult>
```

----------------------------------------

TITLE: Configuring Vue Query Plugin for Nuxt 2
DESCRIPTION: This snippet shows how to set up the Vue Query plugin for Nuxt 2, including handling of server-side and client-side initialization, and hydration of query state.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/ssr.md#2025-04-19_snippet_2

LANGUAGE: javascript
CODE:
```
import Vue from 'vue'
import { VueQueryPlugin, QueryClient, hydrate } from '@tanstack/vue-query'

export default (context) => {
  // Modify your Vue Query global settings here
  const queryClient = new QueryClient({
    defaultOptions: { queries: { staleTime: 5000 } },
  })

  if (process.server) {
    context.ssrContext.VueQuery = queryClient
  }

  if (process.client) {
    Vue.use(VueQueryPlugin, { queryClient })

    if (context.nuxtState && context.nuxtState.vueQueryState) {
      hydrate(queryClient, context.nuxtState.vueQueryState)
    }
  }
}
```

----------------------------------------

TITLE: Implementing Query Loading Tracker in TypeScript
DESCRIPTION: Function that injects a signal tracking the number of active loading/fetching queries in an Angular application. Takes optional query filters and injector parameters, returning a numeric signal that can be used for implementing application-wide loading indicators.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/functions/injectisfetching.md#2025-04-19_snippet_0

LANGUAGE: typescript
CODE:
```
function injectIsFetching(filters?, injector?): Signal<number>
```

----------------------------------------

TITLE: isPending Method for Query Status Checking in TypeScript
DESCRIPTION: The isPending method checks if a query is in a pending state and provides type narrowing to a pending result type. It takes the current instance as a parameter and returns a type predicate that narrows the type to a pending result.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/interfaces/basequerynarrowing.md#2025-04-19_snippet_1

LANGUAGE: typescript
CODE:
```
isPending: (this) => this is CreateBaseQueryResult<TData, TError, CreateStatusBasedQueryResult<"pending", TData, TError>>;
```

----------------------------------------

TITLE: Declaring provideQueryClient Function in TypeScript
DESCRIPTION: Function signature for provideQueryClient that accepts either a QueryClient instance or a factory function returning QueryClient, and returns a Provider. Used to provide custom QueryClient instances for specific parts of an Angular application.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/functions/providequeryclient.md#2025-04-19_snippet_0

LANGUAGE: typescript
CODE:
```
function provideQueryClient(value): Provider
```

----------------------------------------

TITLE: PlaceholderData Identity Function Example
DESCRIPTION: Demonstrates the usage of an identity function with placeholderData to maintain previous query data, showing the function signature with previousData and previousQuery parameters.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-v5.md#2025-04-19_snippet_10

LANGUAGE: ts
CODE:
```
useQuery({
  queryKey,
  queryFn,
  placeholderData: (previousData, previousQuery) => previousData, // identity function with the same behaviour as `keepPreviousData`
})
```

----------------------------------------

TITLE: Manual Type Assertion for Query Data
DESCRIPTION: Demonstrates the traditional way of typing query data using generic type parameters with queryClient methods, which is necessary when not using queryOptions.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/typescript.md#2025-04-19_snippet_10

LANGUAGE: ts
CODE:
```
data = queryClient.getQueryData<Post>(['post', 1])
```

----------------------------------------

TITLE: Manually Setting Online State in TanStack Query
DESCRIPTION: Demonstrates how to manually control the online state using setOnline method. Shows examples of setting both online and offline states.
SOURCE: https://github.com/tanstack/query/blob/main/docs/reference/onlineManager.md#2025-04-19_snippet_2

LANGUAGE: tsx
CODE:
```
import { onlineManager } from '@tanstack/react-query'

// Set to online
onlineManager.setOnline(true)

// Set to offline
onlineManager.setOnline(false)
```

----------------------------------------

TITLE: Auto-loading Devtools Configuration
DESCRIPTION: Demonstrates explicit auto-loading configuration for devtools, which is equivalent to the default behavior.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/devtools.md#2025-04-19_snippet_1

LANGUAGE: typescript
CODE:
```
provideTanStackQuery(new QueryClient(), withDevtools())

// which is equivalent to
provideTanStackQuery(
  new QueryClient(),
  withDevtools(() => ({ loadDevtools: 'auto' })),
)
```

----------------------------------------

TITLE: Incorrect usage of query function returning void in TanStack Query
DESCRIPTION: This example shows a query function that incorrectly doesn't return the fetched data, which would lead to unexpected behavior as TanStack Query won't have any data to cache.
SOURCE: https://github.com/tanstack/query/blob/main/docs/eslint/no-void-query-fn.md#2025-04-19_snippet_0

LANGUAGE: tsx
CODE:
```
/* eslint "@tanstack/query/no-void-query-fn": "error" */

useQuery({
  queryKey: ['todos'],
  queryFn: async () => {
    await api.todos.fetch() // Function doesn't return the fetched data
  },
})
```

----------------------------------------

TITLE: Initializing Vue Query with Custom QueryClientConfig
DESCRIPTION: Shows how to initialize Vue Query plugin with custom QueryClientConfig options, setting default query options like staleTime.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/custom-client.md#2025-04-19_snippet_0

LANGUAGE: tsx
CODE:
```
const vueQueryPluginOptions: VueQueryPluginOptions = {
  queryClientConfig: {
    defaultOptions: { queries: { staleTime: 3600 } },
  },
}
app.use(VueQueryPlugin, vueQueryPluginOptions)
```

----------------------------------------

TITLE: Retry Delay Function Example
DESCRIPTION: Example of an exponential backoff implementation for retry delay calculation.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/solid/reference/useQuery.md#2025-04-19_snippet_5

LANGUAGE: typescript
CODE:
```
attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000)
```

----------------------------------------

TITLE: useQueries API Update
DESCRIPTION: Changes to the useQueries hook API structure.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-react-query-4.md#2025-04-19_snippet_6

LANGUAGE: typescript
CODE:
```
-useQueries([
  { queryKey1, queryFn1, options1 },
  { queryKey2, queryFn2, options2 },
])
+useQueries({
  queries: [
    { queryKey1, queryFn1, options1 },
    { queryKey2, queryFn2, options2 },
  ],
})
```

----------------------------------------

TITLE: Ensuring Query Data Availability
DESCRIPTION: Shows how to ensure query data is available, fetching if necessary.
SOURCE: https://github.com/tanstack/query/blob/main/docs/reference/QueryClient.md#2025-04-19_snippet_8

LANGUAGE: tsx
CODE:
```
const data = await queryClient.ensureQueryData({ queryKey, queryFn })
```

----------------------------------------

TITLE: Defining Query Options in TanStack Query with TypeScript
DESCRIPTION: This code snippet demonstrates the structure of the QueryOptions type in TanStack Query. It includes various configuration options for queries, such as queryKey, queryFn, gcTime, and more. These options allow fine-tuning of query behavior and caching strategies.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/reference/queryOptions.md#2025-04-19_snippet_0

LANGUAGE: typescript
CODE:
```
export interface QueryOptions<
  TQueryFnData = unknown,
  TError = DefaultError,
  TData = TQueryFnData,
  TQueryKey extends QueryKey = QueryKey
> extends WithRequired<QueryObserverOptions<TQueryFnData, TError, TData, TQueryFnData, TQueryKey>, 'queryKey'> {
  /** Defaults to 5 * 60 * 1000 (5 minutes) */
  gcTime?: number
}
```

----------------------------------------

TITLE: Registering Global Query and Mutation Key Types in React Query (TypeScript)
DESCRIPTION: Shows how to register global QueryKey and MutationKey types in React Query for improved type safety.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/typescript.md#2025-04-19_snippet_9

LANGUAGE: ts
CODE:
```
import '@tanstack/react-query'

type QueryKey = ['dashboard' | 'marketing', ...ReadonlyArray<unknown>]

declare module '@tanstack/react-query' {
  interface Register {
    queryKey: QueryKey
    mutationKey: QueryKey
  }
}
```

----------------------------------------

TITLE: Implementing InfiniteQueryOptions with Defined Initial Data in TypeScript
DESCRIPTION: Function implementation for handling infinite query options with defined initial data. Similar to the undefined variant but works with DefinedInitialDataInfiniteOptions. Takes the same generic type parameters and returns tagged infinite query options.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/functions/infinitequeryoptions.md#2025-04-19_snippet_1

LANGUAGE: typescript
CODE:
```
function infiniteQueryOptions<
  TQueryFnData,
  TError,
  TData,
  TQueryKey,
  TPageParam,
>(
  options,
): DefinedInitialDataInfiniteOptions<
  TQueryFnData,
  TError,
  TData,
  TQueryKey,
  TPageParam
> &
  object
```

----------------------------------------

TITLE: Persister Options Interface
DESCRIPTION: Interface defining all available options for createSyncStoragePersister configuration.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/plugins/createSyncStoragePersister.md#2025-04-19_snippet_3

LANGUAGE: tsx
CODE:
```
interface CreateSyncStoragePersisterOptions {
  /** The storage client used for setting an retrieving items from cache (window.localStorage or window.sessionStorage) */
  storage: Storage | undefined | null
  /** The key to use when storing the cache */
  key?: string
  /** To avoid spamming,
   * pass a time in ms to throttle saving the cache to disk */
  throttleTime?: number
  /** How to serialize the data to storage */
  serialize?: (client: PersistedClient) => string
  /** How to deserialize the data from storage */
  deserialize?: (cachedString: string) => PersistedClient
  /** How to retry persistence on error **/
  retry?: PersistRetryer
}
```

----------------------------------------

TITLE: Reactive Query Implementation Using Svelte Stores
DESCRIPTION: Correct implementation using Svelte stores to create a reactive query where refetchInterval updates automatically when the input value changes. Uses derived stores to ensure proper reactivity of query options.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/reactivity.md#2025-04-19_snippet_1

LANGUAGE: svelte
CODE:
```
<script lang="ts">
  import { derived, writable } from 'svelte/store'
  import { createQuery } from '@tanstack/svelte-query'

  const endpoint = 'http://localhost:5173/api/data'

  const intervalMs = writable(1000)

  const query = createQuery(
    derived(intervalMs, ($intervalMs) => ({
      queryKey: ['refetch'],
      queryFn: async () => await fetch(endpoint).then((r) => r.json()),
      refetchInterval: $intervalMs,
    })),
  )
</script>

<input type="number" bind:value={$intervalMs} />
```

----------------------------------------

TITLE: Defining provideAngularQuery Function in TypeScript
DESCRIPTION: Function signature for provideAngularQuery, which takes a QueryClient and returns EnvironmentProviders for setting up TanStack Query in Angular applications.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/functions/provideangularquery.md#2025-04-19_snippet_0

LANGUAGE: typescript
CODE:
```
function provideAngularQuery(queryClient): EnvironmentProviders
```

----------------------------------------

TITLE: Defining injectMutation Function in TypeScript for TanStack Query Angular
DESCRIPTION: Function signature for injectMutation that accepts options and an optional injector to create a mutation in Angular applications. It handles side effects like data updates to the server and returns a CreateMutationResult object.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/functions/injectmutation.md#2025-04-19_snippet_0

LANGUAGE: typescript
CODE:
```
function injectMutation<TData, TError, TVariables, TContext>(
  optionsFn,
  injector?,
): CreateMutationResult<TData, TError, TVariables, TContext>
```

----------------------------------------

TITLE: Type Inference with Data Transformation in React Query (TypeScript)
DESCRIPTION: Illustrates type inference when using a select function to transform query results.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/typescript.md#2025-04-19_snippet_1

LANGUAGE: tsx
CODE:
```
const { data } = useQuery({
  //      ^? const data: string | undefined
  queryKey: ['test'],
  queryFn: () => Promise.resolve(5),
  select: (data) => data.toString(),
})
```

----------------------------------------

TITLE: Basic Query Injection in Angular
DESCRIPTION: Shows a simplified version of injecting a query to fetch a list of todos. This snippet focuses on the core functionality without the class declaration.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/queries.md#2025-04-19_snippet_1

LANGUAGE: typescript
CODE:
```
result = injectQuery(() => ({ queryKey: ['todos'], queryFn: fetchTodoList }))
```

----------------------------------------

TITLE: Configuring Custom Scheduler in NotifyManager
DESCRIPTION: Examples of setting up different scheduling strategies including microtasks, animation frames, and delayed execution.
SOURCE: https://github.com/tanstack/query/blob/main/docs/reference/notifyManager.md#2025-04-19_snippet_5

LANGUAGE: typescript
CODE:
```
import { notifyManager } from '@tanstack/react-query'

// Schedule batches in the next microtask
notifyManager.setScheduler(queueMicrotask)

// Schedule batches before the next frame is rendered
notifyManager.setScheduler(requestAnimationFrame)

// Schedule batches some time in the future
notifyManager.setScheduler((cb) => setTimeout(cb, 10))
```

----------------------------------------

TITLE: Configuring TanStack Query Client with SSR in SvelteKit Layout
DESCRIPTION: Sets up the QueryClient in the root layout with SSR-aware configuration using SvelteKit's browser module to disable queries on the server.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/ssr.md#2025-04-19_snippet_0

LANGUAGE: svelte
CODE:
```
<script lang="ts">
  import { browser } from '$app/environment'
  import { QueryClient, QueryClientProvider } from '@tanstack/svelte-query'

  const queryClient = new QueryClient({
    defaultOptions: {
      queries: {
        enabled: browser,
      },
    },
  })
</script>

<QueryClientProvider client={queryClient}>
  <slot />
</QueryClientProvider>
```

----------------------------------------

TITLE: Checking Current Focus State in TanStack Query
DESCRIPTION: Shows how to use focusManager.isFocused to get the current focus state in TanStack Query.
SOURCE: https://github.com/tanstack/query/blob/main/docs/reference/focusManager.md#2025-04-19_snippet_3

LANGUAGE: tsx
CODE:
```
const isFocused = focusManager.isFocused()
```

----------------------------------------

TITLE: Basic Custom Hook Implementation
DESCRIPTION: Simple custom hook example using React Query to fetch data.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/testing.md#2025-04-19_snippet_1

LANGUAGE: tsx
CODE:
```
export function useCustomHook() {
  return useQuery({ queryKey: ['customHook'], queryFn: () => 'Hello' })
}
```

----------------------------------------

TITLE: Basic Vue Query Implementation (Non-Reactive)
DESCRIPTION: Initial implementation of a user projects query that doesn't properly handle reactivity due to direct value extraction from ref.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/reactivity.md#2025-04-19_snippet_0

LANGUAGE: typescript
CODE:
```
export function useUserProjects(userId: string) {
  return useQuery(
    queryKey: ['userProjects', userId],
    queryFn: () => api.fetchUserProjects(userId),
  );
}
```

----------------------------------------

TITLE: Using provideAngularQuery in Standalone Angular Application
DESCRIPTION: Example of how to use provideAngularQuery in a standalone Angular application, importing necessary modules and bootstrapping the application with the provided QueryClient.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/functions/provideangularquery.md#2025-04-19_snippet_1

LANGUAGE: typescript
CODE:
```
import {
  provideAngularQuery,
  QueryClient,
} from '@tanstack/angular-query-experimental'

bootstrapApplication(AppComponent, {
  providers: [provideAngularQuery(new QueryClient())],
})
```

----------------------------------------

TITLE: Configuring Re-renders with notifyOnChangeProps in React Query
DESCRIPTION: This example shows how to use the new notifyOnChangeProps option to control when a component should re-render based on specific property changes.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-react-query-3.md#2025-04-19_snippet_8

LANGUAGE: tsx
CODE:
```
import { useQuery } from 'react-query'

function User() {
  const { data } = useQuery(['user'], fetchUser, {
    notifyOnChangeProps: ['data', 'error'],
  })
  return <div>Username: {data.username}</div>
}
```

----------------------------------------

TITLE: Optimized Query Data Updates with Undefined Handling
DESCRIPTION: Demonstrates how to conditionally update query data using setQueryData with undefined return to bail out of updates when no cached entry exists.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-react-query-4.md#2025-04-19_snippet_12

LANGUAGE: tsx
CODE:
```
queryClient.setQueryData(['todo', id], (previousTodo) =>
  previousTodo ? { ...previousTodo, done: true } : undefined,
)
```

----------------------------------------

TITLE: Retrieving All Mutations from Cache in TypeScript
DESCRIPTION: Demonstrates how to retrieve all mutation instances stored in the mutation cache using the getAll method.
SOURCE: https://github.com/tanstack/query/blob/main/docs/reference/MutationCache.md#2025-04-19_snippet_1

LANGUAGE: tsx
CODE:
```
const mutations = mutationCache.getAll()
```

----------------------------------------

TITLE: Defining DefinedInitialDataOptions Type Alias in TypeScript
DESCRIPTION: This snippet defines the DefinedInitialDataOptions type alias, which extends CreateQueryOptions and includes an initialData property. It is used for specifying options with defined initial data in TanStack Query.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/reference/type-aliases/definedinitialdataoptions.md#2025-04-19_snippet_0

LANGUAGE: TypeScript
CODE:
```
type DefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey>: CreateQueryOptions<TQueryFnData, TError, TData, TQueryKey> & object;
```

----------------------------------------

TITLE: Using Custom Client Key in Query Hook
DESCRIPTION: Shows how to use the custom client key when making queries with the useQuery hook.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/custom-client.md#2025-04-19_snippet_4

LANGUAGE: js
CODE:
```
useQuery({
  queryKey: ['query1'],
  queryFn: fetcher,
  queryClientKey: 'foo',
})
```

----------------------------------------

TITLE: Using Objects in Query Keys for TanStack Query (TypeScript)
DESCRIPTION: This snippet demonstrates the use of objects within query keys to include multiple parameters. It shows how the order of properties in the object doesn't affect the query key equality.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/query-keys.md#2025-04-19_snippet_2

LANGUAGE: typescript
CODE:
```
injectQuery(() => ({ queryKey: ['todos', { status, page }], ... }))
injectQuery(() => ({ queryKey: ['todos', { page, status }], ...}))
injectQuery(() => ({ queryKey: ['todos', { page, status, other: undefined }], ... }))
```

----------------------------------------

TITLE: Implementing injectInfiniteQuery with Generic Return Type in Angular
DESCRIPTION: This function implementation injects an infinite query for asynchronous data loading with additive 'load more' capability. It accepts a function that returns query options and an optional Angular injector. Returns a CreateInfiniteQueryResult.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/functions/injectinfinitequery.md#2025-04-19_snippet_0

LANGUAGE: typescript
CODE:
```
function injectInfiniteQuery<
  TQueryFnData,
  TError,
  TData,
  TQueryKey,
  TPageParam,
>(optionsFn, injector?): CreateInfiniteQueryResult<TData, TError>
```

----------------------------------------

TITLE: Default Error Typing in React Query (TypeScript)
DESCRIPTION: Illustrates the default Error type used in React Query for the error field.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/typescript.md#2025-04-19_snippet_4

LANGUAGE: tsx
CODE:
```
const { error } = useQuery({ queryKey: ['groups'], queryFn: fetchGroups })
//      ^? const error: Error
```

----------------------------------------

TITLE: Configuring Window Focus Refetching in TanStack Vue Query
DESCRIPTION: This code snippet illustrates how to configure VueQueryPluginOptions to disable the default window focus refetching behavior in TanStack Vue Query. It sets the refetchOnWindowFocus option to false within the queryClientConfig.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/window-focus-refetching.md#2025-04-19_snippet_0

LANGUAGE: javascript
CODE:
```
const vueQueryPluginOptions: VueQueryPluginOptions = {
  queryClientConfig: {
    defaultOptions: {
      queries: {
        refetchOnWindowFocus: false,
      },
    },
  },
}
app.use(VueQueryPlugin, vueQueryPluginOptions)
```

----------------------------------------

TITLE: Implementing Batch Processing in Tanstack Query
DESCRIPTION: Definition of the batch method used to combine multiple updates into a single batch operation. This is primarily used internally for optimizing queryClient updates.
SOURCE: https://github.com/tanstack/query/blob/main/docs/reference/notifyManager.md#2025-04-19_snippet_0

LANGUAGE: typescript
CODE:
```
function batch<T>(callback: () => T): T
```

----------------------------------------

TITLE: Multiple Provider Integration Example
DESCRIPTION: Shows how to compose multiple QueryClient providers with different contexts in a nested component structure.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-react-query-4.md#2025-04-19_snippet_15

LANGUAGE: tsx
CODE:
```
import { ContainerDataProvider, useUser } from "@my-scope/container-data";
import { AppDataProvider } from "@my-scope/app-data";
import { MyComponentDataProvider, useItems } from "@my-scope/my-component-data";

<ContainerDataProvider> // <-- Provides container data (like "user") using its own React Query provider
  ...
  <AppDataProvider> // <-- Provides app data using its own React Query provider (unused in this example)
    ...
      <MyComponentDataProvider> // <-- Provides component data (like "items") using its own React Query provider
        <MyComponent />
      </MyComponentDataProvider>
    ...
  </AppDataProvider>
  ...
</ContainerDataProvider>

// Example of hooks provided by the "DataProvider" components above:
const MyComponent = () => {
  const user = useUser() // <-- Uses the context specified in ContainerDataProvider.
  const items = useItems() // <-- Uses the context specified in MyComponentDataProvider
  ...
}
```

----------------------------------------

TITLE: Correct Usage of Destructured Query Hook Result in React Hook Dependency Array
DESCRIPTION: This example shows the correct approach of destructuring the 'mutate' function from the useMutation result and using only that specific value in the useCallback dependency array, which maintains referential stability.
SOURCE: https://github.com/tanstack/query/blob/main/docs/eslint/no-unstable-deps.md#2025-04-19_snippet_1

LANGUAGE: tsx
CODE:
```
/* eslint "@tanstack/query/no-unstable-deps": "warn" */
import { useCallback } from 'React'
import { useMutation } from '@tanstack/react-query'

function Component() {
  const { mutate } = useMutation({ mutationFn: (value: string) => value })
  const callback = useCallback(() => {
    mutate('hello')
  }, [mutate])
  return null
}
```

----------------------------------------

TITLE: Incorrect Usage of Object Rest Destructuring with useQuery in React Query
DESCRIPTION: This example demonstrates incorrect usage of object rest destructuring with the useQuery hook, which causes the component to subscribe to all fields of the query result, potentially leading to unnecessary re-renders.
SOURCE: https://github.com/tanstack/query/blob/main/docs/eslint/no-rest-destructuring.md#2025-04-19_snippet_0

LANGUAGE: tsx
CODE:
```
/* eslint "@tanstack/query/no-rest-destructuring": "warn" */

const useTodos = () => {
  const { data: todos, ...rest } = useQuery({
    queryKey: ['todos'],
    queryFn: () => api.getTodos(),
  })
  return { todos, ...rest }
}
```

----------------------------------------

TITLE: Configuring Query Options with Defined Initial Data
DESCRIPTION: Function overload for configuring query options when initial data is defined. Takes generic type parameters for query function data, error type, transformed data, and query key. Returns enhanced options object.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/reference/functions/queryoptions.md#2025-04-19_snippet_0

LANGUAGE: typescript
CODE:
```
function queryOptions<TQueryFnData, TError, TData, TQueryKey>(
  options,
): DefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey> & object
```

----------------------------------------

TITLE: Defining DefinedInitialDataOptions Type Alias in TypeScript
DESCRIPTION: Type alias declaration that extends CreateQueryOptions with a constraint ensuring initial data is defined. This type enforces that queries using this option will always have non-undefined initial data available.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/type-aliases/definedinitialdataoptions.md#2025-04-19_snippet_0

LANGUAGE: typescript
CODE:
```
type DefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey>: CreateQueryOptions<TQueryFnData, TError, TData, TQueryKey> & object;
```

----------------------------------------

TITLE: Custom Context Data Package Implementation
DESCRIPTION: Shows the implementation of a data package with custom context for QueryClient provider to enable multiple provider instances.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-react-query-4.md#2025-04-19_snippet_13

LANGUAGE: tsx
CODE:
```
const context = React.createContext<QueryClient | undefined>(undefined)
const queryClient = new QueryClient()

export const useUser = () => {
  return useQuery(USER_KEY, USER_FETCHER, {
    context,
  })
}

export const ContainerDataProvider = ({
  children,
}: {
  children: React.ReactNode
}) => {
  return (
    <QueryClientProvider client={queryClient} context={context}>
      {children}
    </QueryClientProvider>
  )
}
```

----------------------------------------

TITLE: SolidJS Query with Suspense Integration
DESCRIPTION: Demonstrates how to use SolidJS Suspense boundaries with TanStack Query for loading states.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/solid/quick-start.md#2025-04-19_snippet_1

LANGUAGE: tsx
CODE:
```
import { For, Suspense } from 'solid-js'

function Example() {
  const query = useQuery(() => ({
    queryKey: ['todos'],
    queryFn: fetchTodos,
  }))
  return (
    <div>
      <Suspense fallback={'Loading...'}>
        <For each={query.data}>{(todo) => <div>{todo.title}</div>}</For>
      </Suspense>
      <For each={query.data}>{(todo) => <div>{todo.title}</div>}</For>
    </div>
  )
}
```

----------------------------------------

TITLE: Updating QueryClient Logger Configuration in TypeScript
DESCRIPTION: This code shows how to configure a custom logger for QueryClient in v4, replacing the global setLogger function with a configuration option.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-react-query-4.md#2025-04-19_snippet_10

LANGUAGE: tsx
CODE:
```
- import { QueryClient, setLogger } from 'react-query'; // [!code --]
+ import { QueryClient } from '@tanstack/react-query'; // [!code ++]

- setLogger(customLogger) // [!code --]
- const queryClient = new QueryClient(); // [!code --]
+ const queryClient = new QueryClient({ logger: customLogger }) // [!code ++]
```

----------------------------------------

TITLE: Undefined Initial Data Query Creation - TypeScript
DESCRIPTION: Function overload for creating a query with undefined initial data. Takes the same generic type parameters but returns a CreateQueryResult instead of DefinedCreateQueryResult.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/reference/functions/createquery.md#2025-04-19_snippet_1

LANGUAGE: typescript
CODE:
```
function createQuery<TQueryFnData, TError, TData, TQueryKey>(
  options,
  queryClient?,
): CreateQueryResult<TData, TError>
```

----------------------------------------

TITLE: Installing Vue Query Devtools Package
DESCRIPTION: Various package manager commands to install the @tanstack/vue-query-devtools package.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/devtools.md#2025-04-19_snippet_0

LANGUAGE: bash
CODE:
```
npm i @tanstack/vue-query-devtools
```

LANGUAGE: bash
CODE:
```
pnpm add @tanstack/vue-query-devtools
```

LANGUAGE: bash
CODE:
```
yarn add @tanstack/vue-query-devtools
```

LANGUAGE: bash
CODE:
```
bun add @tanstack/vue-query-devtools
```

----------------------------------------

TITLE: Getting Multiple Queries Data
DESCRIPTION: Shows how to retrieve cached data for multiple queries using filters.
SOURCE: https://github.com/tanstack/query/blob/main/docs/reference/QueryClient.md#2025-04-19_snippet_10

LANGUAGE: tsx
CODE:
```
const data = queryClient.getQueriesData(filters)
```

----------------------------------------

TITLE: Defining Query Key Replacements in YAML
DESCRIPTION: YAML configuration that specifies replacements for converting React Query syntax to Solid Query syntax, including mutations, queries, and infinite queries.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/solid/guides/query-keys.md#2025-04-19_snippet_0

LANGUAGE: yaml
CODE:
```
---
id: query-keys
title: Query Keys
ref: docs/framework/react/guides/query-keys.md
replace:
  {
    '@tanstack/react-query': '@tanstack/solid-query',
    'useMutationState[(]': 'useMutationState(() => ',
    'useMutation[(]': 'useMutation(() => ',
    'useQuery[(]': 'useQuery(() => ',
    'useQueries[(]': 'useQueries(() => ',
    'useInfiniteQuery[(]': 'useInfiniteQuery(() => ',
  }
---
```

----------------------------------------

TITLE: Defining injectQueries Function Signature in TypeScript
DESCRIPTION: Function signature for injectQueries that allows injecting multiple queries in Angular components. It takes named parameters with queries and an optional combine function, along with an optional injector parameter, and returns a Signal with the combined query results.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/functions/injectqueries.md#2025-04-19_snippet_0

LANGUAGE: typescript
CODE:
```
function injectQueries<T, TCombinedResult>(
  __namedParameters,
  injector?,
): Signal<TCombinedResult>
```

----------------------------------------

TITLE: Type Narrowing with Status Checks
DESCRIPTION: Shows how to narrow types using status check methods like isSuccess(). When the query is successful, the data type is narrowed from number | undefined to just number.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/typescript.md#2025-04-19_snippet_3

LANGUAGE: angular-ts
CODE:
```
@Component({
  // ...
  template: `
    @if (query.isSuccess()) {
      @let data = query.data();
      //    ^? data: number
    }
  `,
})
class MyComponent {
  query = injectQuery(() => ({
    queryKey: ['test'],
    queryFn: () => Promise.resolve(5),
  }))
}
```

----------------------------------------

TITLE: Subscribing to MutationCache Updates in TypeScript
DESCRIPTION: Shows how to subscribe to mutation cache events using the subscribe method, which provides notifications about cache updates, mutations state changes, and other events.
SOURCE: https://github.com/tanstack/query/blob/main/docs/reference/MutationCache.md#2025-04-19_snippet_2

LANGUAGE: tsx
CODE:
```
const callback = (event) => {
  console.log(event.type, event.mutation)
}

const unsubscribe = mutationCache.subscribe(callback)
```

----------------------------------------

TITLE: Infinite Query Prefetching in TanStack Query
DESCRIPTION: Shows how to prefetch infinite queries with multiple pages using queryClient.prefetchInfiniteQuery(). Includes configuration for initial page parameter, next page calculation, and number of pages to prefetch.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/prefetching.md#2025-04-19_snippet_1

LANGUAGE: tsx
CODE:
```
const prefetchProjects = async () => {
  // The results of this query will be cached like a normal query
  await queryClient.prefetchInfiniteQuery({
    queryKey: ['projects'],
    queryFn: fetchProjects,
    initialPageParam: 0,
    getNextPageParam: (lastPage, pages) => lastPage.nextCursor,
    pages: 3, // prefetch the first 3 pages
  })
}
```

----------------------------------------

TITLE: Injecting QueryClient without Parameters in TypeScript
DESCRIPTION: This function signature shows how to use injectQueryClient without any parameters to inject the QueryClient instance.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/functions/injectqueryclient.md#2025-04-19_snippet_1

LANGUAGE: typescript
CODE:
```
function injectQueryClient(): QueryClient
```

----------------------------------------

TITLE: Persister Interface Type Definitions
DESCRIPTION: TypeScript interface definitions for implementing custom persisters and the persisted client data structure.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/plugins/persistQueryClient.md#2025-04-19_snippet_2

LANGUAGE: typescript
CODE:
```
export interface Persister {
  persistClient(persistClient: PersistedClient): Promisable<void>
  restoreClient(): Promisable<PersistedClient | undefined>
  removeClient(): Promisable<void>
}

export interface PersistedClient {
  timestamp: number
  buster: string
  cacheState: any
}
```

----------------------------------------

TITLE: Accessing Query Cache with getQueryCache in TanStack Query
DESCRIPTION: The getQueryCache method returns the query cache instance that the client is connected to, providing access to the underlying cache mechanisms.
SOURCE: https://github.com/tanstack/query/blob/main/docs/reference/QueryClient.md#2025-04-19_snippet_27

LANGUAGE: tsx
CODE:
```
const queryCache = queryClient.getQueryCache()
```

----------------------------------------

TITLE: Enabling Traditional Vue Devtools Integration
DESCRIPTION: Configuration code to enable Vue Query integration with official Vue devtools through plugin options.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/devtools.md#2025-04-19_snippet_2

LANGUAGE: typescript
CODE:
```
app.use(VueQueryPlugin, {
  enableDevtoolsV6Plugin: true,
})
```

----------------------------------------

TITLE: Defining NonUndefinedGuard Generic Type in TypeScript
DESCRIPTION: A TypeScript utility type that uses conditional type checking to ensure a type T cannot be undefined. If T extends undefined, the type resolves to never, otherwise it resolves to T.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/type-aliases/nonundefinedguard.md#2025-04-19_snippet_0

LANGUAGE: typescript
CODE:
```
type NonUndefinedGuard<T>: T extends undefined ? never : T;
```

----------------------------------------

TITLE: Updating QueryStatus Checks in React Query v3
DESCRIPTION: This snippet illustrates the change from using enum values to string literals when checking QueryStatus in React Query v3.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-react-query-3.md#2025-04-19_snippet_11

LANGUAGE: tsx
CODE:
```
- import { useQuery, QueryStatus } from 'react-query'; // [!code --]
+ import { useQuery } from 'react-query'; // [!code ++]

const { data, status } = useQuery(['post', id], () => fetchPost(id))

- if (status === QueryStatus.Loading) { // [!code --]
+ if (status === 'loading') { // [!code ++]
  ...
}

- if (status === QueryStatus.Error) { // [!code --]
+ if (status === 'error') { // [!code ++]
  ...
}
```

----------------------------------------

TITLE: Network Mode Type Definition in TypeScript
DESCRIPTION: Type signature for the networkMode configuration option in TanStack Query, showing the three possible values and default setting.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/network-mode.md#2025-04-19_snippet_0

LANGUAGE: typescript
CODE:
```
networkMode: 'online' | 'always' | 'offlineFirst'
```

----------------------------------------

TITLE: Prefetching and Fetching Queries
DESCRIPTION: Demonstrates the new methods for prefetching and fetching queries using QueryClient.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-react-query-3.md#2025-04-19_snippet_3

LANGUAGE: tsx
CODE:
```
// Prefetch a query:
await queryClient.prefetchQuery('posts', fetchPosts)

// Fetch a query:
try {
  const data = await queryClient.fetchQuery('posts', fetchPosts)
} catch (error) {
  // Error handling
}
```

----------------------------------------

TITLE: Retrieving Mutation Default Options with getMutationDefaults in TanStack Query
DESCRIPTION: The getMutationDefaults method returns the default options which have been set for specific mutations based on their mutation key.
SOURCE: https://github.com/tanstack/query/blob/main/docs/reference/QueryClient.md#2025-04-19_snippet_25

LANGUAGE: tsx
CODE:
```
const defaultOptions = queryClient.getMutationDefaults(['addPost'])
```

----------------------------------------

TITLE: Installing Vue Query via NPM
DESCRIPTION: This snippet shows how to install Vue Query using NPM package manager.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/installation.md#2025-04-19_snippet_0

LANGUAGE: bash
CODE:
```
npm i @tanstack/vue-query
```

----------------------------------------

TITLE: Configuring QueryClient with Extended Garbage Collection Time
DESCRIPTION: Example showing how to configure a QueryClient instance with extended garbage collection time to properly work with persistence.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/plugins/persistQueryClient.md#2025-04-19_snippet_0

LANGUAGE: tsx
CODE:
```
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      gcTime: 1000 * 60 * 60 * 24, // 24 hours
    },
  },
})
```

----------------------------------------

TITLE: Checking for Active Mutations with isMutating in TanStack Query
DESCRIPTION: The isMutating method returns an integer representing how many mutations in the cache are currently fetching. It can be used to check if any mutations are in progress.
SOURCE: https://github.com/tanstack/query/blob/main/docs/reference/QueryClient.md#2025-04-19_snippet_20

LANGUAGE: tsx
CODE:
```
if (queryClient.isMutating()) {
  console.log('At least one mutation is fetching!')
}
```

----------------------------------------

TITLE: Injecting QueryClient in TypeScript
DESCRIPTION: This snippet demonstrates how to use the injectQueryClient function to inject the QueryClient instance into a component or service.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/functions/injectqueryclient.md#2025-04-19_snippet_0

LANGUAGE: typescript
CODE:
```
const queryClient = injectQueryClient()
```

----------------------------------------

TITLE: Using matchQuery Utility in TanStack Query
DESCRIPTION: Example of using the matchQuery utility function to check if a query matches specified filter conditions.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/filters.md#2025-04-19_snippet_2

LANGUAGE: tsx
CODE:
```
const isMatching = matchQuery(filters, query)
```

----------------------------------------

TITLE: Defining CreateInfiniteQueryOptions Type Alias in TypeScript
DESCRIPTION: This code snippet defines a type alias for CreateInfiniteQueryOptions, which extends InfiniteQueryObserverOptions. It includes six type parameters for query function data, error, data, query data, query key, and page parameter.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/reference/type-aliases/createinfinitequeryoptions.md#2025-04-19_snippet_0

LANGUAGE: typescript
CODE:
```
type CreateInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryData, TQueryKey, TPageParam>: InfiniteQueryObserverOptions<TQueryFnData, TError, TData, TQueryData, TQueryKey, TPageParam>;
```

----------------------------------------

TITLE: Using Mutation Variables in Solid.js
DESCRIPTION: This snippet illustrates how to use mutation variables with the useMutation hook in Solid.js. It shows how to pass variables to the mutation function and how to access them in the mutation callback.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/solid/reference/useMutation.md#2025-04-19_snippet_2

LANGUAGE: javascript
CODE:
```
function App() {
  const mutation = useMutation(() => (newTodo) => {
    return postTodo(newTodo)
  })

  return (
    <div>
      {mutation.isPending ? (
        'Adding todo...'
      ) : (
        <>
          {mutation.isError ? (
            <div>An error occurred: {mutation.error.message}</div>
          ) : null}

          {mutation.isSuccess ? <div>Todo added!</div> : null}

          <button
            onClick={() => {
              mutation.mutate({ id: new Date(), title: 'Do Laundry' })
            }}
          >
            Create Todo
          </button>
        </>
      )}
    </div>
  )
}
```

----------------------------------------

TITLE: Disabling Window Focus Refetching for a Specific Query in Angular Query
DESCRIPTION: This snippet demonstrates how to disable window focus refetching for a specific query using the injectQuery function. It sets the refetchOnWindowFocus option to false for a query that fetches todos.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/window-focus-refetching.md#2025-04-19_snippet_1

LANGUAGE: typescript
CODE:
```
injectQuery(() => ({
  queryKey: ['todos'],
  queryFn: fetchTodos,
  refetchOnWindowFocus: false,
}))
```

----------------------------------------

TITLE: Query Client with Custom Data Serialization
DESCRIPTION: Configuration for query client with custom serialization and deserialization support for non-JSON data types.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/advanced-ssr.md#2025-04-19_snippet_10

LANGUAGE: typescript
CODE:
```
import { QueryClient, defaultShouldDehydrateQuery } from '@tanstack/react-query'
import { deserialize, serialize } from './transformer'

function makeQueryClient() {
  return new QueryClient({
    defaultOptions: {
      hydrate: {
        deserializeData: deserialize,
      },
      dehydrate: {
        serializeData: serialize,
      },
    },
  })
}
```

----------------------------------------

TITLE: Implementing isError Method for Mutation State Narrowing in TypeScript
DESCRIPTION: Type predicate method that narrows a mutation result to the error state, allowing type-safe access to error-specific properties.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/interfaces/basemutationnarrowing.md#2025-04-19_snippet_0

LANGUAGE: typescript
CODE:
```
isError: (this) => this is CreateMutationResult<TData, TError, TVariables, TContext, Override<MutationObserverErrorResult<TData, TError, TVariables, TContext>, Object> & Object>;
```

----------------------------------------

TITLE: Accessing TanStack Query Result Properties in TypeScript
DESCRIPTION: This snippet demonstrates the type definitions and usage of various properties available in the TanStack Query result object. It includes status indicators, data and error properties, fetch statuses, and utility functions.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/reference/useQuery.md#2025-04-19_snippet_1

LANGUAGE: typescript
CODE:
```
interface QueryResult<TData, TError> {
  status: 'idle' | 'pending' | 'error' | 'success';
  isPending: boolean;
  isSuccess: boolean;
  isError: boolean;
  isLoadingError: boolean;
  isRefetchError: boolean;
  data: TData | undefined;
  dataUpdatedAt: number;
  error: TError | null;
  errorUpdatedAt: number;
  isStale: boolean;
  isPlaceholderData: boolean;
  isFetched: boolean;
  isFetchedAfterMount: boolean;
  fetchStatus: 'fetching' | 'paused' | 'idle';
  isFetching: boolean;
  isPaused: boolean;
  isRefetching: boolean;
  isLoading: boolean;
  isInitialLoading: boolean;
  failureCount: number;
  failureReason: TError | null;
  errorUpdateCount: number;
  refetch: (options: { throwOnError: boolean, cancelRefetch: boolean }) => Promise<UseQueryResult>;
  promise: Promise<TData>;
}
```

----------------------------------------

TITLE: Checking Fetch Status in TSX
DESCRIPTION: Example of using queryClient.isFetching to check if any queries are currently fetching data.
SOURCE: https://github.com/tanstack/query/blob/main/docs/reference/QueryClient.md#2025-04-19_snippet_19

LANGUAGE: tsx
CODE:
```
if (queryClient.isFetching()) {
  console.log('At least one query is fetching!')
}
```

----------------------------------------

TITLE: Using Prefetched Data in Svelte Component
DESCRIPTION: Svelte component implementation that uses the prefetched query data.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/ssr.md#2025-04-19_snippet_6

LANGUAGE: svelte
CODE:
```
<script lang="ts">
  import { createQuery } from '@tanstack/svelte-query'

  const query = createQuery({
    queryKey: ['posts'],
    queryFn: async () => (await fetch('/api/posts')).json(),
  })
</script>
```

----------------------------------------

TITLE: Correct Query Key Implementation in TanStack Query (TSX)
DESCRIPTION: These examples show the correct way to implement query keys by including all variables used in the queryFn. This ensures proper caching and automatic refetching when dependencies change.
SOURCE: https://github.com/tanstack/query/blob/main/docs/eslint/exhaustive-deps.md#2025-04-19_snippet_1

LANGUAGE: tsx
CODE:
```
useQuery({
  queryKey: ['todo', todoId],
  queryFn: () => api.getTodo(todoId),
})

const todoQueries = {
  detail: (id) => ({ queryKey: ['todo', id], queryFn: () => api.getTodo(id) }),
}
```

----------------------------------------

TITLE: Importing useQueries from TanStack Query in JavaScript
DESCRIPTION: This snippet shows how to import the useQueries hook from the TanStack Query library. It demonstrates the import statement for both React and Vue versions of the library.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/reference/useQueries.md#2025-04-19_snippet_0

LANGUAGE: javascript
CODE:
```
import { useQueries } from '@tanstack/react-query'
```

LANGUAGE: javascript
CODE:
```
import { useQueries } from '@tanstack/vue-query'
```

----------------------------------------

TITLE: Starting TanStack Query Angular Pagination Example
DESCRIPTION: This code snippet demonstrates how to start the TanStack Query Angular pagination example project using different package managers. It includes commands for npm, yarn, pnpm, and bun.
SOURCE: https://github.com/tanstack/query/blob/main/examples/angular/pagination/README.md#2025-04-19_snippet_1

LANGUAGE: Shell
CODE:
```
npm run start
```

LANGUAGE: Shell
CODE:
```
yarn start
```

LANGUAGE: Shell
CODE:
```
pnpm start
```

LANGUAGE: Shell
CODE:
```
bun start
```

----------------------------------------

TITLE: Using Mutation Filters in TanStack Query
DESCRIPTION: Examples of using MutationFilters to check mutation status and filter mutations based on mutation keys and predicate functions.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/filters.md#2025-04-19_snippet_1

LANGUAGE: tsx
CODE:
```
// Get the number of all fetching mutations
await queryClient.isMutating()

// Filter mutations by mutationKey
await queryClient.isMutating({ mutationKey: ['post'] })

// Filter mutations using a predicate function
await queryClient.isMutating({
  predicate: (mutation) => mutation.state.variables?.id === 1,
})
```

----------------------------------------

TITLE: Using fetchQuery with Stale Time Configuration
DESCRIPTION: Shows how to fetch query data with a specified staleTime to control when data should be refetched.
SOURCE: https://github.com/tanstack/query/blob/main/docs/reference/QueryClient.md#2025-04-19_snippet_2

LANGUAGE: tsx
CODE:
```
try {
  const data = await queryClient.fetchQuery({
    queryKey,
    queryFn,
    staleTime: 10000,
  })
} catch (error) {
  console.log(error)
}
```

----------------------------------------

TITLE: Defining QueriesResults Type Alias in TypeScript for TanStack Query
DESCRIPTION: A recursive type alias that maps query parameters to their respective results. It uses depth checking to prevent excessive recursion depth, and handles different array patterns for proper type inference.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/type-aliases/queriesresults.md#2025-04-19_snippet_0

LANGUAGE: typescript
CODE:
```
type QueriesResults<T, TResult, TDepth>: TDepth["length"] extends MAXIMUM_DEPTH ? QueryObserverResult[] : T extends [] ? [] : T extends [infer Head] ? [...TResult, GetResults<Head>] : T extends [infer Head, ...(infer Tail)] ? QueriesResults<[...Tail], [...TResult, GetResults<Head>], [...TDepth, 1]> : T extends QueryObserverOptionsForCreateQueries<infer TQueryFnData, infer TError, infer TData, any>[] ? QueryObserverResult<unknown extends TData ? TQueryFnData : TData, unknown extends TError ? DefaultError : TError>[] : QueryObserverResult[];
```

----------------------------------------

TITLE: Using Stable Function Reference for Select
DESCRIPTION: Demonstrates how to optimize the select function by extracting it to a stable function reference outside the component.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/render-optimizations.md#2025-04-19_snippet_2

LANGUAGE: javascript
CODE:
```
const selectTodoCount = (data) => data.length

export const useTodoCount = () => {
  return useTodos(selectTodoCount)
}
```

----------------------------------------

TITLE: Defining CreateQueryOptions Type Alias in TypeScript
DESCRIPTION: This code snippet defines the CreateQueryOptions type alias with four generic type parameters. It extends the CreateBaseQueryOptions type with the same type parameters, providing options for creating a query.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/reference/type-aliases/createqueryoptions.md#2025-04-19_snippet_0

LANGUAGE: typescript
CODE:
```
type CreateQueryOptions<TQueryFnData, TError, TData, TQueryKey>: CreateBaseQueryOptions<TQueryFnData, TError, TData, TQueryFnData, TQueryKey>;
```

----------------------------------------

TITLE: Initializing usePrefetchQuery Hook in React TypeScript
DESCRIPTION: Demonstrates the basic usage syntax of the usePrefetchQuery hook. This hook is used to prefetch queries during render, particularly before suspense boundaries containing useSuspenseQuery. It requires a queryKey and usually a queryFn parameter.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/reference/usePrefetchQuery.md#2025-04-19_snippet_0

LANGUAGE: tsx
CODE:
```
usePrefetchQuery(options)
```

----------------------------------------

TITLE: Using QueryCache.find Method
DESCRIPTION: Shows how to retrieve an existing query instance from the cache using the find method. Returns undefined if query doesn't exist.
SOURCE: https://github.com/tanstack/query/blob/main/docs/reference/QueryCache.md#2025-04-19_snippet_1

LANGUAGE: tsx
CODE:
```
const query = queryCache.find(queryKey)
```

----------------------------------------

TITLE: Implementing Mutation Callbacks
DESCRIPTION: Demonstrates using the new mutation pattern with callback functions for success, error, and settlement handling.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-react-query-3.md#2025-04-19_snippet_5

LANGUAGE: tsx
CODE:
```
const { mutate } = useMutation({ mutationFn: addTodo })

mutate('todo', {
  onSuccess: (data) => {
    console.log(data)
  },
  onError: (error) => {
    console.error(error)
  },
  onSettled: () => {
    console.log('settled')
  },
})
```

----------------------------------------

TITLE: isError Method for Query Status Checking in TypeScript
DESCRIPTION: The isError method checks if a query is in an error state and provides type narrowing to an error result type. It takes the current instance as a parameter and returns a type predicate that narrows the type to an error result.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/interfaces/basequerynarrowing.md#2025-04-19_snippet_0

LANGUAGE: typescript
CODE:
```
isError: (this) => this is CreateBaseQueryResult<TData, TError, CreateStatusBasedQueryResult<"error", TData, TError>>;
```

----------------------------------------

TITLE: Declaring Optional Filters Property in MutationStateOptions
DESCRIPTION: Defines an optional filters property of type MutationFilters within the MutationStateOptions type alias.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/reference/type-aliases/mutationstateoptions.md#2025-04-19_snippet_1

LANGUAGE: typescript
CODE:
```
optional filters: MutationFilters;
```

----------------------------------------

TITLE: Defining StoreOrVal Generic Type Alias in TypeScript
DESCRIPTION: This code snippet defines a generic type alias named StoreOrVal that can represent either a base type T or a Svelte Readable store of type T. It's used to allow flexibility in function parameters or return types where either the value itself or a reactive store of that value can be accepted or returned.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/reference/type-aliases/storeorval.md#2025-04-19_snippet_0

LANGUAGE: typescript
CODE:
```
type StoreOrVal<T>: T | Readable<T>;
```

----------------------------------------

TITLE: Linear Backoff Implementation
DESCRIPTION: Example of a linear backoff implementation for retry delay calculation.
SOURCE: https://github.com/tanstack/query/blob/main/docs/framework/solid/reference/useQuery.md#2025-04-19_snippet_6

LANGUAGE: typescript
CODE:
```
attempt => attempt * 1000
```